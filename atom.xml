<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="https://keechang-choi.github.io/atom.xml" rel="self" type="application/atom+xml" /><link href="https://keechang-choi.github.io/" rel="alternate" type="text/html" /><updated>2024-05-26T21:47:54+09:00</updated><id>https://keechang-choi.github.io/atom.xml</id><title type="html">KC blog</title><subtitle>일상 및 공부 기록</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><entry><title type="html">Vulkan Graphics Examples - Cloth</title><link href="https://keechang-choi.github.io/study/study-vge-cloth/" rel="alternate" type="text/html" title="Vulkan Graphics Examples - Cloth" /><published>2024-05-03T00:00:00+09:00</published><updated>2024-05-03T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-vge-cloth</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-vge-cloth/"><![CDATA[<ul>
  <li><a href="#theoretical-background">Theoretical Background</a>
    <ul>
      <li><a href="#existing-example-implementation">Existing example implementation</a></li>
      <li><a href="#pbd-lecture-summary">PBD lecture summary</a>
        <ul>
          <li><a href="#lec-14">Lec 14</a></li>
          <li><a href="#lec-15">Lec 15</a></li>
          <li><a href="#lec-16">Lec 16</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#implementation">Implementation</a>
    <ul>
      <li><a href="#plans">Plans</a>
        <ul>
          <li><a href="#implementation-items">Implementation items</a></li>
        </ul>
      </li>
      <li><a href="#ssbo-draw">SSBO draw</a></li>
      <li><a href="#constraint-compute">Constraint compute</a></li>
      <li><a href="#triangle-mesh--normal-vector">Triangle mesh \&amp; Normal vector</a>
        <ul>
          <li><a href="#stretch-constraint-demo">stretch constraint demo</a></li>
          <li><a href="#atomic-operations">Atomic operations</a></li>
        </ul>
      </li>
      <li><a href="#mouse-ray-casting-interaction">Mouse Ray casting interaction</a></li>
      <li><a href="#geometry-shader">Geometry shader</a></li>
      <li><a href="#results--further-study">Results \&amp; Further study</a>
        <ul>
          <li><a href="#demo">Demo</a></li>
          <li><a href="#todos--not-todos">TODOs \&amp; Not TODOs</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a>
    <ul>
      <li><a href="#근황">근황</a></li>
    </ul>
  </li>
</ul>

<h1 id="theoretical-background">Theoretical Background</h1>

<p>cloth simulation on GPU에 대한 내용을 다루고, 구현 내용을 다루려 한다.<br />
PBD에서의 시뮬레이션 모델을 다루기 전에, 기존 example repo에서 vulkan compute shaderf를 사용한 기본적인 cloth simulation 예제가 있어서 이 예제 구조를 먼저 살펴봤다.</p>

<h2 id="existing-example-implementation">Existing example implementation</h2>

<p>참고한 SaschaWillems Vulkan example 코드</p>
<ul>
  <li><a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/computecloth/computecloth.cpp">Vulkan/examples/computecloth/computecloth.cpp at master · SaschaWillems/Vulkan (github.com)</a></li>
  <li><a href="https://github.com/SaschaWillems/Vulkan/blob/master/shaders/glsl/computecloth/cloth.comp">Vulkan/shaders/glsl/computecloth/cloth.comp at master · SaschaWillems/Vulkan (github.com)</a></li>
</ul>

<p>이 예제에서는 cloth를 grid 형태의 particles로 보고, 이 particle 간의 상호작용을 compute shader에서 계산한다.</p>
<ul>
  <li>cloth model: 간단한 grid 형태만 다루기 때문에, 별도의 cloth model을 load 하지 않고, 직접 grid의 particle position을 지정해서 생성한다.
    <ul>
      <li>우리는 이후 더 복잡한 형태의 옷을 다룰 것을 염두해 두고 gltf model로 cloth 구조를 불러오려 한다. (일단은 동일한 grid 형태의 간단한 구조만 먼저 추가하긴 할 계획이다.) 기존 animation에서 다뤘던 gltf load 구조를 그대로 사용하되, ssbo 중 vertex buffer는 사용하지 않고, index buffer만 사용하는 식으로 이용할 계획이다. model의 texture 등은 그대로 쓰면 된다.</li>
    </ul>
  </li>
  <li>SSBO
    <ul>
      <li>예제에서는 생성한 초기 grid particle을 담을 input ssbo와 compute 결과를 담을 output ssbo를 별도로 둔다. 이 output은 graphics pipeline에서도 rendering에 사용한다.</li>
      <li>우리는 input은 model load에서 불러온 값을 사용할 것이라 별도의 ssbo를 추가할 필요는 없고, compute와 graphics pipeline에서 공용으로 사용할 ssbo는 새로 추가해야 한다. 이를 위해 관련 자원을 담을 cloth model 구조를 추가할 계획이고, 이전부터 변경해왔던대로 frames in flight 수를 고려해서 자원들을 추가하면 된다.</li>
    </ul>
  </li>
  <li>graphics pipeline
    <ul>
      <li>예제에서는 cloth를 rendering 할 pipeline과, 간단한 거리 collision interactiond을 위한 sphere pipeline을 가지고 있다.</li>
      <li>우리도 cloth를 그려줄 pipelines (texture사용과 wireframe)을 추가해줘야 한다. 따로 sphere를 위한 graphics pipeline은 필요없고, 이전부터 사용해오던 phong shading을 적용한 다른 model들(사과나 여우 모델 사용) graphics pipeline은 유지한다.</li>
    </ul>
  </li>
  <li>compute pipeline
    <ul>
      <li>semaphores
        <ul>
          <li>이전에 particle 관련 compute shader 예제를 작성할때, 추가했던 부분과 동일한데, 코드 형태만 조금 다르다. compute dedicated queue를 사용하면서, 서로 다른 queue family 간의 공유되는 memory(ssbo)의 ownership transfer operation (acquire과 release)의 sync를 위해 graphics와 compute에 semaphore를 하나씩 (frames in flight 만큼) 추가로 사용했던 부분에 해당한다.
            <ul>
              <li><a href="/_posts/2023-10-02-study-vge-particles.md##synchronization">이전 particles 예제의 sync관련 내용</a></li>
              <li>저번에 찾은 버그도 있어서 같이 수정할 계획이다. compute dedicated queue가 supported 되지 않으면 이 ownership transfer가 없어도 되고, pipeline barrier나 아니면 semaphore (compute와 graphics submit된 command의 사이의 sync를 위한) 로도 충분하기 때문이다.</li>
              <li>우리는 일관된 구조를 위해서, transfer operation만 분기처리하고, semaphore를 그대로 사용한다. 대신 graphics에 두던 sema를 제거하고, 모두 compute로 옮겨 이름을 예제와 같이 ready, complete로 쓸 계획.</li>
            </ul>
          </li>
          <li>uniform buffer
            <ul>
              <li>dt, mass, stiffness, damping, rest distance, gravity, particle count</li>
              <li>등을 쓰고 있고, 우리도 유사하게 쓰일 것들만 선택해서 추가한다.</li>
            </ul>
          </li>
          <li>storage buffer
            <ul>
              <li>cloth와 간단한 충돌에 쓰일 sphere 한개만 별도로 사용하고 있는데, 우리는 여러개의 sphere를 다뤄볼 예정이다.</li>
              <li>기존 animating model과의 collision을 다룰 생각이라 별도 구조를 쓰지 않아도 될 수도 있다. 이 부분은 최적화를 위해서는 collision 처리에 대한 구현이 잘 되어야 하는데, hash사용이나 tree 구조 등 내용을 구현하기에는 cloth simulation 주제에서 벗어나는 부분이 많아 성능을 감수하고 최대한 간단하게 구현해볼 계획</li>
            </ul>
          </li>
          <li>descriptor sets
            <ul>
              <li>2개의 readset을 두고 descriptor sets를 iteration에서 교차로 사용하는 구조로 구현되어 있다.</li>
              <li>input을 받아서 output에 쓰고, output을 받아서 input에 쓰는 형태 때문에 이렇게 구현된 것으로 보이는데, 우리는 double 혹은 N-buffering을 쓸거라 이전에 하던 것처럼 prevFrameIndex를 쓰면 된다. cloth ssbo에서도 input output 구분이 필요 없는 것과 같은 이유.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="pbd-lecture-summary">PBD lecture summary</h2>

<p><a href="https://matthias-research.github.io/pages/tenMinutePhysics/index.html">Ten Minute Physics</a></p>

<p>cloth simulation의 개념적인 부분은 모두 PBD의 내용을 따랐다.
3개 lecture에 해당하는 영상과 note를 보고 몇가지 내용을 선택, 변경해서 반영했다.
내용들은 이해한 부분들을 간단히 정리만 해두려 한다.</p>
<h3 id="lec-14">Lec 14</h3>

<p><img src="https://www.youtube.com/watch?v=z5oWopN39OU" alt="" /></p>

<p>observation:</p>
<ul>
  <li>cloth is stretchable</li>
  <li>처음 5%까지의 힘에서만 길이가 늘어나고 그 이후로는 거의 일정함.</li>
  <li>중력이 옷을 늘리는 일은 거의 없다.</li>
  <li>stretching이 너무 없는 cloth simulation이 많다.</li>
  <li>하지만 너무 많은 stretching은 시각적 효과 측면에서 보기 좋지 않다.</li>
  <li>latex같은 재질은 dynamics가 없고 거의 정적인 motion을 이루기 때문에, skeleta skinning 방식으로 처리하는게 낫다고 한다.</li>
</ul>

<p>결론:</p>
<ul>
  <li>복잡한 cloth model들은 그 늘어나는 5% 의 힘 구간을 simulation하기 위한 것.</li>
  <li>우리는 stiffness가 inf인 material을 가정하고 simulation 하고자 함.</li>
  <li>force 기반의 방식은 explode하는 문제가 있음.</li>
  <li>우리가 취할 방식은 zero compliance distance constraint on cloth mesh edges with XPBD
    <ul>
      <li>이 방식은 parameter tuning이 필요 없어서 좋다.</li>
    </ul>
  </li>
</ul>

<p>Bending Resistance</p>
<ul>
  <li>하나의 parameter가 필요함.</li>
  <li>두 인접한 삼각형간의 constraing로 접근
    <ul>
      <li>반대편 두 점 (공유된 edge 가 아닌)의 거리 방식
        <ul>
          <li>simple하지만 flat한 형태에서 constraint가 약함
            <ul>
              <li>두 삼각형이 flat하면 (거의 구부러진 각 없이 평행하면) 조금 접히더라도 각 두 삼각형의 반대편 두점 사이의 거리 변화가 작다는 뜻으로 이해함.</li>
            </ul>
          </li>
          <li>접힌 angle 방식
            <ul>
              <li>flat 한 경우에서도 강한 조건이 됨. 하지만 계산 비용이 큼</li>
              <li>우선 더 간단한 거리 방식으로 구현해보고 각도 방식으로 개선하면 좋을 듯 함.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>triangle neighbor를 찾는 법</p>
<ul>
  <li>global edge number를 부여한다. tri_nr * 3 + local_edge_nr</li>
  <li>edge에 연결된 (v_index 낮은 것, v_index 높은 것, global_edge_nr) 이 세개를 하나의 tuple로 묶는다.
    <ul>
      <li>이 edge 별 tuple들을 lexicographic order로 정렬.</li>
      <li>이때 v_index 부분 두개가 같은 edge가 연속해서 나오면 adjacent edge임. 두 삼각형이 공유하는 edge</li>
    </ul>
  </li>
  <li>이 정보를 가지고 edge neighbor list를 구성한다.
    <ul>
      <li>-1: edge is open</li>
      <li>두 연속한 edge tuple이 adjacent edge면, 서로 반대편 global_edge_nr을 넣어준다.</li>
      <li>이 global_edge_nr만 있으면, tri_nr과 local_edge_nr 둘다 얻을 수 있음.</li>
    </ul>
  </li>
  <li>이렇게 찾은 인접 삼각형 정보를 가지고 XPBD의 constraint로 계산하는데, 이 lec14에서는 CPU 계산으로 구현되어 있다.</li>
</ul>

<h3 id="lec-15">Lec 15</h3>

<p><img src="https://www.youtube.com/watch?v=XY3dLpgOk4Q" alt="" /></p>

<p>cloth self-collision은 어려운 문제중 하나다.</p>
<ul>
  <li>soft body에는 outside와 inside가 명확해서 충돌처리가 명확하지만
    <ul>
      <li>cloth에는 in out 개념이 없다.</li>
    </ul>
  </li>
  <li>global problem이다. 접근은 여러 방식이 있다.
    <ul>
      <li>시작이 valid 했다면 그걸 유지하도록 보장하는 방식.</li>
    </ul>
  </li>
</ul>

<p>완벽한 해법은 아니더라도, 5가지 트릭을 제시함.</p>
<ul>
  <li>particles와 particle hash로 collision detection
    <ul>
      <li>복잡한 하나의 대상을 다루는게 아니라, 간단한 primitives(particle)을 여러개 많이 쓰는 접근</li>
      <li>cloth를 여러개의 particle로 보고 문제를 접근하라는 얘기 같다.</li>
      <li>구현이 간단하고 자유도가 높아 fidelity가 높다고 한다.</li>
    </ul>
  </li>
  <li>rest distance로 jiterring 피하기
    <ul>
      <li>보통 particle이 서로 2r 거리에 있기를 원하는데 그보다 가깝게 rest distance가 설정된 경우에 jittering 문제가 발생한다.</li>
      <li>충돌 constraint와 거리 constarint가 싸우면서 jittering이 발생</li>
      <li>collision 거기를 더 작은 거리로 설정해서 어느 정도 해결되지만 메모리 사용이 커진다고 함.</li>
    </ul>
  </li>
  <li>continuos collosion detection이 아닌 substeping 사용.
    <ul>
      <li>두 particle이 계산 시간간경의 처음에도 충돌하지 않고, 끝에도 충돌하지 않는 경우지만, 그 사이에서 충돌했을 경우가 있다.
        <ul>
          <li>이럴때 CCD라는 방법으로 충돌을 검출한다.</li>
          <li>swept volume의 overlap을 검사해서 검출되면 rollback하는 방식</li>
        </ul>
      </li>
      <li>이런 처리 대신 시간 간격을 더 쪼개서 substepping을 써서 이런 일을 방지하자.
        <ul>
          <li>hash 계산은 substepping loop 이전에 한번만 하라고 한다. 안그러면 너무 느려진다고 함.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>max velocity 부여
    <ul>
      <li>속도가 너무 커지면 substepping에도 불구하고 충돌을 놓치게 된다고 함.</li>
      <li>max vel을 r / t_substep 정도로 지정하면 좋다고 함.</li>
    </ul>
  </li>
  <li>unconditionally stable cloth-cloth friction 기법
    <ul>
      <li>damping coefficient를 넣어서 overshoot 하지 않도록 처리하는 기법</li>
    </ul>
  </li>
</ul>

<p>실제로 cloth simulation을 구현해보니, 이 self-intersection처리가 왜 중요한지 알게 됐다. 
기본적인 stretch, bending, shearing 등 constraint를 구현하면 아주 간단한 dynamic만 확인이 가능한데, cloth가 중력으로 인해 펼쳐지거나 흔들리는 정도이다. cloth와 animating model이나, mouse interaction을 추가했을 때, cloth가 꼬이거나, 한쪽 끝이 cloth를 통과하는 등 문제가 생기면 아예 현실적인 느낌이 들지 않았아서 이런 처리를 위한 기법이 왜 중요한지 느꼈다.<br />
여기서 소개한 trick들이 단순한 편이겠지만 self-intersection이 다른 constraint와 다르게 하나의 fancy 한 방식으로 처리되는게 아니라, 여러가지 기법을 중첩시켜 해결해야되는 문제라는 정도를 이해하고 넘어갔다.</p>

<h3 id="lec-16">Lec 16</h3>

<p><img src="https://www.youtube.com/watch?v=q4rNoupGr8U" alt="" /></p>

<p>전체적인 구조</p>
<ul>
  <li>gpu memory로 particle의 v, p(업데이트 전 x), x(업데이트 된 position)를 저장해놓는다.</li>
  <li>main memory에는 x만 있으면 된다. (mouse interaction 등을 위해서 인듯). rendering은 GPU에서 할거라 사실 main memory에 x를 남길 필요도 없을 것 같음</li>
  <li>data copy는 DMA로 이뤄진다고 함.</li>
  <li>python + warp를 쓰고, nvidia omniverse를 써서 시각화 한다.</li>
  <li>gpu에서는 thread id를 각 particle index로 mapping해서 계산한다.</li>
</ul>

<p>challenge 1</p>
<ul>
  <li>per particle loop에서는 각 thread가 각 array entry에 적어서 문제가 없다.</li>
  <li>constraints는 여러 threads가 같은 array entry에 적을 수도 있는 문제가 있다.
    <ul>
      <li>atomic add를 써야 함.</li>
      <li>좀 느려진다.</li>
    </ul>
  </li>
</ul>

<p>challenge 2</p>
<ul>
  <li>동시에 읽는 것과 쓰는 것
    <ul>
      <li>여러 constraint에서 하나의 x에 대해서 읽는 것과 쓰는 것의 순서를 보장할 수가 없다.</li>
    </ul>
  </li>
  <li>예를 들어 1번 particle의 업데이트를 위해서, 0번 particle의 위치를 읽어서 1번과의 거리를 계산해야 한다고 해보자. 0번을 읽을 때, 다른 thread에서 0번에 뭐가 쓰여지고 있는지 이 순서를 알 수 없다는 것.
    <ul>
      <li>Jacobi solver / graph coloring 두가지 방법이 있다.</li>
    </ul>
  </li>
</ul>

<p>Jacobi solver (vs. Gauss-Seidel solver)</p>
<ul>
  <li>cpu 에서는 각 constraint에서 계산한 correction을 바로 particle에 더했다.</li>
  <li>하지만 Jacobi solver에서는 d라는 correction vector에 모든 correction을 저장하고, 마지막에 한번에 particle에 적용한다.
    <ul>
      <li>(이때도 correction vector에는 atomic add)</li>
      <li>이렇게 하면 solve 도중에는 x가 변하지 않는다.</li>
      <li>하지만 error propagation이 느려서 convergence가 느려진다.</li>
      <li>그리고 overshooting 문제가 있어서 1보다 작은 계수를 곱해줘야 한다고 함.</li>
    </ul>
  </li>
  <li>correction을 전부 평균내서 더해주는 방법도 있는데,
    <ul>
      <li>(5개의 constraint가 한 particle에 적용되면 5로 나누자는 말)</li>
      <li>strength가 주변 constraint에 영향을 받게되고, momentum conservation이 위반되는 문제가 있다고 한다.</li>
    </ul>
  </li>
  <li>계수는 1/4 가 적당하다고 한다.</li>
</ul>

<p>graph coloring</p>
<ul>
  <li>계산 과정을 나눠서 전체 particle의 계산을 한번에 하지 않고 여러 pass로 나누는 방식</li>
  <li>각 pass는 독립적인 constraints로 구성된다
    <ul>
      <li>보통 cloth를 4개의 pass로 나눈다고 함.</li>
    </ul>
  </li>
  <li>하지만 이 pass 구성을 찾는 건, graphc coloring 문제를 푸는건데,
    <ul>
      <li>np hard라고 함.</li>
      <li>greedy로 적당히 작은 수의 group이 되도록 pass를 찾자.</li>
      <li>pass가 최소 한 node랑 연결된 edge 수 만큼은 필요하다
        <ul>
          <li>degree.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>구현은 stretching constraint만 graph coloring으로 하고,
    <ul>
      <li>나머지 bending 과 shear는 Jacobi로 하면 좋다고함. 이 조건들은 stiffness가 필요 없어서.</li>
    </ul>
  </li>
</ul>

<p>integration</p>
<ul>
  <li>여러 pass별로 계산한다
    <ul>
      <li>distance constraint
        <ul>
          <li>이안에 stretching, bending, shearing constraint가 전부 들어있고, 각 pass 별로 constraints에 접근할 index만 구분해준다.</li>
        </ul>
      </li>
      <li>구현할때는 간단한 사각형 grid 형태 cloth여서 constraint 초기 구성을 해준다.</li>
    </ul>
  </li>
  <li>이후에 vel update로 PBD구조 구현.</li>
</ul>

<p>구현</p>
<ul>
  <li>python구현 코드 구조를 보고 많은 부분을 참고했다.</li>
  <li>warp에서는 launch나 copy 등은 synch가 implicit하게 맞춰진다고 한다. (GPU-CPU synch <a href="https://github.com/NVIDIA/warp">https://github.com/NVIDIA/warp</a>)</li>
  <li>distConstIds에 두 v index를 pass별로 나눠서 전부 저장해놓고 하나의 ssbo로 전달한다고 볼 수 있다.</li>
  <li>이 ssbo는 read only로 둬도 될 것 같은데, 초기 rest length 계산을 gpu에서 해주려면 write가 필요하다.</li>
</ul>

<h1 id="implementation">Implementation</h1>
<h2 id="plans">Plans</h2>

<p>lec 16을 참고한 구현 구조 구상은 다음과 같다.</p>

<p>SSBO</p>
<ul>
  <li>compute에 사용할 particle 구조. x, v, p (prev position) data</li>
  <li>render에 사용할 particle 구조. normal 등</li>
  <li>dist constraint ids
    <ul>
      <li>vertex id 두개와 rest length</li>
    </ul>
  </li>
</ul>

<p>compute</p>
<ul>
  <li>각 작업의 command를 recording 하고, 이전 작업이 끝나도록 pipeline Barrier를 통해 sync 맞추도록 command 들 사이에 recording 해줘야 함.</li>
  <li>rest length 계산해서 저장
    <ul>
      <li>초기 1회만. CPU에서 해줘도 될 것 같음</li>
    </ul>
  </li>
  <li>integration
    <ul>
      <li>매 substep마다</li>
    </ul>
  </li>
  <li>solve distance constraints
    <ul>
      <li>매 substep마다. independent pass는 memory barrier없이 한번에 recording 되어도 될 듯 함.</li>
      <li>stretch 4개의 independent pass는 Gauss-Seidel solver를 쓰고 나머지 constraints들은 하나의 pass에 넣어서 Jacobi soler로 쓴다.</li>
    </ul>
  </li>
  <li>add correction
    <ul>
      <li>correction을 바로 반영할지, Jacobi solver로 할지를 pass independence에 따라서 처리</li>
    </ul>
  </li>
  <li>vel update
    <ul>
      <li>매 substep의 마지막에서</li>
    </ul>
  </li>
  <li>compute normal
    <ul>
      <li>substep이 모두 끝난 후, rendering 이전에 필요한 normal등을 업데이트</li>
    </ul>
  </li>
</ul>

<h3 id="implementation-items">Implementation items</h3>

<p>처음에는 CPU에서 simulation을 작성하고, GPU로 옮겨보면서 성능 비교를 해보고 싶었는데, 애초에 메모리 구조나 실행 구조를 생각했을 때, 아예 서로 다른 프로그램이 될 것 같아서 GPU 구현에 중심을 두고 계획부터 GPU 사용쪽에 초점을 맞췄다.</p>

<ul>
  <li>compute 부분 없이 graphics pipeline 작업
    <ul>
      <li>cloth와 다른 animating model등, wireframe rendering등을 우선 작업</li>
      <li>render에 사용될 particle buffer 자원등을 생성하고 초기화 파트 구현.</li>
    </ul>
  </li>
  <li>cloth buffer 등 자원 생성</li>
  <li>compute shader에 constraint 없이 gravity 만 추가.</li>
  <li>stretch constraint만 추가해서 동작 확인.
    <ul>
      <li>우선은 하나의 cloth에 대해서만 구현하되, 여러개의 cloth가 서로 distance constraint가 적용될 수 있도록 염두.</li>
    </ul>
  </li>
  <li>model과 collision 처리
    <ul>
      <li>우선 하나의 model과 collision만 구현하되, 구조는 여러 model과 가능하도록 염두.</li>
    </ul>
  </li>
  <li>mouse interaction
    <ul>
      <li>mouse click info를 GPU로 보내서 compute shader에서 계산해야함
        <ul>
          <li>cloth particle의 data가 전부 GPU에 있기때문에.</li>
        </ul>
      </li>
      <li>아니면 cloth particle 전체를 CPU로 copy해야하는데 굳이 그럴 필요가 없다고 생각했음.</li>
    </ul>
  </li>
</ul>

<h2 id="ssbo-draw">SSBO draw</h2>

<p>처음 cloth 데이터를 load 하고, 정지된 texture를 render하는 부분을 구현했다.
이후 바로 자원 생성하는 부분 작업을 해준 후, compute shader 에서 gravity에 영향 받는 부분을 작성했는데, 다음 이미지 처럼 particle 좌표가 이상하게 변동됐다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: left"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-1.png)</td>
      <td style="text-align: left">render doc을 열어서 particle buffer의 값들을 확인해보니 buffer에 데이터가 밀려들어가 있었고, 확인해보니 alignment 관련된 문제여서 수정할 수 있었다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-2-2.png)</td>
      <td style="text-align: left">pos 나 normal의 .w 부분을 보면 1이 들어있어야하는데, 다른 값들이 들어있는 것이 보인다. <br /> structure 형태의 data를 가지는 buffer의 값을 보기위해서는 format을 지정해줘야 하는데, 코드에 맞춰서 하단에 적어줬다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-2-1.png)</td>
      <td style="text-align: left">vertex buffer의 attribute 들은 위 처럼, vertex index와 함께 어떤 vertex가 render 되고 있는지를 같이 볼 수 있다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-0.png)</td>
      <td style="text-align: left">alignment 관련 수정을 해준 후, compute SSBO로 지정해준 pos와 normal, uv 등이 의도대로 설정되어서 rendering 시 원하는 texture와 vertex 형태가 나오게 됐다.</td>
    </tr>
    <tr>
      <td style="text-align: center"> </td>
      <td style="text-align: left"> </td>
    </tr>
  </tbody>
</table>

<h2 id="constraint-compute">Constraint compute</h2>

<p>dispatch call 관련해서 처음에 size 관련된 오류가 발생했다.
이와 관련된 여러 limit이나 숫자들이 있는데, 내용을 좀 정리해두려 한다.</p>
<ul>
  <li>참고 검색 자료
    <ul>
      <li><a href="https://stackoverflow.com/questions/68653519/maximum-number-of-threads-of-vulkan-compute-shader">https://stackoverflow.com/questions/68653519/maximum-number-of-threads-of-vulkan-compute-shader</a></li>
      <li><a href="https://www.khronos.org/opengl/wiki/Compute_Shader">https://www.khronos.org/opengl/wiki/Compute_Shader</a></li>
    </ul>
  </li>
  <li>한 dispatch call 한번에 여러 work group의 dimension이 명시된다.
    <ul>
      <li>각 work group에는 work item 여러개 (invocation)들이 실행될 것이다.</li>
      <li>예를들어 <code class="language-plaintext highlighter-rouge">dispatch(num_verts/256+1, 1, 1)</code> 이런 호출에서 <code class="language-plaintext highlighter-rouge">num_verts</code> 가 2560이라고 가정해보자</li>
      <li>work group은 11개가 될 것이고, 한 work group 안에는 256 (이건 따로 local_size_x로 명시해뒀다고 가정)의 invocation 이 있다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">maxComputeWorkGroupInvocations</code>는 이 local_size_x * local_size_y * local_size_z에 연관된 limit이다.</li>
  <li>이 각각의 xyz는  <code class="language-plaintext highlighter-rouge">maxComputeWorkGroupSize</code> 각자 xyz 별로 다른 제한도 있다. ex. (1024, 1024, 64)</li>
  <li><code class="language-plaintext highlighter-rouge">maxComputeWorkGroupCount</code> 는 dispatch 할때 work gorup의 수 제한이다.
    <ul>
      <li>ex (2147483647, 65535, 65535)</li>
    </ul>
  </li>
</ul>

<p>위 내용은 total invocations의 수에 대한 개념이고, 한번에 single execution core에서 동시에 실행가능한 invocations의 개념에는 subgroup 개념이 필요하다.</p>
<ul>
  <li>이게 중요한 이유는 결국 shared data를 잘 활용해서 최적화 할 때 실행 단위를 알아야 하기 때문.</li>
  <li>한 subgroup내에서는 invocation들이 inter-communicate 가능하다.</li>
  <li>한 lockstep에서 실행 가능한 invocation들 수와 같은 의미로 이해했는데, 이 subgroup 개념은 hardware support를 먼저 확인해야한다고 한다.</li>
</ul>

<p>이후 model의 각 vertex와 일정 거리를 유지하는 간단한 collision 처리를 구현해서 dispatch했다. 
x를 cloth particle, y를 model vertex로 mapping 해서 호출했는데, 충돌 처리가 아예 적용되지 않는 문제가 생겼다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: left"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-2.png)</td>
      <td style="text-align: left">먼저 render doc에서 compute pipeline debugging 기능을 사용해서, distance가 일정 거리 이내엔 condition에 들어오는지를 확인했는데, 아예 분기로 들어오는 경우가 없었다. <br /> 그래서 거리 값을 normal의 w에 넣어 값을 확인해봤다. <br /> normal의 w에 보이듯 거리가 전부 예상보다 큰 값이 들어있어서 각 좌표를 확인해봤다. <br /> 확인 결과 모델 vertex의 좌표가 변환되지 않은채였는데, model matrix는 animation에서 곱해주지 않고, vertex shader에서 곱하도록 이전에 구현했던 부분이 원인으로 파악됐다. (이전에 NOTE를 써놔서 다행이다.)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-3.png)</td>
      <td style="text-align: left">vertex shader에서 compute shader로 model mat 적용을 옮겨주니 지정한 거리 이내에 들어왔을 때 처리되는 것을 확인했다. <br /> 아직 normal update가 따로 없어서 눈으로 확인하기 한계가 있다. 하지만 단순한 collision 처리이기에 모델과 cloth가 뚫고 들어가는 현상은 확인했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-4.png)</td>
      <td style="text-align: left">normal 관련 구현 전 까지는 wireframe 형태로 확인하는게 더 잘 보였다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-5.png)</td>
      <td style="text-align: left">normal과 관련해서는, gltf export 시 normal을 포함하지 않도록 해서, 같은 position을 가지면 하나의 vertex가 되도록 내보내서 사용했다. 이렇게 구성된 모델을 쓰고, normal 계산은 이후 compute shader에서 직접해주는 방식으로 구현했다. <br /> compute 과정에서는 간단한 collision handle만 추가해줘서, 모델의 vertex들과 일정 거리안에 들지 않도록 처리된 모습이다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-6.png)</td>
      <td style="text-align: left">이후 distance constraint 부분을 compute shader에 추가해주기 전에, particle 정보를 initialize 하는 부분을 cpu에서 하고 ssbo로 copy 해주는 부분을 변경했다. <br /></td>
    </tr>
    <tr>
      <td style="text-align: center">아직 constraint 초기화에서 rest length 계산은 cpu에 있는 상태인데, 일부 pos에 nan 값이 들어있어서 비어있게 보이는 문제가 발생했다.</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-7.png)</td>
      <td style="text-align: left">^^ 원인은 초기화 되지 않은 값이 pos에 들어가서 사용된 것이었다. prevPos attribute를 shader에서 초기화 해주는 부분이 빠져서 발생한 문제여서 쉽게 수정 가능했다.</td>
    </tr>
  </tbody>
</table>

<p>constraint를 전달할 때, solve type (Jacobi or Gauss-Seidel) 정보는 각 constraint 별로 저장하지 않았고, constraint의 index 범위를 나눠서 pass에 저장해둔 independence 여부로 구분했다. 
이 구조에서 solve type은 별도의 pipeline으로 구성을 했고, 이때 dispatch할때 계산할 constraint의 index들이 invocation ID로 쓰이기 때문에, 각 dispatch 시, first constraint 정보가 필요했다.</p>
<ul>
  <li>solve type은 아예 specialization constants로 미리 구분해둔 별도의 pipeline으로 나눠놨다.</li>
  <li>constraint의 first와 num 정보를 push constants로 넣었서 각 dispatch command 제출에 사용했다.
    <ul>
      <li>ubo 형태나 ssbo 형태로 bind가 가능할 지 생각해봤는데, 한번 recording 할 때 사용할 constraints들 group 수 만큼의 ssbo에 이 정보를 담아두면 가능할 것 같긴했다. dynamic 형태
        <ul>
          <li>gltf 모델 load 구조에서 node마다 texture material image와 descriptor set이 있는 것 처럼.</li>
        </ul>
      </li>
      <li>어차피 전달할 data 크기가 적기때문에 push constant를 사용하기 적합하다고 생각했다.</li>
    </ul>
  </li>
</ul>

<h2 id="triangle-mesh--normal-vector">Triangle mesh &amp; Normal vector</h2>

<p>distance constraints를 처음 적용했을 때, 이상한 결과가 나왔다.
처음에는 simulation precision 문제로 예상했는데, rest length 자체가 내가 지정해준 방식과 달라보였다.</p>

<ul>
  <li>rest length check</li>
  <li>solve dist constraint 과정 디버깅</li>
</ul>

<p>rest length 계산은 처음에는 cpu에서 진행하다가, 초기화 부분을 particle 과 마찬가지로 compute shader에서 계산하도록 옮겨주었고, 이부분을 render doc에서 capture 해서 확인했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: left"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-8.png)</td>
      <td style="text-align: left">distance constraint 추가 후, 각 particle 거리가 rest length로 유지되도록 stretch constraint가 적용된 모습이다. 하지만 잘못된 거리가 들어가있는 결과이다. <br />처음에는 simulation의 float이 precision 문제가 있는 것으로 생각해서 double precision으로 늘려봤지만, 문제가 해결되지 않아 되돌렸다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-9.png)</td>
      <td style="text-align: left">초기화 과정을 render doc에서 캡쳐하기 위해서는 직접 frame을 지정해서 launch가 가능하다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-10.png)</td>
      <td style="text-align: left">constraint ssbo의 데이터 값인데, 앞 두개는 id0, id1을 마지막 항목이 rest length distance를 저장하고 있어야 한다. 이때 5.45라는 예상되지 않은 값이 들어있는 것을 확인했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-11.png)</td>
      <td style="text-align: left">디버깅과 buffer 내용을 보고 모델의 vertex index가 의도와 다르게 정렬됐다는 사실을 알게됐다. <br /> 해당 index에 맞는 vertex를 blender를 열어서 확인했다. 의도된 순서라면 y로 먼저 정렬하고, 같은 y는 x 순으로 정렬되어 있어야 하는데, 그렇지 않았다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-12.png)</td>
      <td style="text-align: left">blender에 추가했던 model의 vertex index를 정렬하는 파이썬 스크립트에서 해당 부분의 (-y, x)를 출력해봤다. <br /> blender에서 position float의 precision문제로 제대로 정렬이 안됐던 문제였고, 이를 4자리 까지로 줄여서 문제가 사라진 것을 확인했다.</td>
    </tr>
  </tbody>
</table>

<p>아래는 사용한 blender script 이다.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># https://blender.stackexchange.com/questions/36577/how-are-vertex-indices-determined/36619#36619
</span><span class="kn">import</span> <span class="nn">bpy</span>
<span class="kn">import</span> <span class="nn">bmesh</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="nb">object</span>
<span class="k">assert</span> <span class="n">ob</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="s">"MESH"</span>
<span class="n">me</span> <span class="o">=</span> <span class="n">ob</span><span class="p">.</span><span class="n">data</span>

<span class="n">bm</span> <span class="o">=</span> <span class="n">bmesh</span><span class="p">.</span><span class="n">from_edit_mesh</span><span class="p">(</span><span class="n">me</span><span class="p">)</span>

<span class="c1"># https://docs.blender.org/api/current/bmesh.types.html#bmesh.types.BMesh.verts
</span><span class="k">print</span><span class="p">(</span><span class="s">"====== sort vertex id ======"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">449</span><span class="p">].</span><span class="n">index</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">449</span><span class="p">].</span><span class="n">co</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">300</span><span class="p">].</span><span class="n">index</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">300</span><span class="p">].</span><span class="n">co</span><span class="p">)</span>

<span class="n">posList</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># https://docs.blender.org/api/current/mathutils.html
</span><span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">:</span>
		<span class="c1"># upto3 
</span>    <span class="n">coord</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">co</span><span class="p">.</span><span class="n">to_tuple</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">posList</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="o">-</span><span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="c1"># precision check
</span><span class="k">print</span><span class="p">(</span><span class="n">posList</span><span class="p">[</span><span class="mi">300</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">posList</span><span class="p">[</span><span class="mi">449</span><span class="p">])</span>


<span class="n">sortedIndices</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">posList</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

<span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sortedIndices</span><span class="p">):</span>
    <span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">index</span> <span class="o">=</span> <span class="n">rank</span>

    
<span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
<span class="n">bmesh</span><span class="p">.</span><span class="n">update_edit_mesh</span><span class="p">(</span><span class="n">me</span><span class="p">)</span>

<span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">.</span><span class="n">ensure_lookup_table</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"====== after sort ======"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">449</span><span class="p">].</span><span class="n">index</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">449</span><span class="p">].</span><span class="n">co</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">300</span><span class="p">].</span><span class="n">index</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">bm</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="mi">300</span><span class="p">].</span><span class="n">co</span><span class="p">)</span>
</code></pre></div></div>

<p>이후 constraint size에 문제가 있던 오류를 수정한 이후로, 의도된 결과를 확인할 수 있었다.</p>

<p>확인을 위해 normal vector update를 flat shading 과 average normal을 써서 smooth shading이 되도록 두가지 옵션을 구현했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-13.png)</td>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-14.png)</td>
    </tr>
  </tbody>
</table>

<h3 id="stretch-constraint-demo">stretch constraint demo</h3>

<p>stretch constraint (grid 형태에서 인접한 두 particle 간 rest length 만 유지되도록 하는 constraint)만 추가한 모습이다. bending이나 shear는 빠져있으서 실제 cloth와는 이질감이 드는 부분이 있을 수 있지만 어느정도 눈에 보이는 결과를 얻기 시작했다.</p>

<p><img src="/images/vge-cloth/ex-cloth-7-stretch.gif" alt="image" /></p>

<h3 id="atomic-operations">Atomic operations</h3>

<p>atomic add가 normal update에서도 사용되고, constraint solver 에서도 사용됐는데, laptop에서는 atomic add가 하드웨어에서 지원되지 않아서 프로그램이 아예 실행되지가 않았다.</p>

<p>이와 관련해서, vulkan feature와 extension관련된 코드를 리팩토링해줬고, logical device 생성시에 atomic add 관련 부분을 명시해줬다.</p>

<p>vulkan에는 instance extension도 (device extension)있는데 이와 헷갈렸던 것 같아 개념을 좀 찾아봤다.</p>
<ul>
  <li>instance extension은 vulkan loader support가 필요한 것들이고, graphics card와는 독립적인 개념이다. loader는 vulkan api에 포함된 내용.</li>
  <li>device extension을 사용하려면, physical device가 그 기능을 support 하는지 먼저 확인하고, logical device 생성할 때 명시하면 된다.</li>
  <li>validation layer 사용시 debug extension을 추가하는 내용 샘플
    <ul>
      <li><a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/samples/PhysicalDeviceFeatures/PhysicalDeviceFeatures.cpp">https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/samples/PhysicalDeviceFeatures/PhysicalDeviceFeatures.cpp</a></li>
    </ul>
  </li>
  <li><a href="https://docs.vulkan.org/guide/latest/enabling_features.html#enabling-features">https://docs.vulkan.org/guide/latest/enabling_features.html#enabling-features</a></li>
  <li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html">https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceShaderAtomicFloatFeaturesEXT.html</a></li>
</ul>

<p>atomic add 가 지원되지 않을때, 그냥 프로그램을 종료해도 되는데, 우회할 수 있는 방법이 있을지 조금 확인을 해봤다.</p>

<p>atomic load/store나 atomic exchange는 사용이 가능해서 이 operation들을 잘 사용하면 glsl 상에서 해결 가능한 방법이 있지 않을까 싶어서 찾아보던 중, spinlock을 구현해서 사용하는 방법이 있어 추가해봤다.</p>

<p>결론부터 말하면 실행은 확인했는데, 코드 구조에 따라서 결과가 이상한 경우도 있었고, (compiler optimizer에 의해서 뭔가 달라지는 것 같음), invocation들의 execution order를 지정해주려는 방식 자체가 공식 spec에 undefined behavior라는 의견도 있었다.</p>
<ul>
  <li><a href="https://www.gamedev.net/forums/topic/681459-compute-shader-memory-barrier-fun/5306851/?page=1">https://www.gamedev.net/forums/topic/681459-compute-shader-memory-barrier-fun/5306851/?page=1</a></li>
  <li><a href="https://community.khronos.org/t/using-spinlock-to-control-image-read-writes/69299">https://community.khronos.org/t/using-spinlock-to-control-image-read-writes/69299</a></li>
  <li><a href="https://stackoverflow.com/questions/51704683/glsl-per-pixel-spinlock-using-imageatomiccompswap">https://stackoverflow.com/questions/51704683/glsl-per-pixel-spinlock-using-imageatomiccompswap</a></li>
</ul>

<p>구현한 내용은 다음과 같다.</p>
<ul>
  <li>shared data를 하나 둬서 spinlock으로 쓴다 (여러개 둬도 될 것 같음)</li>
  <li>실제로 병렬로 실행되는 thread 개념이 subgroup 단위인데, 이 subgroup은 한 local work group 내에서 나눠진 것임
    <ul>
      <li><a href="https://www.khronos.org/blog/vulkan-subgroup-tutorial">https://www.khronos.org/blog/vulkan-subgroup-tutorial</a></li>
    </ul>
  </li>
  <li>결국 동시에 실행되는 단위나 접근은 local work group 내에서만 신경쓰면 된다고 생각해서 이를 공유하는 shared data를 spinlock으로 써서 하나의 invocation만 critical area에 접근하도록 atomic exchange로 감싸줬음.
    <ul>
      <li>atomic 연산에 memory scope와 semantics 개념이 들어가는데,</li>
      <li>scope: atomicity를 지켜야할 shader invocation들의 범위
        <ul>
          <li>다른 어떤 agent들에 대해서 atomic 해야하는지를 지정</li>
          <li>device, workgroup, subgroup, invocation, queue family</li>
        </ul>
      </li>
      <li>semantic: 다른 메모리 접근들의 순서를 제한하는 flags
        <ul>
          <li>relaxed, acquire, release, acquire release</li>
          <li>storage semantic
            <ul>
              <li>buffer, shared, image, output</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap53.html#memory-model-scope">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap53.html#memory-model-scope</a></li>
      <li><a href="https://github.com/KhronosGroup/GLSL/blob/main/extensions/khr/GL_KHR_memory_scope_semantics.txt">https://github.com/KhronosGroup/GLSL/blob/main/extensions/khr/GL_KHR_memory_scope_semantics.txt</a></li>
    </ul>
  </li>
</ul>

<p>atomic operation 관련한 개념을 좀 더 살펴보는 계기가 됐는데, 기능적으로 이런 spinlock을 invocation들의 순서를 강제하기 위해 shader 내부에서 쓰는 것은 지양해야하는 방식인 것 같아 실험적으로 구현해본 것에 의의를 두고 넘어갔다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: left"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-15.png)</td>
      <td style="text-align: left">atomic add 관련 제대로된 처리가 안되어 있을때는, normal이 계속 바뀌면서 밝기가 flickering 하는 현상이 있었는데, 사라진 모습니다. <br /> 하지만 normal에 의한 밝기가 미묘하게 밝은 듯 한 느낌이 있다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-16.png)</td>
      <td style="text-align: left">fragment shader에서 texture를 쓰는 대신, back face 구분도 지정해줬다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-17.png)</td>
      <td style="text-align: left">normal  관련 initialize를 제대로 해주지 않는 오류가 있어서 수정해주고 나니, 이전 보다 더 명확한 면들의 밝기 차이를 볼 수 있었다.</td>
    </tr>
  </tbody>
</table>

<h2 id="mouse-ray-casting-interaction">Mouse Ray casting interaction</h2>

<p>fixed point는 임시로 hard-coding 된 형태로 inv mass를 0.0으로 줘서 동작을 확인했다. (상단 좌우 두 점을 고정했다.)</p>

<p>이후 mouse interaction은 계획대로 GPU 상에서 삼각형과 barycentric coords 계산을 통해 처리했다.</p>

<ul>
  <li>click 정보로부터 ray start와 ray dir를 compute shader로 넘김. ubo 사용</li>
  <li>compute shader에서 ray와 모든 cloth triangle로의 projection 거리를 계산.
    <ul>
      <li>삼각형과 ray가 만나지 않으면 -1.</li>
      <li>이를 위해 barycentric coords 이용</li>
    </ul>
  </li>
  <li>cpu에서 거리 정보만 copy해서 가장 가까운 depth가 몇인지를 확인한다.</li>
  <li>그 triangle주의 임의 한 particle만 depth 만큼 길이를 유지한 채로, 옮긴다. (integrate 시)
    <ul>
      <li>옮길 정보 역시 ray start와 dir로 ubo로 넘겨준 값 사용.</li>
    </ul>
  </li>
  <li>이 과정이 compute ubo update에서 depth 계산이 이뤄져야하는데, 이때 single time submit으로 compute queue에 제출하고 기다리도록 구현을 했다.
    <ul>
      <li>사실 이 부분 구현을 어디에 둬야하는지 고민이 좀 됐는데, 우선 간단하게 구현하는 대신 compute queue가 매 frame 계산되길 기다려야하므로 double buffering 구현 목표와 상충되게 됐다.</li>
      <li>이 부분을 제대로 구현하려면 async compute 관련 구현을 먼저 익혀야할 것 같은데, 이후 새로운 주제로 알게되면 다시 언급할 예정이다.</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-18.png)</td>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-19.png)</td>
    </tr>
  </tbody>
</table>

<h2 id="geometry-shader">Geometry shader</h2>

<p>구현한 cloth render시, smoothing shading형태의 normal을 사용하면, 일부 둥글게 나와야할 부분에 이상한 패턴이 보이는 경우가 발생했다.</p>

<p><img src="/images/vge-cloth/vge-cloth-20.png" alt="image" /></p>

<p>average 한 normal에서만 보이는 문제이고, flat shaing에서는 문제가 없어서 normal의 값이 문제는 아닌것으로 봤지만, 우선은 좀 더 확인을 해봤다.</p>

<p>normal을 간단하게 확인하는 방식으로 geometry shader를 구성해서 normal line들을 생성하는 방법이 있어 추가해봤다.</p>

<p>geometry shader는 입력으로 primitive를 받아서 새로운 primitives를 출력해주는 shader stage인데, 이런 normal debugging에 자주 쓰인다고 한다.</p>
<ul>
  <li>새로 normal을 위한 buffer나 descriptor set을 구성하면 번거롭다.</li>
  <li>geometry shader가 성능상 좋지 않아서 debugging용도로만 자주 쓰인다고 한다.</li>
  <li>input primitive를 받아서 새로운 primitive를 방출할 수 있는데, 여러개를 하거나 방출을 안할 수도 있따.</li>
  <li>이번에는 vertex 하나를 두개의 vertex primitive로 보내서 normal line을 만들때 쓴다.</li>
  <li>geometry shader stage는 vertex shader stage와 raterization 사이에서 일어나는데, tesselation shader와 유사하지만 더 유연하다고 한다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-21.png)</td>
      <td style="text-align: center">smoothing shading을 위한 normal을 시각화 한 것. <br /> normal이 한 vertex에 하나 씩만 있다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-22.png)</td>
      <td style="text-align: center">flat shading을 위한 경우는, 각 triangle 면 마다 normal이 있어야 하므로, 한 vertex당 최대 6개 까지 normal이 보인다.</td>
    </tr>
  </tbody>
</table>

<p>normal에는 문제가 없는것을 눈으로 확인했다.<br />
혹시 모를 미세한 수치차이로 인한것인지 의심되어 interpolation qualifier 관련된 문제가 있는지 찾아봤지만 비슷한 케이스를 찾지 못했다.</p>
<ul>
  <li><a href="https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)#Fragment_shader_outputs">https://www.khronos.org/opengl/wiki/Type_Qualifier_(GLSL)#Fragment_shader_outputs</a></li>
</ul>

<p>shaing 방식의 한계인지도 모르겠어서 검색해본 결과 비슷한 예시를 찾았다.</p>
<ul>
  <li><a href="https://stackoverflow.com/questions/38070899/how-to-interpolate-normals-for-phong-shading-in-opengl">https://stackoverflow.com/questions/38070899/how-to-interpolate-normals-for-phong-shading-in-opengl</a></li>
</ul>

<p>답변에는 slerp 관련 문제라고 하는데, 결국 normal 각도가 너무 커서 rasterize에서 interpolation시 오차가 발생한 것으로 설명한다.</p>

<p>간단하게 이것이 원인이 맞는지 검증해볼 방법이 생각나지 않아서 질문 글의 stanford bunny 모델을 받아서 확인해봤는데, blender에서도 비슷한 현상이 보였다.</p>

<p><img src="/images/vge-cloth/vge-cloth-23.png" alt="image" /></p>

<p>결국 cloth normal이나, shading 구현에 오류가 있는 것은 아니라고 안심하고 이런 패턴이 발생하는 원인은 파악하지 못한채로 넘어가기로 했다. 라이팅 방식이나 rasterizer의 interpolation 방식에서 오는 한계가 아닌가 싶은데 그런것 치곤 cloth에서 저런 패턴이 너무 자주 보여서 원인 파악이 좀 더 필요한 상태다.</p>

<h2 id="results--further-study">Results &amp; Further study</h2>
<p>최종 결과로 확인한 장면들이고, 아래 demo에 해당 영상을 넣어놨다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-24.png)</td>
      <td style="text-align: center">상단 두 점을 fix 해놓고 model과 collision한 모습</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-25.png)</td>
      <td style="text-align: center">fox model animation 위로 떨어진 cloth 모습</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/vge-cloth-26.png)</td>
      <td style="text-align: center">정지된 사과 모델 위로 떨어진 cloth 모습</td>
    </tr>
  </tbody>
</table>

<h3 id="demo">Demo</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/ex-cloth-1-low.gif)</td>
      <td style="text-align: center">option들을 변경하는 장면</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/ex-cloth-2-low.gif)</td>
      <td style="text-align: center">wireframe 전환과 backface</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/ex-cloth-3-low.gif)</td>
      <td style="text-align: center">mouse drag interaction</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/ex-cloth-4-low.gif)</td>
      <td style="text-align: center">geometry shader for normal debugging</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/ex-cloth-5-low.gif)</td>
      <td style="text-align: center">single animating model collision</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/ex-cloth-6-low.gif)</td>
      <td style="text-align: center">two animating model collision  <br /> cloth의 self intersection이 구현되어 있지 않아 cloth가 꼬이도록 mouse interaction도 넣었다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-cloth/ex-cloth-8.gif)</td>
      <td style="text-align: center">stationary model and animating model collision</td>
    </tr>
  </tbody>
</table>

<h3 id="todos--not-todos">TODOs &amp; Not TODOs</h3>

<ul>
  <li>self-collision
    <ul>
      <li>이건 좀 더 자연스러운 cloth simulation 결과를 위해서는 꼭 해보고 싶은 주제다.</li>
      <li>기법에 대해 간단히 lec 15에서 봤을때는, 하나의 일관적인 method가 있다기 보다는 성능을 고려하면서 시각적으로 만족할 만한 결과를 얻기 위한 trick들을 쓰는 것으로 이해했기 때문에 좀 더 실질적인 필요가 있을 때 구현을 해볼 것 같다.</li>
    </ul>
  </li>
  <li>optimize
    <ul>
      <li>간단한 cloth model인데도 성능이 잘 안나오게 구현한 부분이 많다. 특히 collision 관련한 부분은 너무 기초적이라 결과도 안좋고 성능도 안좋다.</li>
      <li>바로 이 코드를 개선할 생각은 없고 이후에 새로운 내용들을 공부하고 얻은 지식을 활용해볼 수 있으면 적용할 것 같다.</li>
    </ul>
  </li>
  <li>multiple cloth simulation
    <ul>
      <li>구조를 계획할 때 좀 더 다양한 경우를 계획해놨는데, 구현하다보니 여러 한계로 우선 미구현인채로 마치게됐다. 성능 optimize를 하게되면 그때 좀 더 다양한 interaction을 추가할 것 같다.</li>
      <li>cloth patch 간의 연결과 여러 animation model과의 interaction을 구현전에 구조상 계획을 해뒀기 때문에 코드 구조적인 변경이 크게 필요하지는 않을 것 같다.</li>
      <li>좀 더 복잡한 cloth에 대한 simulation을 해볼 동기가 생기면 해볼 것 같다.</li>
    </ul>
  </li>
  <li>improve model collision
    <ul>
      <li>이부분은 collision handle에 대한 내용을 먼저 별도의 주제로 익히고나면 추가하려 한다.</li>
      <li>당장 cloth simulation에 포함시키기에는 주제가 너무 넓어진다고 생각한다.</li>
    </ul>
  </li>
</ul>

<p>초기에 구현하려 계획했던 부분들보다 상당히 축소된 기본 기능만 구현한 채로 마무리하게 되어서 TODO 보다 Not TODO가 더 많게 되어 찝찝한 느낌이 많이 남는다.<br />
조급하게 당장 해봐야 할 것들로 생각하지 말고, 좀 더 주제를 세분화해서 다뤄야 이 TODO 목록들을 채워나갈 수 있을 것 같다.</p>

<h1 id="마무리">마무리</h1>

<p>이전에 vulkan api 관련 공부를 시작하면서 초기부터 compute shader나 이런 simulation 예제를 보고 나도 만들어보고 싶다고 생각했었다.<br />
몇가지 예시를 구현해보니 확실히 재미도 있고, 눈에 보이는 것 외에 훨씬 많은 어려움이 뒤에 숨어 있다고 느꼈다.<br />
원래는 이직 준비를 하는 겸, 관심있던 computer graphics 의 기본적인 개념을 학습하고자했던 의도로 생각하면 이런 예제들을 다듬게 되면서 소요되는 시간이 예상보다 더 오래 걸려서 학습해야할 주제들을 많이 커버하지 못한다고 느꼈다. 정작 관심있던 채용 포지션 중에 지원하지 못했던 것 들도 이나 하지 않았던 것들도 있고, 면접 과정에서 생각보다 내가 공부하고 있는 속도나 커버리지가 graphics engineer가 요구하는 커버리지에 부족한 점들도 있는 것 같았다. (물론 몇몇 포지션과는 준비한 방향성에서 차이가 있음을 느끼기도 했다.) 
면접 준비와 면접 과정에서 몇가지 주제는 좀 우선적으로 다뤄봐야겠다고 느낀 것이 있는데, 다음 항목들이고 앞으로 우선적으로 다뤄보려고 한다.</p>
<ul>
  <li>deferred rendering</li>
  <li>depth-stencil</li>
  <li>multi-thread command buffer</li>
</ul>

<h2 id="근황">근황</h2>

<p>최근 이직을 하고나서 원래 진행하던 이 cloth simulation 주제를 끝마치고 블로그에 올리기 위한 자료나 글 정리만을 하고 있었는데, 이것만으로도 몇주가 지나간 것 같다. 이렇게 주말 등의 시간을 쪼개서 조금씩 글을 추가하고 있었는데, 오늘이 돼서야 어느정도 초안을 마무리하고 올리게 돼서 다행이라고 생각한다. 그리고 혼자만 보는 블로그더라도, 글로 과정을 기록하고 생각했던 것들을 정리해두는 것은 확실히 업무에서도 도움이 되고 있다. 소통이나 진행상황 공유를 말로 하는 것보다 문서화해서 진행하는 것은 이전 직장에서도 강조되었던 내용들인데, 그나마 쉬는 기간에도 어느정도 기록하는 습관들 둬서 그런지 그런 부분에서는 수월하게 적응했다.</p>

<p>요즘 하는 일은 3D mesh를 생성하는 일을 하고 있는데, 요구 조건에 맞게 생성하고 잘 배치하는 작업들을 효율적으로 할 수 있게 자동화 하는 작업들을 하고 있고 3D 아티스트 분들과도 소통하며 협업하고 있다. 지금 하는일은 computer graphics 분야로 보면 geometry나 modeling에 가까운 부분이라고 생각이된다. 입사과정에서도 graphics engineer 포지션으로 지원하면서 내가 rendering이나 animation(simulation)쪽에 관심이 있음을 밝히기도 했고 맡게될 업무는 geometry나 정적인 model을 다루는 쪽일 수 있다고 상호 인지했던터라 불만이 있다거나 그런 상태는 아니다. 사실 나도 graphics engineer로의 커리어를 희망하면서도 막상은 graphics engineer라면 정확히 뭘 해야한다 거나 보통 어떤 업무를 맡는다는 등의 경험이나 판단 기준이 있지는 않으니, 일단은 이전보다 한단계 더 관심분야에 가까워진다는 측면에서는 이점이 있다고 판단하고 최종 결정을 한 것이기도 하다. 한가지 희망했던 건 graphics engineer의 senior 개발자가 있기를 희망했는데, 그 부분에서는 기대와 맞지 않는 부분도 있는 것 같다. 팀 domain에 해당하는 senior 분들이 팀에 계시고, 옆 팀이나 주변 팀에 graphics engineer분들이 계시는 걸로 파악하고 있어서 보고 배우자 한다면, 나 스스로 하기 나름일 것 같기도 하다.</p>

<p>업무 방식 측면에서는, 다른 팀이나 다른 분야의 전문가와 협업하는 과정에서 가장 중요하다고 느낀 것은 역시 요구사항을, (specification을) 사전에 명확히 하는 것이다. 어떤 결과를 원하는지, 그 결과에 어떤 특성들이 있을 수록 좋은지, 그 특성을 정량화할 수 있는지, 그렇다면 어느 정도 수치를 만족해야하는지, 더 나아가서는 왜 그런 특성들이 필요하고 그 결과가 어디에 쓰이는지에 대한 context 파악까지 할수 있어야 서로 만족할만한 결과물을 얻는다는 점을 느끼고 있다. 지금까지는 업무를 시작할때 이런 specification을 가지지 못한 채로 시작하고 있어서 작업을 진행하면서 중간결과를 전달하고 오는 피드백을 통해서 정리중이다. 이후에는 내가 아니더라도 이런 업무를 맡는 다음 사람을 생각하며 초기 계획을 위해서는 이런 specification을 잘 남기고 서로 잘 소통할 수 있도록 염두해두고 일하고 있다. 분야 특성상 눈으로 결과를 봐야한다거나, QA가 필요하다거나 하는 특성이 있을 수 있는데, 적어도 내가 작업하기 편한 언어에서는 최대한 많은 특성들이 정량화되고 그 수치를 달성하는 것을 목적으로 작업하는게 편하다. 아마 대부분의 개발자는 그렇지 않을까.</p>

<p>세부적인 개발 측면에서 아직은 주로 python 코드를 쓰고 있는데, 다른 python의 open source 기반 패키지들은 대부분 openGL renderer에 기반을 두고 있는게 상당히 많다고 느꼈다. 그리고 대부분 C++로 개발된 라이브러리를 python으로 포팅된 바인딩들을 쓰는 경우가 많은데 그럴때 C++ 측에서 integration 작업이나 자료가 많아서 참고용으로 보고 있는 정도다. 이후에 C++ 이나 다른 언어를 사용할때에는 상용 게임엔진을 다루거나 할 때 정도로 예상중이다.</p>

<p>아직 몇달이 채 되지 않아서 이런 작업을 계속하게 될지 혹은 다른 업무를 맡을지는 모르겠는데, 지금까지 일의 형태는 이전 직장에서 하던 양상과 크게 다르지 않아 큰 어려움은 없다고 생각하고 있다.(타 도메인 전문가와 소통하며 어떤 결과물을 만들어내거나 요구사항에 맞춰서 어떤 프로세스를 자동화 한다거나 하는 큰 개념에서 유사하다.) 조금 다른점은 이전 직장에서는 하나의 프로젝트를 여러명에서 contributor로 같이 진행하면서 review하고 배포하는 느낌이었다면, 현 직장에서는 우리팀 모두가 각자 다른 일을 하고 있고 그래서인지 code를 서로 review하는 문화가 활발한 건 아닌 것 같다. (팀마다 확실히 분위기는 다르긴 한 것 같다). 물론 내가 아직 혼자서 이것저것 해볼 기회가 주어져서 reviewer나 reviewee로 할당될 일이 거의 없어서 그런 점도 있다.</p>

<p>이전 직장에서는 2d 위주의 기하 데이터를 중점으로 다뤘다면 요즘엔 2.5D 정도의 데이터를 다루고 있는 것 같다. 완전히 3D 라고 보기 어려운 부분은 다루는 데이터 도메인에 기반한 것도 있고, 내가 프로토타이핑 식으로 요즘 작업하면서 시도해보고 있는 방향에서 오는 것도 있다. 확실히 익숙한 기술이나 접근 방식이 구현비용이 적게 든다고 생각하게 돼서 인지, 먼저 떠올리고 테스트해보게 되는데, 이런 측면에서 익숙한 툴을 늘리는 것의 중요성도 느끼고 있다. graphics에서 rendering과 관련된 부분은 아직 거의 다루고 있지 않기도 한데, 뭔가 건드려볼 대상들은 확실히 많아 보이지만 내가 적은 비용으로 쉽게 접근해볼만한 익숙함이 부족해서 선뜻 파보지 않아서 그렇기도 하다고 생각한다. (예를 들자면 texture opmization 등의 주제). 관심만 있고 경험은 없는 채로 남기 싫다면 업무에서 시작을 하든, 퇴근 후 공부를 하든 뭐라도 계획을 세울 시점이다. 어느정도 기반 지식이 있어서 관련 업무를 맡는다면 일하면서 더 효율적으로 체득할 수 있을 거라 기대하고 있다.</p>

<p>그리고 상용 게임엔진 관련 사용도 어느정도 익혀두면 확실히 도움이 될것이라고 예전보다 더 강하게 느끼고 있는데, 아직 계획적인 학습 방향을 설정하지는 않고 가끔씩 궁금한 내용 한두개씩 찾아보는 정도이다. (어떤 작업을 시작하고 싶다거나, 내가 작업 의사를 표출하려면 할 줄 아는 것만 깊게 파는 것 보다는 여러가지를 건드려보는게 기회가 많이 생길 것 같다.) 관련해서 스타트업 개발자로서 더 강력하게 느끼는 점은, 내가 하고싶다거나 필요하다고 제시하는 업무를 직접 계획해서 시작해볼 수 있는 자율성과 기회가 주어진다는 점이다. top-down으로 정해진 업무나 필요한 기능을 만드는 건 당연히 해야하는 거고, 더 능동적으로 내가 제안하고 필요성을 제기해야한다고 생각하고 있다. (이전 직장에서 내가 부족했다고 생각하는 부분이기도 하다.) 그게 현재 일하는 직장에서의 장점이라고 생각하고, 어떻게 보면 이런 기회를 잘 스스로 챙기지 못하고 수동적인 태도로 일을하게 되면 큰 단점이 될 것으로 보고 있다.</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[Theoretical Background Existing example implementation PBD lecture summary Lec 14 Lec 15 Lec 16 Implementation Plans Implementation items SSBO draw Constraint compute Triangle mesh \&amp; Normal vector stretch constraint demo Atomic operations Mouse Ray casting interaction Geometry shader Results \&amp; Further study Demo TODOs \&amp; Not TODOs 마무리 근황]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vge-cloth/vge-cloth-26.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vge-cloth/vge-cloth-26.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Problem Solving: skyline</title><link href="https://keechang-choi.github.io/study/ps-skyline/" rel="alternate" type="text/html" title="Problem Solving: skyline" /><published>2024-02-20T00:00:00+09:00</published><updated>2024-02-20T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/ps-skyline</id><content type="html" xml:base="https://keechang-choi.github.io/study/ps-skyline/"><![CDATA[<p>이전에 직장에서 computational geometry study를 가진적이 있다.<br />
그때 알게된 문제인데 skyline problem이라고 하는 유명한 문제가 leetcode에도 있어서 이 문제를 풀고 개선하려고 정리했던 적이 있다.<br />
정리해두고 잊고 있었는데, 블로그에 올려두려 한다.</p>

<ul>
  <li><a href="#문제-설명">문제 설명</a></li>
  <li><a href="#기존-해법">기존 해법</a></li>
  <li><a href="#개선-알고리즘">개선 알고리즘</a></li>
  <li><a href="#아이디어">아이디어</a></li>
  <li><a href="#구현">구현</a></li>
  <li><a href="#검증-및-시각화">검증 및 시각화</a></li>
  <li><a href="#코드-자료">코드 자료</a></li>
  <li><a href="#104">10^4</a></li>
</ul>

<hr />

<h1 id="문제-설명">문제 설명</h1>

<blockquote>
  <p><a href="https://leetcode.com/problems/the-skyline-problem/">https://leetcode.com/problems/the-skyline-problem/</a></p>
</blockquote>

<p>먼저 skyline problem 문제 정의는 위 leetcode에서 명확히 알 수 있다. 간단하게는 빌딩이 여러개 겹쳐있을때, 하늘의 선이 어떻게 될지 찾으라는 문제인데 시간 복잡도를 줄이는게 핵심인 문제다.</p>

<h1 id="기존-해법">기존 해법</h1>

<p>보통 PS 에서 요구되는 입력 범위와 알고리즘은 O(n log n)을 요구한다.<br />
대부분의 해법을 찾아보면 priority queue를 활용한 방법이나, divide and merge 로 풀 수 있다.</p>

<ul>
  <li>segments에는 건물의 x 값과 건물 index를 pair로 넣고 정렬한다. (시작점과 끝점의 x 모두)</li>
  <li>priority queue에 높이와 건물이 끝나는 x 좌표를 같이 저장한다. (이때  우선순위는 높이, x좌표 큰 순)</li>
  <li>x 순으로 segment를 도는 loop.
    <ul>
      <li>현재 seg에 저장된 x 값이 현재 event x와 같을 동안 다음 seg로 반복한다. (같은 x 좌표에 여러 building이 겹칠때)
        <ul>
          <li>현재 seg에 저장된 건물의 시작 x값이 현재 event x와 같으면 높이와 끝 x 값을 pq에 추가한다.</li>
        </ul>
      </li>
      <li>pq에 들어있는 top부터 이미 event x 가 건물의 끝점을 지나간 것들은 pq에서 pop</li>
      <li>pq의 top에서 현재 높이를 얻는다. (이때 pq가 비어있으면 0이 되도록 설정)</li>
      <li>이 높이가 이미 skyline의 마지막 값과 다른 경우만 event x 와 그 높이를 추가해준다. (같으면 이어져야함)</li>
    </ul>
  </li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// find skyline given building segments in O(n log n)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">GetSkylineSlow</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">buildings</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">skyline</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">segs</span><span class="p">;</span>
    <span class="n">segs</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">buildings</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buildings</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buildings</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">segs</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">});</span>
      <span class="n">segs</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">segs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">segs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">seg_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">seg_idx</span> <span class="o">&lt;</span> <span class="n">segs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">cur_x</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ignore</span><span class="p">)</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">seg_idx</span> <span class="o">&lt;</span> <span class="n">segs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cur_x</span> <span class="o">==</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">building_idx</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ignore</span><span class="p">,</span> <span class="n">building_idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>
        <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buildings</span><span class="p">[</span><span class="n">building_idx</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_x</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]});</span>
        <span class="p">}</span>
        <span class="n">seg_idx</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// remove immediately as it ends</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span> <span class="o">&lt;=</span> <span class="n">cur_x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="kt">int</span> <span class="n">cur_height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">cur_height</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">skyline</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">skyline</span><span class="p">.</span><span class="n">back</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cur_height</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">skyline</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_height</span><span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">skyline</span><span class="p">;</span>
  <span class="p">}</span>

</code></pre></div></div>

<p>다음은 고려할 corner case등을 생각한 과정이다.</p>

<p><img src="/images/ps-skyline/ps-skyline2.png" alt="image" /></p>

<h1 id="개선-알고리즘">개선 알고리즘</h1>

<p>이 문제를 시간복잡도 O(n log h)에 풀수 있다는 정보를 study중 알게되었는데, 이때 h는 output으로 나오는 skyline의 point 수이다. 이런 알고리즘을 <a href="https://en.wikipedia.org/wiki/Output-sensitive_algorithm">output-sensitive</a> 알고리즘 이라고 하는데, 계산기하학 분야에서 자주 나온다.<br />
output의 수가 적게 예상되는 상황에서 효율적인 방식인데, skyline problem도 빌딩의 수 n이 매우 커지면 겹치는 부분들로 인해 최종 skyline의 수는 적을것으로 예상할만한 상황이다.</p>

<h1 id="아이디어">아이디어</h1>

<p>이 output-sensitive한 알고리즘의 대표적인 방식으로 convex hull 을 찾는 <a href="https://en.wikipedia.org/wiki/Chan%27s_algorithm">Chan’s algorithm</a> 이 있는데, 이와 유사한 아이디어로 문제를 접근하기로 했다.</p>

<ul>
  <li>최종 skyline의 수를 h라고 하고, 이 값은 알 수 없으므로 먼저 h*라고 guess한다.</li>
  <li>그다음 각 building을 h*개씩 묶어서 k개의 그룹을 만든다.</li>
  <li>각 그룹에서 skyline을 찾는다. (이전의 우선순위 큐 방식 사용)
    <ul>
      <li>O(k x (h* log h<em>)) = O(n log h</em>)</li>
    </ul>
  </li>
  <li>각 그룹에서 ray query를 할 수 있는 구조를 구축한다.
    <ul>
      <li>O(k x (h* log h*))</li>
    </ul>
  </li>
  <li>각 그룹의 skyline을 하나로 합친다.
    <ul>
      <li>시작점에서 모든 k개의 그룹으로 query를 날려서 가장 가까운 segment로 이동한다.
        <ul>
          <li>O(k x log h*)</li>
        </ul>
      </li>
      <li>이 query 후 이동 과정을 한번 하면 최종 skyline의 점 하나를 얻으므로,  h 번 반복하면 정답을 얻어야 한다. guess했던 h*가 h 보다 크거나 같다면 어쨌든 정답을 찾을 수 있다.
        <ul>
          <li>O(n log h*)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이제 이 h*를 작은 값에서부터 늘리면서 정답을 찾을 수 있을때까지 늘리면 된다.
    <ul>
      <li>이 늘리는 방식은 2^(2^i) 형태로 늘리는데, 이렇게 늘려야 모든 합을 계산했을 때, O(n log h)를 달성할 수 있다.</li>
    </ul>
  </li>
</ul>

<p><img src="/images/ps-skyline/ps-skyline3.png" alt="image" /></p>

<p>이 query는 다음과 같이 한 점에서 수평선으로 ray를 쐈을 때, 어떤 vertical segment와 먼저 만나는지 반환해야하는데, O(log n)의 시간복잡도를 보장해야하고, 구축할때 O(n log n)의 시간복잡도를 만족해야 한다.</p>

<p>range tree나, kd tree 등 여러 tree 구조의 데이터를 구축해야 탐색 시 시간복잡도를 만족할 것으로 생각하고 조사해봤다.<br />
결국 선택한 방식은 y좌표로 한번, x좌표로 한번 두개의 binary search를 하도록 구성하는 방식인데, 이를 구성할 때 시간을 줄이기 위해 <a href="https://en.wikipedia.org/wiki/Fractional_cascading">fractional cascading</a> 기법을 사용했다.</p>

<p>query 과정을 나타낸 모식도이며 세부 알고리즘은 구현 코드와 주석으로 대체하려한다.
<img src="/images/ps-skyline/ps-skyline4.png" alt="image" /></p>

<h1 id="구현">구현</h1>

<p><img src="/images/ps-skyline/ps-skyline5.png" alt="image" /></p>

<p>초기 구현 결과로 복잡한 예시를 넣어봤다. 오류가 몇가지 있었는데 수정한 내용이다.</p>
<ul>
  <li>next sub group point exist 중 drop 조건</li>
  <li>그후 prev로 drop하기 전에, current next y로 self drop이 더 높으면 drop하지 않도록 조건을 변경</li>
</ul>

<p>해당 이슈를 수정한 후 원하는 결과를 얻었다.<br />
<img src="/images/ps-skyline/ps-skyline6.png" alt="image" /></p>

<p>보기 편하게 20개 건물로 확인한 결과이다.</p>

<p><img src="/images/ps-skyline/ps-skyline9.png" alt="image" /></p>

<p>구현과정에서는 테스트 케이스를 하나씩 추가해가며 각 기능의 구현완료를 확인하고 넘어갔다.</p>

<h1 id="검증-및-시각화">검증 및 시각화</h1>

<p>가장 먼저 시각화 코드를 작성해서 눈으로 결과의 오류를 확인하고 수정할 부분을 건드렸다.<br />
그 이후 각 부분별로 실행시간을 확인했다.<br />
<img src="/images/ps-skyline/ps-skyline8.png" alt="image" /></p>

<ul>
  <li>preprocess는 O(n)이 예상되는 부분인데 조금 오래걸린것으로 보고, copy 최적화로 절반 가량 줄였다.</li>
  <li>subgp skyline 시간 총합</li>
  <li>각 query tree 구축 시간
    <ul>
      <li>이부분이 가장 시간을 많이 쓰고 있어서 최적화의 여지가 있지만 남겨두었다.</li>
    </ul>
  </li>
  <li>h* loop의 각각 query 시간</li>
</ul>

<p><img src="/images/ps-skyline/ps-skyline7.png" alt="image" /></p>

<p>이후에는 n을 키워가며 기존의 알고리즘과 제안한 알고리즘의 시간이 얼마나 걸리는지 측정했다.<br />
n의 범위가 작을때는 priority queue 방식이 더 빨랐지만, n이 10^6을 넘어가면서부터는 개선된 시간을 보였다. 이 n은 최적화를 통해 더 줄일 수 있을 것으로 판단했다.<br />
하지만 이런 asymptotic analysis 자체가 practical 한 측면 보다는 theoretical한 분석위주이기 때문에, 실제 알고리즘에는 불필요한 constant term을 줄일필요가 있을 것이다. 참고로 leetcode에서 제공되는 n의 최대값은 10^4으로 기존 알고리즘이 더 나은 성능을 보이는데, 여러 이론상 빠른 알고리즘들도 구현상 복작도나, n이 작은 경우 느려서 쓰이지 않는 케이스가 많이 있기때문에 큰 문제는 아니라고 생각했다.</p>

<h1 id="코드-자료">코드 자료</h1>

<details>
<summary>전체 알고리즘과 테스트 코드, 프로파일링 코드</summary>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unordered_map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Node</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">y_med</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_sorted_idx</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">left_x_cascading_map</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">right_x_cascading_map</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">left_x_cascading_map_inverse</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">right_x_cascading_map_inverse</span><span class="p">;</span>

  <span class="n">Node</span><span class="p">(</span><span class="kt">int</span> <span class="n">y_med_</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">x_sorted_idx_</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">y_med</span><span class="p">(</span><span class="n">y_med_</span><span class="p">),</span> <span class="n">x_sorted_idx</span><span class="p">(</span><span class="n">x_sorted_idx_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Tree</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">pts</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_sorted_idx</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">y_sorted_idx</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">idx_to_y_order</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">td1</span><span class="p">,</span> <span class="n">td2</span><span class="p">,</span> <span class="n">td3</span><span class="p">,</span> <span class="n">td4</span><span class="p">,</span> <span class="n">td5</span><span class="p">,</span> <span class="n">td6</span><span class="p">;</span>
  <span class="n">Tree</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">pts_</span><span class="p">)</span> <span class="o">:</span> <span class="n">pts</span><span class="p">(</span><span class="n">pts_</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// TODO: remove O(n) copys using only sort.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">begin</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">end</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">tp0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">tp1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">tp2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">time_diff</span><span class="p">;</span>

    <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="c1">// std::vector&lt;std::tuple&lt;int, int, int&gt;&gt; indexed_xy;</span>
    <span class="c1">// indexed_xy.reserve(pts_.size());</span>
    <span class="c1">// for (int i = 0; i &lt; pts.size(); i++) {</span>
    <span class="c1">//   indexed_xy.emplace_back(i, pts[i][0], pts[i][1]);</span>
    <span class="c1">// }</span>

    <span class="c1">// std::sort(indexed_xy.begin(), indexed_xy.end(),</span>
    <span class="c1">//           [](const auto&amp; a, const auto&amp; b) {</span>
    <span class="c1">//             int a_x;</span>
    <span class="c1">//             std::tie(std::ignore, a_x, std::ignore) = a;</span>
    <span class="c1">//             int b_x;</span>
    <span class="c1">//             std::tie(std::ignore, b_x, std::ignore) = b;</span>
    <span class="c1">//             return a_x &lt; b_x;</span>
    <span class="c1">//           });</span>
    <span class="c1">// x_sorted_idx.reserve(pts_.size());</span>
    <span class="c1">// for (const auto&amp; item : indexed_xy) {</span>
    <span class="c1">//   int idx;</span>
    <span class="c1">//   std::tie(idx, std::ignore, std::ignore) = item;</span>
    <span class="c1">//   x_sorted_idx.push_back(idx);</span>
    <span class="c1">// }</span>
    <span class="n">x_sorted_idx</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">pts_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="c1">// y_sorted_idx.reserve(pts_.size());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pts_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">x_sorted_idx</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="c1">// y_sorted_idx.push_back(i);</span>
    <span class="p">}</span>

    <span class="c1">// x_sorted_idx.resize(pts_.size());</span>
    <span class="c1">// std::iota(x_sorted_idx.begin(), x_sorted_idx.end(), 0);</span>
    <span class="n">tp0</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="n">y_sorted_idx</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">pts_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pts_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">y_sorted_idx</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">tp1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span>
        <span class="n">y_sorted_idx</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">y_sorted_idx</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="n">pts_</span><span class="p">](</span><span class="kt">int</span> <span class="n">i1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pts_</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pts_</span><span class="p">[</span><span class="n">i2</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="p">});</span>

    <span class="c1">// std::stable_sort(indexed_xy.begin(), indexed_xy.end(),</span>
    <span class="c1">//                  [](const auto&amp; a, const auto&amp; b) {</span>
    <span class="c1">//                    int a_y;</span>
    <span class="c1">//                    std::tie(std::ignore, std::ignore, a_y) = a;</span>
    <span class="c1">//                    int b_y;</span>
    <span class="c1">//                    std::tie(std::ignore, std::ignore, b_y) = b;</span>
    <span class="c1">//                    return a_y &lt; b_y;</span>
    <span class="c1">//                  });</span>
    <span class="n">tp2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="c1">// y_sorted_idx.reserve(pts_.size());</span>
    <span class="c1">// idx_to_y_order.resize(indexed_xy.size());</span>

    <span class="c1">// for (int i = 0; i &lt; indexed_xy.size(); i++) {</span>
    <span class="c1">//   int idx;</span>
    <span class="c1">//   std::tie(idx, std::ignore, std::ignore) = indexed_xy[i];</span>
    <span class="c1">//   idx_to_y_order[idx] = i;</span>
    <span class="c1">//   y_sorted_idx.push_back(idx);</span>
    <span class="c1">// }</span>

    <span class="n">idx_to_y_order</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">y_sorted_idx</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">y_sorted_idx</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">idx_to_y_order</span><span class="p">[</span><span class="n">y_sorted_idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="n">td1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
              <span class="p">.</span><span class="n">count</span><span class="p">();</span>

    <span class="n">td3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tp0</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
              <span class="p">.</span><span class="n">count</span><span class="p">();</span>
    <span class="n">td4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tp1</span> <span class="o">-</span> <span class="n">tp0</span><span class="p">)</span>
              <span class="p">.</span><span class="n">count</span><span class="p">();</span>
    <span class="n">td5</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tp2</span> <span class="o">-</span> <span class="n">tp1</span><span class="p">)</span>
              <span class="p">.</span><span class="n">count</span><span class="p">();</span>
    <span class="n">td6</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">tp2</span><span class="p">)</span>
              <span class="p">.</span><span class="n">count</span><span class="p">();</span>

    <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="n">root</span> <span class="o">=</span> <span class="n">ConstructTree</span><span class="p">(</span><span class="n">x_sorted_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pts</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="n">td2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
              <span class="p">.</span><span class="n">count</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">Node</span><span class="o">*</span> <span class="n">ConstructTree</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">x_sorted_idx_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y_idx_left</span><span class="p">,</span>
                      <span class="kt">int</span> <span class="n">y_idx_right</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// TODO: remove x_sorted_idx_ parameter using y indices</span>
    <span class="kt">int</span> <span class="n">y_idx_med</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_idx_left</span> <span class="o">+</span> <span class="n">y_idx_right</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y_med</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">y_sorted_idx</span><span class="p">[</span><span class="n">y_idx_med</span><span class="p">]][</span><span class="mi">1</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">x_sorted_idx_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="c1">// std::cout &lt;&lt; "Tree Construction [" &lt;&lt; y_idx_left &lt;&lt; " ~ " &lt;&lt; y_idx_right</span>
    <span class="c1">//           &lt;&lt; "]" &lt;&lt; std::endl;</span>
    <span class="c1">// std::cout &lt;&lt; "y med: " &lt;&lt; y_med &lt;&lt; std::endl;</span>
    <span class="c1">// for (const auto&amp; idx : x_sorted_idx_) {</span>
    <span class="c1">//   std::cout &lt;&lt; "(" &lt;&lt; pts[idx][0] &lt;&lt; ", " &lt;&lt; pts[idx][1] &lt;&lt; ") - ";</span>
    <span class="c1">// }</span>
    <span class="c1">// std::cout &lt;&lt; std::endl;</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">y_med</span><span class="p">,</span> <span class="n">x_sorted_idx_</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y_idx_left</span> <span class="o">==</span> <span class="n">y_idx_right</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_sorted_idx_left</span><span class="p">;</span>
    <span class="n">x_sorted_idx_left</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x_sorted_idx_right</span><span class="p">;</span>
    <span class="n">x_sorted_idx_right</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">left_x_cascading_map</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left_x_cascading_map</span><span class="p">;</span>
    <span class="n">left_x_cascading_map</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">right_x_cascading_map</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right_x_cascading_map</span><span class="p">;</span>
    <span class="n">right_x_cascading_map</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">left_x_cascading_map_inverse</span> <span class="o">=</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">left_x_cascading_map_inverse</span><span class="p">;</span>
    <span class="n">left_x_cascading_map_inverse</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">right_x_cascading_map_inverse</span> <span class="o">=</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">right_x_cascading_map_inverse</span><span class="p">;</span>
    <span class="n">right_x_cascading_map_inverse</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">left_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">left_cnt_inverse</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right_cnt_inverse</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 0~size</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x_sorted_idx_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">left_x_cascading_map</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">left_cnt</span><span class="p">);</span>
      <span class="n">right_x_cascading_map</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">right_cnt</span><span class="p">);</span>

      <span class="kt">int</span> <span class="n">y_order_i</span> <span class="o">=</span> <span class="n">idx_to_y_order</span><span class="p">[</span><span class="n">x_sorted_idx_</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">y_order_i</span> <span class="o">&lt;</span> <span class="n">y_idx_med</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x_sorted_idx_left</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x_sorted_idx_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">left_cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="n">left_cnt_inverse</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">x_sorted_idx_right</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x_sorted_idx_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">right_cnt</span><span class="o">++</span><span class="p">;</span>
        <span class="n">right_cnt_inverse</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">left_x_cascading_map_inverse</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">left_cnt_inverse</span><span class="p">);</span>
      <span class="n">right_x_cascading_map_inverse</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">right_cnt_inverse</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">left_node</span> <span class="o">=</span>
        <span class="n">ConstructTree</span><span class="p">(</span><span class="n">x_sorted_idx_left</span><span class="p">,</span> <span class="n">y_idx_left</span><span class="p">,</span> <span class="n">y_idx_med</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">right_node</span> <span class="o">=</span>
        <span class="n">ConstructTree</span><span class="p">(</span><span class="n">x_sorted_idx_right</span><span class="p">,</span> <span class="n">y_idx_med</span><span class="p">,</span> <span class="n">y_idx_right</span><span class="p">);</span>

    <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">left_node</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">right_node</span><span class="p">;</span>
    <span class="c1">// node-&gt;left_x_cascading_map = left_x_cascading_map;</span>
    <span class="c1">// node-&gt;right_x_cascading_map = right_x_cascading_map;</span>
    <span class="c1">// node-&gt;left_x_cascading_map_inverse = left_x_cascading_map_inverse;</span>
    <span class="c1">// node-&gt;right_x_cascading_map_inverse = right_x_cascading_map_inverse;</span>

    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">QueryRight</span><span class="p">(</span><span class="kt">int</span> <span class="n">qx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qy</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bound_x_sorted_idx</span> <span class="o">=</span> <span class="n">LowerBound</span><span class="p">(</span><span class="n">x_sorted_idx</span><span class="p">,</span> <span class="n">qx</span><span class="p">);</span>
    <span class="c1">// if (bound_x_sorted_idx &lt; x_sorted_idx.size() &amp;&amp;</span>
    <span class="c1">//     x_sorted_idx[bound_x_sorted_idx] == qx) {</span>
    <span class="c1">//   bound_x_sorted_idx = UpperBound(x_sorted_idx, qx) + 1;</span>
    <span class="c1">// }</span>
    <span class="kt">int</span> <span class="n">closest_right_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//   std::cout &lt;&lt; "----------------" &lt;&lt; std::endl;</span>
      <span class="c1">//   std::cout &lt;&lt; "y med: " &lt;&lt; node-&gt;y_med &lt;&lt; std::endl;</span>
      <span class="c1">//   std::cout &lt;&lt; "lower_bound idx: " &lt;&lt; bound_x_sorted_idx &lt;&lt;</span>
      <span class="c1">//   std::endl; std::cout &lt;&lt; "x_sorted_idx : \n\t"; for (const auto&amp; idx :</span>
      <span class="c1">//   node-&gt;x_sorted_idx) {</span>
      <span class="c1">//     std::cout &lt;&lt; idx &lt;&lt; " ";</span>
      <span class="c1">//   }</span>
      <span class="c1">//   std::cout &lt;&lt; std::endl;</span>

      <span class="c1">//   std::cout &lt;&lt; "left_cascading_map : \n\t";</span>
      <span class="c1">//   for (const auto&amp; cascading_idx : node-&gt;left_x_cascading_map) {</span>
      <span class="c1">//     std::cout &lt;&lt; cascading_idx &lt;&lt; " ";</span>
      <span class="c1">//   }</span>
      <span class="c1">//   std::cout &lt;&lt; std::endl;</span>

      <span class="c1">//   std::cout &lt;&lt; "left-&gt;x_sorted_idx : \n\t";</span>
      <span class="c1">//   for (const auto&amp; idx : node-&gt;left-&gt;x_sorted_idx) {</span>
      <span class="c1">//     std::cout &lt;&lt; idx &lt;&lt; " ";</span>
      <span class="c1">//   }</span>
      <span class="c1">//   std::cout &lt;&lt; std::endl;</span>

      <span class="c1">//   std::cout &lt;&lt; "right_cascading_map : \n\t";</span>
      <span class="c1">//   for (const auto&amp; cascading_idx : node-&gt;right_x_cascading_map) {</span>
      <span class="c1">//     std::cout &lt;&lt; cascading_idx &lt;&lt; " ";</span>
      <span class="c1">//   }</span>
      <span class="c1">//   std::cout &lt;&lt; std::endl;</span>

      <span class="c1">//   std::cout &lt;&lt; "right-&gt;x_sorted_idx : \n\t";</span>
      <span class="c1">//   for (const auto&amp; idx : node-&gt;right-&gt;x_sorted_idx) {</span>
      <span class="c1">//     std::cout &lt;&lt; idx &lt;&lt; " ";</span>
      <span class="c1">//   }</span>
      <span class="c1">//   std::cout &lt;&lt; std::endl;</span>
      <span class="c1">//   std::cout &lt;&lt; "left 1, right 0 : " &lt;&lt; (qy &lt;= node-&gt;y_med) &lt;&lt;</span>
      <span class="c1">//   std::endl; std::cout &lt;&lt; "closest_right_idx : " &lt;&lt; closest_right_idx</span>
      <span class="c1">//   &lt;&lt; std::endl;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">bound_x_sorted_idx</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// NOTE</span>
      <span class="c1">// qy 랑 같은 y 에 멈출지 말지? (output sensitive 관련)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">qy</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">y_med</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">found_higher_x_sorted_idx</span> <span class="o">=</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right_x_cascading_map</span><span class="p">[</span><span class="n">bound_x_sorted_idx</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">found_higher_x_sorted_idx</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">found_higher_idx</span> <span class="o">=</span>
              <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">[</span><span class="n">found_higher_x_sorted_idx</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">closest_right_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">closest_right_idx</span> <span class="o">=</span> <span class="n">found_higher_idx</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">found_higher_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pts</span><span class="p">[</span><span class="n">closest_right_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">closest_right_idx</span> <span class="o">=</span> <span class="n">found_higher_idx</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// NOTE else?</span>

        <span class="n">bound_x_sorted_idx</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left_x_cascading_map</span><span class="p">[</span><span class="n">bound_x_sorted_idx</span><span class="p">];</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>

      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">bound_x_sorted_idx</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right_x_cascading_map</span><span class="p">[</span><span class="n">bound_x_sorted_idx</span><span class="p">];</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// NOTE</span>
    <span class="c1">// if(closest_right_idx == -1){</span>
    <span class="c1">// }</span>
    <span class="k">return</span> <span class="n">closest_right_idx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">QueryLeft</span><span class="p">(</span><span class="kt">int</span> <span class="n">qx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qy</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">Node</span><span class="o">*</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bound_x_sorted_idx</span> <span class="o">=</span> <span class="n">UpperBound</span><span class="p">(</span><span class="n">x_sorted_idx</span><span class="p">,</span> <span class="n">qx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">closest_left_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">!=</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// std::cout &lt;&lt; "----------------" &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "y med: " &lt;&lt; node-&gt;y_med &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "lower_bound idx: " &lt;&lt; bound_x_sorted_idx &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "x_sorted_idx : \n\t";</span>
      <span class="c1">// for (const auto&amp; idx : node-&gt;x_sorted_idx) {</span>
      <span class="c1">//   std::cout &lt;&lt; idx &lt;&lt; " ";</span>
      <span class="c1">// }</span>
      <span class="c1">// std::cout &lt;&lt; std::endl;</span>

      <span class="c1">// std::cout &lt;&lt; "left_cascading_map_inverse : \n\t";</span>
      <span class="c1">// for (const auto&amp; cascading_idx : node-&gt;left_x_cascading_map_inverse) {</span>
      <span class="c1">//   std::cout &lt;&lt; cascading_idx &lt;&lt; " ";</span>
      <span class="c1">// }</span>
      <span class="c1">// std::cout &lt;&lt; std::endl;</span>

      <span class="c1">// std::cout &lt;&lt; "left-&gt;x_sorted_idx : \n\t";</span>
      <span class="c1">// for (const auto&amp; idx : node-&gt;left-&gt;x_sorted_idx) {</span>
      <span class="c1">//   std::cout &lt;&lt; idx &lt;&lt; " ";</span>
      <span class="c1">// }</span>
      <span class="c1">// std::cout &lt;&lt; std::endl;</span>

      <span class="c1">// std::cout &lt;&lt; "right_cascading_map_inverse : \n\t";</span>
      <span class="c1">// for (const auto&amp; cascading_idx : node-&gt;right_x_cascading_map_inverse) {</span>
      <span class="c1">//   std::cout &lt;&lt; cascading_idx &lt;&lt; " ";</span>
      <span class="c1">// }</span>
      <span class="c1">// std::cout &lt;&lt; std::endl;</span>

      <span class="c1">// std::cout &lt;&lt; "right-&gt;x_sorted_idx : \n\t";</span>
      <span class="c1">// for (const auto&amp; idx : node-&gt;right-&gt;x_sorted_idx) {</span>
      <span class="c1">//   std::cout &lt;&lt; idx &lt;&lt; " ";</span>
      <span class="c1">// }</span>
      <span class="c1">// std::cout &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "left 1, right 0 : " &lt;&lt; (qy &lt;= node-&gt;y_med) &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "closest_left_idx : " &lt;&lt; closest_left_idx &lt;&lt; std::endl;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">bound_x_sorted_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// NOTE</span>
      <span class="c1">// qy 랑 같은 y 에 멈출지 말지? (output sensitive 관련)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">qy</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">y_med</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">found_higher_x_sorted_idx</span> <span class="o">=</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right_x_cascading_map_inverse</span><span class="p">[</span><span class="n">bound_x_sorted_idx</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">found_higher_x_sorted_idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">found_higher_idx</span> <span class="o">=</span>
              <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">[</span><span class="n">found_higher_x_sorted_idx</span><span class="p">];</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">closest_left_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">closest_left_idx</span> <span class="o">=</span> <span class="n">found_higher_idx</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">found_higher_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pts</span><span class="p">[</span><span class="n">closest_left_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">closest_left_idx</span> <span class="o">=</span> <span class="n">found_higher_idx</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// NOTE else?</span>

        <span class="n">bound_x_sorted_idx</span> <span class="o">=</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">left_x_cascading_map_inverse</span><span class="p">[</span><span class="n">bound_x_sorted_idx</span><span class="p">];</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>

      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">bound_x_sorted_idx</span> <span class="o">=</span>
            <span class="n">node</span><span class="o">-&gt;</span><span class="n">right_x_cascading_map_inverse</span><span class="p">[</span><span class="n">bound_x_sorted_idx</span><span class="p">];</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// NOTE</span>
    <span class="c1">// last node consideration?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">qx</span> <span class="o">&amp;&amp;</span>
          <span class="n">pts</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">qy</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">closest</span><span class="err">\</span><span class="n">_left</span><span class="err">\</span><span class="n">_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="err">\</span><span class="o">||</span>
            <span class="n">pts</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pts</span><span class="p">[</span><span class="n">closest_left_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
          <span class="n">closest_left_idx</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">x_sorted_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">closest_left_idx</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// x_sorted_idx -&gt; evaluation -&gt; upperbound -&gt; idx</span>
  <span class="kt">int</span> <span class="n">UpperBound</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">x_sorted_idx_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// not containing end r</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x_sorted_idx_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">med_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">med</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">x_sorted_idx_</span><span class="p">[</span><span class="n">med_idx</span><span class="p">]][</span><span class="mi">0</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">med</span> <span class="o">&lt;=</span> <span class="n">qx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">med_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">med_idx</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// x_sorted_idx -&gt; evaluation -&gt; lowerbound -&gt; idx</span>
  <span class="kt">int</span> <span class="n">LowerBound</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">x_sorted_idx_</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// not containing end r</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x_sorted_idx_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">med_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">med</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">x_sorted_idx_</span><span class="p">[</span><span class="n">med_idx</span><span class="p">]][</span><span class="mi">0</span><span class="p">];</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">med</span> <span class="o">&lt;</span> <span class="n">qx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">med_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">med_idx</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="c1">// using output-sensitive solution</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">getSkyline</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">buildings</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">begin</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">end</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">new_buildings</span><span class="p">;</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="n">new_buildings</span> <span class="o">=</span> <span class="n">PreprocessBuildings</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"# preprocess : "</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span>
                                                                       <span class="n">begin</span><span class="p">)</span>
                     <span class="p">.</span><span class="n">count</span><span class="p">()</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">new_buildings</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="c1">// starting at 4 too slow</span>
    <span class="kt">int</span> <span class="n">h_cnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">h_star</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="c1">// 2, 4, 16, 256 , ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">h_star</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">h_cnt</span><span class="o">++</span><span class="p">));</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">skyline</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">h_star</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">h_star</span> <span class="o">*</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">//</span>
      <span class="c1">// std::cout &lt;&lt; "----- Skyline ----- [ h*: " &lt;&lt; h_star &lt;&lt; ", k: " &lt;&lt; k</span>
      <span class="c1">//           &lt;&lt; " ]" &lt;&lt; std::endl;</span>
      <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">subgp_buildings</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">subgp_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="n">h_star</span><span class="p">;</span>
        <span class="n">subgp_buildings</span><span class="p">[</span><span class="n">subgp_idx</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">new_buildings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">subgp_skylines</span><span class="p">;</span>
      <span class="n">subgp_skylines</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">b</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="n">subgp_skylines</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">GetSkylineSlow</span><span class="p">(</span><span class="n">subgp_buildings</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">e</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="c1">// std::cout &lt;&lt; "# subgp each skyline : " &lt;&lt;</span>
        <span class="c1">// std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(e - b).count()</span>
        <span class="c1">// &lt;&lt; std::endl; std::cout &lt;&lt; "skyline for subgp " &lt;&lt; i &lt;&lt; std::endl;</span>
        <span class="c1">// for (const auto&amp; pt : subgp_skylines[i]) {</span>
        <span class="c1">//   std::cout &lt;&lt; "(" &lt;&lt; pt[0] &lt;&lt; ", " &lt;&lt; pt[1] &lt;&lt; ") - ";</span>
        <span class="c1">// }</span>
        <span class="c1">// std::cout &lt;&lt; std::endl;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">subgp_skylines</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"# subgp skyline ["</span> <span class="o">&lt;&lt;</span> <span class="n">h_star</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="s">"]: "</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span>
                                                                         <span class="n">begin</span><span class="p">)</span>
                       <span class="p">.</span><span class="n">count</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

      <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;</span> <span class="n">subgp_trees</span><span class="p">;</span>
      <span class="n">subgp_trees</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">sum_td1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_td2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_td3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_td4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum_td5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
          <span class="n">sum_td6</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">subgp_trees</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">subgp_skylines</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">sum_td1</span> <span class="o">+=</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">td1</span><span class="p">;</span>
        <span class="n">sum_td2</span> <span class="o">+=</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">td2</span><span class="p">;</span>
        <span class="n">sum_td3</span> <span class="o">+=</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">td3</span><span class="p">;</span>
        <span class="n">sum_td4</span> <span class="o">+=</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">td4</span><span class="p">;</span>
        <span class="n">sum_td5</span> <span class="o">+=</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">td5</span><span class="p">;</span>
        <span class="n">sum_td6</span> <span class="o">+=</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">back</span><span class="p">().</span><span class="n">td6</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"# tree construction : "</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span>
                                                                         <span class="n">begin</span><span class="p">)</span>
                       <span class="p">.</span><span class="n">count</span><span class="p">()</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="c1">// std::cout &lt;&lt; "# tree construction td1: " &lt;&lt; sum_td1 &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "# tree construction td2: " &lt;&lt; sum_td2 &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "# tree construction td3: " &lt;&lt; sum_td3 &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "# tree construction td4: " &lt;&lt; sum_td4 &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "# tree construction td5: " &lt;&lt; sum_td5 &lt;&lt; std::endl;</span>
      <span class="c1">// std::cout &lt;&lt; "# tree construction td6: " &lt;&lt; sum_td6 &lt;&lt; std::endl;</span>

      <span class="c1">// merge</span>
      <span class="kt">int</span> <span class="n">cur_x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">cur_y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">cur_subgp_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">cur_subgp_pt_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">succeeded</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="c1">// from start point, h_start + 1 iteration needed</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">h_star</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="c1">// std::cout &lt;&lt; "- h* loop : " &lt;&lt; i &lt;&lt; " / " &lt;&lt; h_star &lt;&lt; std::endl;</span>
        <span class="c1">// std::cout &lt;&lt; "cur_x: " &lt;&lt; cur_x &lt;&lt; std::endl</span>
        <span class="c1">//           &lt;&lt; "cur_y: " &lt;&lt; cur_y &lt;&lt; std::endl</span>
        <span class="c1">//           &lt;&lt; "cur_subgp_idx: " &lt;&lt; cur_subgp_idx &lt;&lt; std::endl</span>
        <span class="c1">//           &lt;&lt; "cur_subgp_pt_idx: " &lt;&lt; cur_subgp_pt_idx &lt;&lt; std::endl;</span>
        <span class="kt">int</span> <span class="n">next_x</span><span class="p">,</span> <span class="n">next_y</span><span class="p">,</span> <span class="n">next_subgp_idx</span><span class="p">,</span> <span class="n">next_subgp_pt_idx</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">next_x</span><span class="p">,</span> <span class="n">next_y</span><span class="p">,</span> <span class="n">next_subgp_idx</span><span class="p">,</span> <span class="n">next_subgp_pt_idx</span><span class="p">)</span> <span class="o">=</span>
            <span class="n">FindNextSkylinePt</span><span class="p">(</span><span class="n">subgp_trees</span><span class="p">,</span> <span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_y</span><span class="p">);</span>
        <span class="c1">// std::cout &lt;&lt; "next_x: " &lt;&lt; next_x &lt;&lt; std::endl</span>
        <span class="c1">//           &lt;&lt; "next_y: " &lt;&lt; next_y &lt;&lt; std::endl</span>
        <span class="c1">//           &lt;&lt; "next_subgp_idx: " &lt;&lt; next_subgp_idx &lt;&lt; std::endl</span>
        <span class="c1">//           &lt;&lt; "next_subgp_pt_idx: " &lt;&lt; next_subgp_pt_idx &lt;&lt; std::endl;</span>
        <span class="c1">// std::cout</span>
        <span class="c1">//     &lt;&lt; "Query next response: "</span>
        <span class="c1">//     &lt;&lt; \(cur\_subgp\_idx == -1 \||</span>
        <span class="c1">//         cur_subgp_pt_idx &lt; subgp_trees[cur_subgp_idx].pts.size() - 1)</span>
        <span class="c1">//     &lt;&lt; \(next\_x == -1 \||</span>
        <span class="c1">//         (cur_subgp_idx != -1 &amp;&amp;</span>
        <span class="c1">//          next_x &gt;</span>
        <span class="c1">//              subgp_trees[cur_subgp_idx].pts[cur_subgp_pt_idx +</span>
        <span class="c1">//              1][0]))</span>
        <span class="c1">//     &lt;&lt; std::endl;</span>
        <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">cur</span><span class="err">\</span><span class="n">_subgp</span><span class="err">\</span><span class="n">_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="err">\</span><span class="o">||</span>
            <span class="n">cur_subgp_pt_idx</span> <span class="o">&lt;</span> <span class="n">subgp_trees</span><span class="p">[</span><span class="n">cur_subgp_idx</span><span class="p">].</span><span class="n">pts</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">// next subgp pt exists</span>

          <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">next</span><span class="err">\</span><span class="n">_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="err">\</span><span class="o">||</span>
              <span class="p">(</span><span class="n">cur_subgp_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span>
               <span class="n">next_x</span> <span class="o">&gt;</span>
                   <span class="n">subgp_trees</span><span class="p">[</span><span class="n">cur_subgp_idx</span><span class="p">].</span><span class="n">pts</span><span class="p">[</span><span class="n">cur_subgp_pt_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
            <span class="c1">// no query response</span>
            <span class="c1">// if cur_subgp_idx == -1 (init), it must jump</span>
            <span class="c1">// to be drop case, next_x must be farther than the cur next x</span>
            <span class="c1">// drop to cur_subgp_idx+1 and need to find y</span>
            <span class="c1">// assert idx not -1 if no query resp</span>
            <span class="kt">int</span> <span class="n">cur_next_x</span> <span class="o">=</span>
                <span class="n">subgp_trees</span><span class="p">[</span><span class="n">cur_subgp_idx</span><span class="p">].</span><span class="n">pts</span><span class="p">[</span><span class="n">cur_subgp_pt_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">cur_next_y</span> <span class="o">=</span>
                <span class="n">subgp_trees</span><span class="p">[</span><span class="n">cur_subgp_idx</span><span class="p">].</span><span class="n">pts</span><span class="p">[</span><span class="n">cur_subgp_pt_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">prev_x</span><span class="p">,</span> <span class="n">prev_y</span><span class="p">,</span> <span class="n">prev_subgp_idx</span><span class="p">,</span> <span class="n">prev_subgp_pt_idx</span><span class="p">;</span>
            <span class="c1">// std::cout &lt;&lt; "Query prev: (" &lt;&lt; cur_next_x &lt;&lt; ", " &lt;&lt; cur_next_y</span>
            <span class="c1">//           &lt;&lt; ")" &lt;&lt; std::endl;</span>
            <span class="c1">// NOTE: query y?</span>
            <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">prev_x</span><span class="p">,</span> <span class="n">prev_y</span><span class="p">,</span> <span class="n">prev_subgp_idx</span><span class="p">,</span> <span class="n">prev_subgp_pt_idx</span><span class="p">)</span> <span class="o">=</span>
                <span class="n">FindPrevSkylinePt</span><span class="p">(</span><span class="n">subgp_trees</span><span class="p">,</span> <span class="n">cur_next_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur_subgp_idx</span><span class="p">);</span>
            <span class="c1">// std::cout &lt;&lt; "prev_x: " &lt;&lt; prev_x &lt;&lt; std::endl</span>
            <span class="c1">//           &lt;&lt; "prev_y: " &lt;&lt; prev_y &lt;&lt; std::endl</span>
            <span class="c1">//           &lt;&lt; "prev_subgp_idx: " &lt;&lt; prev_subgp_idx &lt;&lt; std::endl</span>
            <span class="c1">//           &lt;&lt; "prev_subgp_pt_idx: " &lt;&lt; prev_subgp_pt_idx</span>
            <span class="c1">//           &lt;&lt; std::endl;</span>
            <span class="c1">// drop to prev y only if it is higher than drop height in the same</span>
            <span class="c1">// subgp</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev_y</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">prev_y</span> <span class="o">&gt;</span> <span class="n">cur_next_y</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">cur_x</span> <span class="o">=</span> <span class="n">cur_next_x</span><span class="p">;</span>
              <span class="n">cur_y</span> <span class="o">=</span> <span class="n">prev_y</span><span class="p">;</span>
              <span class="n">cur_subgp_idx</span> <span class="o">=</span> <span class="n">prev_subgp_idx</span><span class="p">;</span>
              <span class="n">cur_subgp_pt_idx</span> <span class="o">=</span> <span class="n">prev_subgp_pt_idx</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// drop to current subgp next pt</span>
              <span class="n">cur_x</span> <span class="o">=</span> <span class="n">cur_next_x</span><span class="p">;</span>
              <span class="n">cur_y</span> <span class="o">=</span> <span class="n">cur_next_y</span><span class="p">;</span>
              <span class="n">cur_subgp_pt_idx</span> <span class="o">=</span> <span class="n">cur_subgp_pt_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// jump (move to the query response)</span>
            <span class="c1">// including cur subgp.</span>
            <span class="n">cur_x</span> <span class="o">=</span> <span class="n">next_x</span><span class="p">;</span>
            <span class="n">cur_y</span> <span class="o">=</span> <span class="n">next_y</span><span class="p">;</span>
            <span class="n">cur_subgp_idx</span> <span class="o">=</span> <span class="n">next_subgp_idx</span><span class="p">;</span>
            <span class="n">cur_subgp_pt_idx</span> <span class="o">=</span> <span class="n">next_subgp_pt_idx</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// else pt is the last (0,0) of the subgp</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">next_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// no query response</span>
            <span class="n">succeeded</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// jump (move to the query response)</span>
            <span class="n">cur_x</span> <span class="o">=</span> <span class="n">next_x</span><span class="p">;</span>
            <span class="n">cur_y</span> <span class="o">=</span> <span class="n">next_y</span><span class="p">;</span>
            <span class="n">cur_subgp_idx</span> <span class="o">=</span> <span class="n">next_subgp_idx</span><span class="p">;</span>
            <span class="n">cur_subgp_pt_idx</span> <span class="o">=</span> <span class="n">next_subgp_pt_idx</span><span class="p">;</span>
          <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// std::cout &lt;&lt; "-- skyline push : (" &lt;&lt; cur_x &lt;&lt; ", " &lt;&lt; cur_y &lt;&lt; ")"</span>
        <span class="c1">//           &lt;&lt; std::endl;</span>
        <span class="n">skyline</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_y</span><span class="p">});</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

        <span class="c1">// std::cout &lt;&lt; "# h* loop queary : " &lt;&lt;</span>
        <span class="c1">// std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end -</span>
        <span class="c1">// begin).count() &lt;&lt; std::endl;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">succeeded</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">skyline</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">;</span>  <span class="c1">// std::cout &lt;&lt; " - fail" &lt;&lt; std::endl;</span>
      <span class="p">}</span>

      <span class="c1">// h_star = h_star * h_star;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">FindNextSkylinePt</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;&amp;</span> <span class="n">subgp_trees</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qy</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">next_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next_subgp_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">next_subgp_pt_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">subgp_tree</span> <span class="o">=</span> <span class="n">subgp_trees</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">resp_idx</span> <span class="o">=</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">QueryRight</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">resp_idx</span> <span class="o">&gt;</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">pts</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kt">int</span> <span class="n">next_cand_x</span> <span class="o">=</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">pts</span><span class="p">[</span><span class="n">resp_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">next_cand_y</span> <span class="o">=</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">pts</span><span class="p">[</span><span class="n">resp_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">next</span><span class="err">\</span><span class="n">_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="err">\</span><span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="err">\</span><span class="p">(</span><span class="n">next</span><span class="err">\</span><span class="n">_x</span><span class="p">,</span> <span class="o">-</span><span class="n">next</span><span class="err">\</span><span class="n">_y</span><span class="p">)</span> <span class="o">&gt;</span>
                              <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next_cand_x</span><span class="p">,</span> <span class="o">-</span><span class="n">next_cand_y</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">next_x</span> <span class="o">=</span> <span class="n">next_cand_x</span><span class="p">;</span>
        <span class="n">next_y</span> <span class="o">=</span> <span class="n">next_cand_y</span><span class="p">;</span>
        <span class="n">next_subgp_idx</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">next_subgp_pt_idx</span> <span class="o">=</span> <span class="n">resp_idx</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">next_x</span><span class="p">,</span> <span class="n">next_y</span><span class="p">,</span> <span class="n">next_subgp_idx</span><span class="p">,</span> <span class="n">next_subgp_pt_idx</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// regardless x , find highest y value dominating query pt</span>
  <span class="c1">// return highest except cur subgp</span>
  <span class="n">std</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">FindPrevSkylinePt</span><span class="p">(</span>
      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Tree</span><span class="o">&gt;&amp;</span> <span class="n">subgp_trees</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">qy</span><span class="p">,</span>
      <span class="kt">int</span> <span class="n">cur_subgp_idx</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">prev_x</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prev_y</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prev_subgp_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prev_subgp_pt_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">subgp_trees</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">cur_subgp_idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">subgp_tree</span> <span class="o">=</span> <span class="n">subgp_trees</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">resp_idx</span> <span class="o">=</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">QueryLeft</span><span class="p">(</span><span class="n">qx</span><span class="p">,</span> <span class="n">qy</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">resp_idx</span> <span class="o">&gt;</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">pts</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="kt">int</span> <span class="n">prev_cand_x</span> <span class="o">=</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">pts</span><span class="p">[</span><span class="n">resp_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">prev_cand_y</span> <span class="o">=</span> <span class="n">subgp_tree</span><span class="p">.</span><span class="n">pts</span><span class="p">[</span><span class="n">resp_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
      <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">prev</span><span class="err">\</span><span class="n">_x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="err">\</span><span class="o">||</span> <span class="n">prev</span><span class="err">\</span><span class="n">_y</span> <span class="o">&lt;</span> <span class="n">prev</span><span class="err">\</span><span class="n">_cand</span><span class="err">\</span><span class="n">_y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prev_x</span> <span class="o">=</span> <span class="n">prev_cand_x</span><span class="p">;</span>
        <span class="n">prev_y</span> <span class="o">=</span> <span class="n">prev_cand_y</span><span class="p">;</span>
        <span class="n">prev_subgp_idx</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="n">prev_subgp_pt_idx</span> <span class="o">=</span> <span class="n">resp_idx</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="n">prev_x</span><span class="p">,</span> <span class="n">prev_y</span><span class="p">,</span> <span class="n">prev_subgp_idx</span><span class="p">,</span> <span class="n">prev_subgp_pt_idx</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// find skyline given building segments in O(n log n)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">GetSkylineSlow</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">buildings</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">skyline</span><span class="p">;</span>
    <span class="n">skyline</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">buildings</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">segs</span><span class="p">;</span>
    <span class="n">segs</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">buildings</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">buildings</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buildings</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">segs</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">});</span>
      <span class="n">segs</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">i</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">segs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">segs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pq</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">seg_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">seg_idx</span> <span class="o">&lt;</span> <span class="n">segs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">cur_x</span><span class="p">;</span>
      <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ignore</span><span class="p">)</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">seg_idx</span> <span class="o">&lt;</span> <span class="n">segs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">cur_x</span> <span class="o">==</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">building_idx</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ignore</span><span class="p">,</span> <span class="n">building_idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">seg_idx</span><span class="p">];</span>
        <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">buildings</span><span class="p">[</span><span class="n">building_idx</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_x</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]});</span>
          <span class="c1">// pq.emplace(b[2], b[1]);</span>
        <span class="p">}</span>
        <span class="n">seg_idx</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">// remove immediately as it ends</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">second</span> <span class="o">&lt;=</span> <span class="n">cur_x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="kt">int</span> <span class="n">cur_height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">cur_height</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="err">\</span><span class="p">(</span><span class="n">skyline</span><span class="p">.</span><span class="n">empty</span><span class="err">\</span><span class="p">()</span> <span class="err">\</span><span class="o">||</span> <span class="n">skyline</span><span class="p">.</span><span class="n">back</span><span class="err">\</span><span class="p">()</span><span class="err">\</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cur</span><span class="err">\</span><span class="n">_height</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">skyline</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">cur_x</span><span class="p">,</span> <span class="n">cur_height</span><span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">skyline</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// remove same height connected buildings</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">PreprocessBuildings</span><span class="p">(</span>
      <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">buildings</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">um</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">new_buildings</span><span class="p">;</span>
    <span class="n">new_buildings</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">buildings</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">:</span> <span class="n">buildings</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">um</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="n">um</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">new_buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
        <span class="n">um</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// assert um[b[2]] not empty</span>
        <span class="k">auto</span><span class="o">&amp;</span> <span class="n">last_b</span> <span class="o">=</span> <span class="n">new_buildings</span><span class="p">[</span><span class="n">um</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]];</span>
        <span class="c1">// intersects</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">last_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">last_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">last_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="c1">// contained</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="c1">// separated</span>
          <span class="n">new_buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
          <span class="n">um</span><span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">new_buildings</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestTree ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">19</span><span class="p">,</span> <span class="mi">8</span><span class="p">}};</span>
    <span class="n">Tree</span> <span class="n">t</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">TestQuery</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestQuery ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>   <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>  <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">}};</span>
    <span class="n">Tree</span> <span class="n">t</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">test_list</span> <span class="o">=</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">LowerBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test lowerbound for 5 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">LowerBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test lowerbound for 6 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">LowerBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test lowerbound for 7 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">LowerBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test lowerbound for 0 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">LowerBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test lowerbound for 11 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">UpperBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test upperbound for 5 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">UpperBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test upperbound for 6 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">UpperBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test upperbound for 7 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">UpperBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test upperbound for 0 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">UpperBound</span><span class="p">(</span><span class="n">test_list</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test upperbound for 11 : "</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">TestQuery2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestQuery2 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span>  <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">26</span><span class="p">},</span> <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>   <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>   <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>  <span class="p">{</span><span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">18</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">18</span><span class="p">},</span> <span class="p">{</span><span class="mi">22</span><span class="p">,</span> <span class="mi">24</span><span class="p">},</span> <span class="p">{</span><span class="mi">24</span><span class="p">,</span> <span class="mi">16</span><span class="p">},</span> <span class="p">{</span><span class="mi">26</span><span class="p">,</span> <span class="mi">22</span><span class="p">},</span> <span class="p">{</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">}};</span>

    <span class="n">Tree</span> <span class="n">t</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"pts : "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">pts</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y_order : "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">idx</span> <span class="o">:</span> <span class="n">t</span><span class="p">.</span><span class="n">x_sorted_idx</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">idx_to_y_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">qs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>  <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">},</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">27</span><span class="p">},</span> <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">28</span><span class="p">},</span> <span class="p">{</span><span class="mi">29</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">28</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">19</span><span class="p">,</span> <span class="mi">18</span><span class="p">}};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Query : ("</span> <span class="o">&lt;&lt;</span> <span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">&lt;&lt;</span> <span class="s">") : "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">qidx</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">QueryRight</span><span class="p">(</span><span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">qidx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">qidx</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; "</span>
                  <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pts</span><span class="p">[</span><span class="n">qidx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pts</span><span class="p">[</span><span class="n">qidx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">qidx</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; not found"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestQuery3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestQuery3 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span>  <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">26</span><span class="p">},</span>  <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>   <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">},</span>  <span class="p">{</span><span class="mi">14</span><span class="p">,</span> <span class="mi">20</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">18</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>  <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">18</span><span class="p">},</span> <span class="p">{</span><span class="mi">22</span><span class="p">,</span> <span class="mi">24</span><span class="p">},</span> <span class="p">{</span><span class="mi">24</span><span class="p">,</span> <span class="mi">16</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">26</span><span class="p">,</span> <span class="mi">22</span><span class="p">},</span> <span class="p">{</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">},</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>

    <span class="n">Tree</span> <span class="n">t</span><span class="p">(</span><span class="n">pts</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"pts : "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">pts</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"y_order : "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">idx</span> <span class="o">:</span> <span class="n">t</span><span class="p">.</span><span class="n">x_sorted_idx</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">idx_to_y_order</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">qs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>   <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">},</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">},</span>  <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">27</span><span class="p">},</span>  <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">28</span><span class="p">},</span> <span class="p">{</span><span class="mi">29</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">28</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span>  <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>  <span class="p">{</span><span class="mi">19</span><span class="p">,</span> <span class="mi">18</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span> <span class="p">{</span><span class="mi">26</span><span class="p">,</span> <span class="mi">22</span><span class="p">},</span> <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">0</span><span class="p">}};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">qs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Query : ("</span> <span class="o">&lt;&lt;</span> <span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="o">&lt;&lt;</span> <span class="s">") : "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">qidx</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">QueryLeft</span><span class="p">(</span><span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">qs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">qidx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">qidx</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; "</span>
                  <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pts</span><span class="p">[</span><span class="n">qidx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pts</span><span class="p">[</span><span class="n">qidx</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">qidx</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; not found"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">TestSlow</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSlow ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">19</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">8</span><span class="p">}};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">GetSkylineSlow</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestSlow2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSlow2 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">});</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">GetSkylineSlow</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestSlow3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSlow3 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">GetSkylineSlow</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">TestSkyline</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSkyline ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">},</span> <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span> <span class="p">{</span><span class="mi">19</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">8</span><span class="p">}};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestSkyline2</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSkyline2 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="p">});</span>
    <span class="p">}</span>
    <span class="n">buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">202</span><span class="p">,</span> <span class="mi">101</span><span class="p">});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----- Result -----"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestSkyline3</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSkyline3 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">});</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----- Result -----"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestSkyline4</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSkyline4 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----- Result -----"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"("</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">") - "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestSkyline5</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSkyline5 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">219</span><span class="p">},</span>  <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">228</span><span class="p">},</span>  <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">106</span><span class="p">},</span>  <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">65</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>    <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>    <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">14</span><span class="p">},</span>   <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">225</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">187</span><span class="p">},</span>  <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">118</span><span class="p">},</span>  <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">211</span><span class="p">},</span>  <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">97</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">92</span><span class="p">},</span>   <span class="p">{</span><span class="mi">6</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">188</span><span class="p">},</span>  <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">42</span><span class="p">},</span>   <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">78</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">163</span><span class="p">},</span>  <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">212</span><span class="p">},</span>  <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">125</span><span class="p">},</span>  <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">85</span><span class="p">,</span> <span class="mi">200</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">9</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">74</span><span class="p">},</span>  <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">58</span><span class="p">},</span>  <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">179</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">215</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">161</span><span class="p">},</span> <span class="p">{</span><span class="mi">12</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">198</span><span class="p">},</span> <span class="p">{</span><span class="mi">13</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">48</span><span class="p">},</span>  <span class="p">{</span><span class="mi">13</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">222</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">14</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>   <span class="p">{</span><span class="mi">15</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">222</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">196</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">142</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">176</span><span class="p">},</span> <span class="p">{</span><span class="mi">16</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">114</span><span class="p">},</span> <span class="p">{</span><span class="mi">18</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>   <span class="p">{</span><span class="mi">19</span><span class="p">,</span> <span class="mi">79</span><span class="p">,</span> <span class="mi">149</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">20</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">53</span><span class="p">},</span>  <span class="p">{</span><span class="mi">21</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">41</span><span class="p">},</span>  <span class="p">{</span><span class="mi">23</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">43</span><span class="p">},</span>  <span class="p">{</span><span class="mi">24</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">75</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">24</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">20</span><span class="p">},</span>  <span class="p">{</span><span class="mi">27</span><span class="p">,</span> <span class="mi">63</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>   <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">69</span><span class="p">,</span> <span class="mi">58</span><span class="p">},</span>  <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">123</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">31</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">146</span><span class="p">},</span> <span class="p">{</span><span class="mi">33</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">27</span><span class="p">},</span>  <span class="p">{</span><span class="mi">35</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">190</span><span class="p">},</span> <span class="p">{</span><span class="mi">35</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="mi">116</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">37</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">81</span><span class="p">},</span>  <span class="p">{</span><span class="mi">38</span><span class="p">,</span> <span class="mi">78</span><span class="p">,</span> <span class="mi">99</span><span class="p">},</span>  <span class="p">{</span><span class="mi">39</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">125</span><span class="p">},</span> <span class="p">{</span><span class="mi">39</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">144</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">40</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>   <span class="p">{</span><span class="mi">45</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">229</span><span class="p">},</span> <span class="p">{</span><span class="mi">47</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">10</span><span class="p">},</span>  <span class="p">{</span><span class="mi">47</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">152</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">48</span><span class="p">,</span> <span class="mi">67</span><span class="p">,</span> <span class="mi">69</span><span class="p">},</span>  <span class="p">{</span><span class="mi">48</span><span class="p">,</span> <span class="mi">72</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>   <span class="p">{</span><span class="mi">49</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">204</span><span class="p">},</span> <span class="p">{</span><span class="mi">49</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">117</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">174</span><span class="p">},</span> <span class="p">{</span><span class="mi">50</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">147</span><span class="p">},</span> <span class="p">{</span><span class="mi">52</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span>   <span class="p">{</span><span class="mi">52</span><span class="p">,</span> <span class="mi">89</span><span class="p">,</span> <span class="mi">84</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">54</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">201</span><span class="p">},</span> <span class="p">{</span><span class="mi">57</span><span class="p">,</span> <span class="mi">76</span><span class="p">,</span> <span class="mi">47</span><span class="p">},</span>  <span class="p">{</span><span class="mi">58</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">215</span><span class="p">},</span> <span class="p">{</span><span class="mi">58</span><span class="p">,</span> <span class="mi">98</span><span class="p">,</span> <span class="mi">57</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">61</span><span class="p">,</span> <span class="mi">95</span><span class="p">,</span> <span class="mi">190</span><span class="p">},</span> <span class="p">{</span><span class="mi">66</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">34</span><span class="p">},</span>  <span class="p">{</span><span class="mi">66</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">53</span><span class="p">},</span>  <span class="p">{</span><span class="mi">67</span><span class="p">,</span> <span class="mi">74</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">68</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">175</span><span class="p">},</span> <span class="p">{</span><span class="mi">70</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">131</span><span class="p">},</span> <span class="p">{</span><span class="mi">74</span><span class="p">,</span> <span class="mi">77</span><span class="p">,</span> <span class="mi">155</span><span class="p">},</span> <span class="p">{</span><span class="mi">74</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">145</span><span class="p">},</span>
        <span class="p">{</span><span class="mi">76</span><span class="p">,</span> <span class="mi">88</span><span class="p">,</span> <span class="mi">26</span><span class="p">},</span>  <span class="p">{</span><span class="mi">82</span><span class="p">,</span> <span class="mi">87</span><span class="p">,</span> <span class="mi">40</span><span class="p">},</span>  <span class="p">{</span><span class="mi">83</span><span class="p">,</span> <span class="mi">84</span><span class="p">,</span> <span class="mi">132</span><span class="p">},</span> <span class="p">{</span><span class="mi">88</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">99</span><span class="p">}};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----- Result -----"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"["</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"], "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">TestSkyline6</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"===== TestSkyline6 ====="</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">infile</span><span class="p">(</span><span class="s">"test_input"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">infile</span><span class="p">.</span><span class="n">eof</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">infile</span> <span class="o">&gt;&gt;</span> <span class="n">x1</span> <span class="o">&gt;&gt;</span> <span class="n">x2</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">;</span>
      <span class="n">buildings</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">});</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"input length: "</span> <span class="o">&lt;&lt;</span> <span class="n">buildings</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----- Result -----"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt</span> <span class="o">:</span> <span class="n">ans</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"["</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">"], "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">GenerateRandomInput</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="o">&amp;</span> <span class="n">gen</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist_x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">dist_y</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">20</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
      <span class="n">x1</span> <span class="o">=</span> <span class="n">dist_x</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
      <span class="n">x2</span> <span class="o">=</span> <span class="n">dist_x</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">dist_y</span><span class="p">(</span><span class="n">gen</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span><span class="p">;</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">buildings</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">};</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">buildings</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">buildings</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">buildings</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">ProfileTC</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">repetition</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">rd</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">gen</span><span class="p">(</span><span class="mi">1234</span><span class="p">);</span>  <span class="c1">// rd()</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">outfile</span><span class="p">(</span><span class="s">"profile"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">scale</span> <span class="o">=</span> <span class="mi">20000000</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">scale</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">scale</span> <span class="o">*</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">scale</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">repetition</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">buildings</span> <span class="o">=</span> <span class="n">GenerateRandomInput</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">begin</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">end</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">ans</span><span class="p">;</span>
        <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">GetSkylineSlow</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">time_ms1</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
                <span class="p">.</span><span class="n">count</span><span class="p">();</span>

        <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="n">getSkyline</span><span class="p">(</span><span class="n">buildings</span><span class="p">);</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">ans</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">auto</span> <span class="n">time_ms2</span> <span class="o">=</span>
            <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
                <span class="p">.</span><span class="n">count</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">h</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">h1</span> <span class="o">==</span> <span class="n">h2</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">h</span> <span class="o">=</span> <span class="n">h1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="s">"----- Error ----- : "</span> <span class="o">&lt;&lt;</span> <span class="n">h1</span> <span class="o">&lt;&lt;</span> <span class="s">" vs "</span> <span class="o">&lt;&lt;</span> <span class="n">h2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">:</span> <span class="n">buildings</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">outfile</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">h</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">time_ms1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">time_ms2</span>
                <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// outfile &lt;&lt; ss.rdbuf();</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Solution</span> <span class="n">s</span><span class="p">;</span>
  <span class="c1">// s.TestTree();</span>
  <span class="c1">// s.TestQuery();</span>
  <span class="c1">// s.TestQuery2();</span>
  <span class="c1">// s.TestQuery3();</span>
  <span class="c1">// s.TestSlow();</span>
  <span class="c1">// s.TestSlow2();</span>
  <span class="c1">// s.TestSlow3();</span>
  <span class="c1">// s.TestSkyline();</span>
  <span class="c1">// s.TestSkyline2();</span>
  <span class="c1">// s.TestSkyline3();</span>
  <span class="c1">// s.TestSkyline4();</span>
  <span class="c1">// s.TestSkyline5();</span>
  <span class="c1">// s.TestSkyline6();</span>
  <span class="n">s</span><span class="p">.</span><span class="n">ProfileTC</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

</details>

<details>
<summary>시각화 코드</summary>


<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># 10^4
</span><span class="k">def</span> <span class="nf">generate_random_case</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="c1"># buildings = [[1,2**5, 2**5]]
</span>    <span class="n">buildings</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">10</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">x_max</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_max</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">:</span> 
            <span class="n">x1</span><span class="p">,</span><span class="n">x2</span> <span class="o">=</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span>
        <span class="k">elif</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x2</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">buildings</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
    <span class="n">buildings</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">buildings</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">buildings</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>

    

    <span class="c1"># buildings = [[1,38,219],[2,19,228],[2,64,106],[3,80,65],[3,84,8],[4,12,8],[4,25,14],[4,46,225],[4,67,187],[5,36,118],[5,48,211],[5,55,97],[6,42,92],[6,56,188],[7,37,42],[7,49,78],[7,84,163],[8,44,212],[9,42,125],[9,85,200],[9,100,74],[10,13,58],[11,30,179],[12,32,215],[12,33,161],[12,61,198],[13,38,48],[13,65,222],[14,22,1],[15,70,222],[16,19,196],[16,24,142],[16,25,176],[16,57,114],[18,45,1],[19,79,149],[20,33,53],[21,29,41],[23,77,43],[24,41,75],[24,94,20],[27,63,2],[31,69,58],[31,88,123],[31,88,146],[33,61,27],[35,62,190],[35,81,116],[37,97,81],[38,78,99],[39,51,125],[39,98,144],[40,95,4],[45,89,229],[47,49,10],[47,99,152],[48,67,69],[48,72,1],[49,73,204],[49,77,117],[50,61,174],[50,76,147],[52,64,4],[52,89,84],[54,70,201],[57,76,47],[58,61,215],[58,98,57],[61,95,190],[66,71,34],[66,99,53],[67,74,9],[68,97,175],[70,88,131],[74,77,155],[74,99,145],[76,88,26],[82,87,40],[83,84,132],[88,99,99]]
</span>    <span class="n">buildings</span> <span class="o">=</span> <span class="n">generate_random_case</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
    <span class="c1"># print(buildings)
</span>    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"test_input_py"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf-8"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">buildings</span><span class="p">))</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"test_input"</span><span class="p">,</span> <span class="s">"w"</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">"utf-8"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">:</span>
            <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">buildings</span><span class="p">))</span>

    
    <span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">])</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">])</span>

    <span class="n">ax</span><span class="p">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_max</span><span class="o">*</span><span class="mf">1.1</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_max</span><span class="o">*</span><span class="mf">1.1</span><span class="p">])</span>
    <span class="c1"># ax.set_xticks(np.arange(-1, x_max, 100))
</span>
    <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">cm</span><span class="p">.</span><span class="n">viridis</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">buildings</span><span class="p">:</span>
        <span class="n">ax</span><span class="p">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">Rectangle</span><span class="p">((</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                <span class="n">color</span><span class="o">=</span><span class="n">cmap</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">))))</span>

    <span class="c1"># ans = [[1, 219], [2, 228], [19, 225], [45, 229], [89, 190], [95, 175], [97, 152], [99, 74], [100, 0]]
</span>    <span class="n">ans</span>  <span class="o">=</span> <span class="p">[[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">451</span><span class="p">],</span> <span class="p">[</span><span class="mi">103</span><span class="p">,</span> <span class="mi">773</span><span class="p">],</span> <span class="p">[</span><span class="mi">196</span><span class="p">,</span> <span class="mi">494</span><span class="p">],</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">1003</span><span class="p">],</span> <span class="p">[</span><span class="mi">551</span><span class="p">,</span> <span class="mi">893</span><span class="p">],</span> <span class="p">[</span><span class="mi">562</span><span class="p">,</span> <span class="mi">943</span><span class="p">],</span> <span class="p">[</span><span class="mi">808</span><span class="p">,</span> <span class="mi">288</span><span class="p">],</span> <span class="p">[</span><span class="mi">832</span><span class="p">,</span> <span class="mi">133</span><span class="p">],</span> <span class="p">[</span><span class="mi">973</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

    <span class="n">ans_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">]</span>
    <span class="n">ans_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ans</span><span class="p">]</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">ans_x</span><span class="p">,</span> <span class="n">ans_y</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s">'red'</span><span class="p">)</span>

    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span></code></pre></figure>

</details>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="ps" /><category term="computational geometry" /><summary type="html"><![CDATA[이전에 직장에서 computational geometry study를 가진적이 있다. 그때 알게된 문제인데 skyline problem이라고 하는 유명한 문제가 leetcode에도 있어서 이 문제를 풀고 개선하려고 정리했던 적이 있다. 정리해두고 잊고 있었는데, 블로그에 올려두려 한다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/ps-skyline/ps-skyline1.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/ps-skyline/ps-skyline1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Graphics Examples - PBD</title><link href="https://keechang-choi.github.io/study/study-vge-pbd/" rel="alternate" type="text/html" title="Vulkan Graphics Examples - PBD" /><published>2023-11-25T00:00:00+09:00</published><updated>2023-11-25T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-vge-pbd</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-vge-pbd/"><![CDATA[<p><code class="language-plaintext highlighter-rouge">PBD(Position Based Dynamics)</code> 관련 내용들을 습득하고 예제들을 구현해보기로 했다. lecture에는 영상과 구현 자료가 잘 정리되어 있고 논문 및 course note 등 정확한 정보가 충분해서 공부하기 좋았다.<br />
이론과 관련되어서는 이전부터 조금씩 봐왔던 것들 중 자세히 짚고 넘어가지 못한 내용들을 정리하려 한다. numerical integration과 hash 관련 내용들이 그렇다.<br />
여러 simtulation 예시들이 나오는데, 일부는 예시들을 그대로 구현한 것 도 있고, 일부 Vulkan 활용에 편하도록 수정한 것들도 있다. 아직은 GPU 활용한 예제를 다루지 않고 CPU base의 간단한 simulation 위주로 작성했다.</p>

<blockquote>
  <p><a href="https://matthias-research.github.io/pages/tenMinutePhysics/index.html">https://matthias-research.github.io/pages/tenMinutePhysics/index.html</a></p>
</blockquote>

<blockquote>
  <p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/5">https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/5</a></p>
</blockquote>

<ul>
  <li><a href="#pbd-position-based-dynamics">PBD: Position Based Dynamics</a>
    <ul>
      <li><a href="#integration-method">Integration Method</a></li>
    </ul>
  </li>
  <li><a href="#lectures--plan">Lectures \&amp; Plan</a></li>
  <li><a href="#simulations">Simulations</a>
    <ul>
      <li><a href="#compute-animation">Compute animation</a></li>
      <li><a href="#2d-simulation-setup">2D simulation setup</a></li>
      <li><a href="#cannon-ball">Cannon ball</a></li>
      <li><a href="#ball-collision---naive">Ball collision - naive</a></li>
      <li><a href="#beads-on-wire">Beads on wire</a>
        <ul>
          <li><a href="#constraint-dynamics">Constraint dynamics</a></li>
        </ul>
      </li>
      <li><a href="#triple-pendulum">Triple pendulum</a>
        <ul>
          <li><a href="#renderdoc">RenderDoc</a></li>
        </ul>
      </li>
      <li><a href="#softbody">SoftBody</a>
        <ul>
          <li><a href="#xpbd">XPBD</a></li>
          <li><a href="#interaction">Interaction</a></li>
        </ul>
      </li>
      <li><a href="#neighbor-search">Neighbor search</a>
        <ul>
          <li><a href="#spatial-hash">Spatial hash</a></li>
          <li><a href="#hash-function">hash function</a></li>
        </ul>
      </li>
      <li><a href="#collision-by-constraint">Collision by constraint</a></li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a></li>
</ul>

<hr />

<h1 id="pbd-position-based-dynamics">PBD: Position Based Dynamics</h1>

<blockquote>
  <p><a href="https://matthias-research.github.io/pages/publications/PBDTutorial2017-CourseNotes.pdf">https://matthias-research.github.io/pages/publications/PBDTutorial2017-CourseNotes.pdf</a></p>
</blockquote>

<p>이론적인 내용은 위의 survey 자료를 읽고 정리하는 것으로 진행했다. 다 읽진 못해서 계속 병행해서 읽으면서 정리하려 한다.<br />
전통적인 real-time simulation 분야에서 쓰이던 impulse나 force 기반의 접근의 문제점을 제시한다. <a href="https://en.wikipedia.org/wiki/Real-time_computer_graphics">real-time rendering</a>을 달성하기 위해서는 성능이 매우 중요한데, 실시간으로 사용자와 상호작용이 필요하면서도, 끊어지지 않는 속도로 매 frame의 계산이 완료되어야 하기 때문이다. 영화 인터스텔라의 블랙홀 장면을 렌더링하기 위해서 사전에 몇백시간의 분량을 고성능 컴퓨터로 물리학자들과 협업해서 계산했다는 글을 본적이 있는데, 그것과 대비된다.<br />
force 기반 방식에서 주로 사용하는 간단한 mass-spring model에 있어서도, 여러 문제점이 있었다.</p>
<ul>
  <li>spring network를 구성하는 방식에 따라 물체의 행동이 달라짐</li>
  <li>spring constant를 조정하는 것이 어려움</li>
  <li>mass spring network로는 부피 보존 효과를 구현하기 힘들다.</li>
</ul>

<p>이에대한 단점을 개선하는 방식이 Position 기반 방식 <code class="language-plaintext highlighter-rouge">PBD</code> 이라고 제시한다.
힘이나 속도를 변경하는 간접적인 방식이 아니라, 위치 자체를 제약조건을 만족하도록 직접 수정하고, 속도는 그에따라 업데이트 해주는 방식이다. 제약조건을 다뤄야하기 때문에, <a href="https://graphics.pixar.com/pbm2001/pdf/notesf.pdf">Constraint Dynamics</a>의 내용이 자주 등장한다. 예전에 봤던 물리엔진 관련 영상이 이와 같은 자료를 기반으로 하고 있어서 남겨놓겠다.</p>

<p><img src="https://www.youtube.com/watch?v=TtgS-b191V0" alt="" /></p>

<p><code class="language-plaintext highlighter-rouge">PBD</code>의 전체적인 알고리즘은 다음처럼 설명한다.<br />
<a href="https://matthias-research.github.io/pages/tenMinutePhysics/09-xpbd.pdf">https://matthias-research.github.io/pages/tenMinutePhysics/09-xpbd.pdf</a> 의 설명을 참고해서 디테일은 조금 다를 수 있다.</p>
<ul>
  <li>초기화. position, velocity, inverse mass
    <ul>
      <li>mass의 역수를 자주 써서 inverse mass로 관리한다. +inf의 mass 표현이 0으로 가능해니다.</li>
    </ul>
  </li>
  <li>time loop
    <ul>
      <li>모든 vertices에 대해서
        <ul>
          <li>속도에 force계산을 통한 가속도 누적
            <ul>
              <li>force 계산에는 x를 사용</li>
            </ul>
          </li>
          <li>위치에 속도 누적
            <ul>
              <li>이전 위치 x를 p에 임시 저장</li>
              <li>x에는 속도를 누적한 새로운 내용 저장</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>모든 vertices에 대해서 충돌 제약 생성
        <ul>
          <li>위치 업데이트로 인해 발생된 충돌 검출</li>
        </ul>
      </li>
      <li>모든 제약 조건에 대해서 (지정한 제약과 위의 충돌 제약 포함)
        <ul>
          <li>제약조건 projection 혹은 solve
            <ul>
              <li>x에 delta x를 직접 반영해서 업데이트</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>모든 vertices에 대해서
        <ul>
          <li>v를 (x-p)/dt로 업데이트</li>
        </ul>
      </li>
      <li>속도 update
        <ul>
          <li>여기서 충돌 등으로 인해 추가적으로 필요한 속도 처리를 해주는 것 같다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>이와 같이 알고리즘이 간단하고, 병렬화하기 좋은 구조로 되어있는 것이 장점이다. constraint solve에서는 iterative한 method를 쓰는 것 보다, dt 자체를 substep으로 쪼개서 수행하는 것이 결과가 좋다는 실험 결과도 제시한다.<br />
이 알고리즘의 correctness나 convergence rate 혹은 error approximation 등에 대해서 생각하기 위해서는 time integration 관련 내용이 등장하는데, 주요 키워드는 다음과 같다.</p>
<ul>
  <li>implicit Euler method
    <ul>
      <li>abstract에서 제약 준수와 연관된 implicit Euler method의 variational formulation이라고 소개함.</li>
    </ul>
  </li>
  <li>Verlet method
    <ul>
      <li>integration scheme이 비슷하다고 하면서 다른 method와 비교를 제시하고 있음</li>
    </ul>
  </li>
  <li>Symplectic Euler method
    <ul>
      <li>prediction step에서 사용됨. (v를 x 보다 먼저 업데이트)</li>
    </ul>
  </li>
  <li>implicit backward Euler method
    <ul>
      <li>constraint force를 반영하는 방식에서 사용됨</li>
      <li>constrained minimization으로 볼 수 있음.</li>
      <li>first order 방식 뿐 아니라 second order method도 가능함.</li>
    </ul>
  </li>
</ul>

<p>numerical integration 관련해서는 이번 기회에 못본 내용들을 좀 더 자세히 정리하고 넘어가려 한다.</p>

<h2 id="integration-method">Integration Method</h2>
<blockquote>
  <p><a href="https://adamsturge.github.io/Engine-Blog/mydoc_midpoint_method.html">https://adamsturge.github.io/Engine-Blog/mydoc_midpoint_method.html</a></p>
</blockquote>

<ul>
  <li>Euler method</li>
  <li>implicit Euler method
    <ul>
      <li>(backward)</li>
    </ul>
  </li>
  <li>Semi-implicit Euler method
    <ul>
      <li>Symplectic Euler method</li>
    </ul>
  </li>
  <li>Mid-point method</li>
  <li>Verlet method</li>
</ul>

<p>symplectic 개념과 numerical method에 대해서 더 자세히 알기 위한 수학 내용들을 보고 있었는데, 시간이 생각보다 더 소요됐다.<br />
differential geometry와 differential equation이 관련된 내용들인데, 학생때 공부했던 내용들과 겹치는 것들이 있으면서도 처음 보는 내용들도 많았다. 나름 공부하는 재미가 있어서 앞으로 더 진행하면서 시간을 나눠서 같이 공부해 나갈 계획이다.</p>

<h1 id="lectures--plan">Lectures &amp; Plan</h1>

<blockquote>
  <p><a href="https://matthias-research.github.io/pages/tenMinutePhysics/index.html">Ten Minute Physics (matthias-research.github.io)</a></p>
</blockquote>

<p><img src="https://www.youtube.com/watch?v=oPuSvdBGrpE" alt="" /></p>

<p>영상 렉쳐는 시작점으로 보고 가기 좋다. 다루는 내용은 다음과 같이 이 순서대로 나도 따라가려한다.</p>

<ul>
  <li>PBD 기반 지식</li>
  <li>2D particles</li>
  <li>constraint - beads, pendulum</li>
  <li>Soft Body - XPBD
    <ul>
      <li>spatial hashing</li>
    </ul>
  </li>
  <li>cloth</li>
  <li>GPU
    <ul>
      <li>atomic add,</li>
      <li>jacobi solver, Gauss Seidel</li>
      <li>graph coloring</li>
    </ul>
  </li>
  <li>fluid</li>
</ul>

<p>우선 GPU를 사용한 연산을 다루기 이전까지는 모두 CPU 기반의 시뮬레이션들을 구현해보면서, PBD 원리나 구조를 이해하는데 중점을 두려한다.<br />
그래서 해당 예시들을 구현할 수 있는 code base를 하나로 묶어서 다양한 예제 구현을 우선적으로 진행 했고, 이후 정리된 구조를 만들어갈 계획이다.</p>

<h1 id="simulations">Simulations</h1>
<h2 id="compute-animation">Compute animation</h2>

<p>우선 이전까지 작성했던 예제들 중 앞으로 필요할 것 같은 내용을 정리했다. 먼저 compute shader에서 animation을 미리 계산하는 것은 이후 cloth interaction등에서 사용될 수 있을 것 같아 코드를 수정하고 시작했다.</p>

<p>floor를 추가하고 animation을 확인했다. empty texture를 checker board로 설정했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: left"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-2.png)</td>
      <td style="text-align: left">![image](/images/vge-pbd/vge-pbd-3.png)</td>
    </tr>
  </tbody>
</table>

<p>이전 particle 예제에서와 조금 다른 점은, 초기 transfer 부분이 필요치 않아 제거한 점이다. 그에따라서 queue ownership transfer도 잘 맞춰줘야하며, 잘못된 사용시 아래와 같은 validation layer의 error 메세지를 볼 수 있다.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>validation layer: Validation Error: [ UNASSIGNED-VkBufferMemoryBarrier-buffer-00004 ] Object 0: handle = 0x17d413d6c00, type = VK_OBJECT_TYPE_COMMAND_BUFFER; | MessageID = 0x991fd38f | vkQueueSubmit(): in submitted command buffer VkBufferMemoryBarrier acquiring ownership of VkBuffer (VkBuffer 0xad19770000000122[]), from srcQueueFamilyIndex 0 to dstQueueFamilyIndex 2 has no matching release barrier queued for execution.
</code></pre></div></div>

<p>animation 적용시, 다른 모델들은 모두 문제가 없었는데, ship 모델에만 문제가 있어서 확인해본 결과, compute dispatch에서 실수가 있었다. 원인은 dispatch시 model vertex count를 제대로 맞추지 않았던 것이었다.<br />
이외에도 buffer alignment나, skinning시 node hierarchy, 등에서 잘못된 부분은 없나 체크하며 다음 단계로 넘어갔다.</p>

<p><img src="/images/vge-pbd/vge-pbd-4.png" alt="image" /></p>

<h2 id="2d-simulation-setup">2D simulation setup</h2>

<p><img src="/images/vge-pbd/vge-pbd-5.png" alt="image" /></p>

<p>floor와 animation을 정리한 이후에는, 2D simulation을 추가해줄 사각형 frame과, 단순한 원과 같은 2D geometry model 들을 생성할 수 있는 구조를 추가했다.<br />
lighting 관련해서는 기존의 point light 하나를 그대로 유지했는데, 필요시 point light를 추가하거나 directional light와 함께 사용해도 좋을 것 같다.<br />
우선은 2D simulation에는 lighting의 별도 적용 없이 단색으로 표현되도록 설정했다.</p>

<h2 id="cannon-ball">Cannon ball</h2>

<p><img src="/images/vge-pbd/vge-pbd-6.png" alt="image" />
단순히 중력에 영향을 받아 움직이는 2d ball이다. 벽과의 충돌만 처리했다.</p>

<h2 id="ball-collision---naive">Ball collision - naive</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-7.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-collision-naive.gif)</td>
    </tr>
  </tbody>
</table>

<p>단순한 방식의 collision 처리이다.
ball 들이 서로 충돌했을 때 mass를 고려한 충돌을 처리했다.<br />
충돌 검출이 단순한 방식의 O(n^2) 이기 때문에 많은 수의 ball을 처리할 수 없는 한계가 있다.</p>

<h2 id="beads-on-wire">Beads on wire</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-8.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-beads.gif)</td>
    </tr>
  </tbody>
</table>

<p>원형 wire에 구슬 beads가 껴있는 상황에 대한 시뮬레이션이다.  ball끼리의 충돌은 이전 예제와 동일하다. 추가된 점은 ball이 원형 wire위에 있도록 유지되는 것인데, 이 현상을 쉽게 묘사하는 방법이 제약조건을 활용한 constraint dynamics이다.</p>

<p>아래는 이 제약조건을 활용한 시뮬레이션과 직접 수식을 풀어서 계산한 analytic 한 solution의 비교장면이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-9.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-bead-analytic.gif)</td>
    </tr>
  </tbody>
</table>

<p>처음에는 붉은색(analytic solution)과 파란색(simulation) 결과가 동일하게 움직이지만 오차가 점차 커지는 것을 볼 수 있다.<br />
여러 방법으로 이 오차를 줄일 수 있는데, substep 수를 늘리는 방식으로 간단하게 해결 가능하다.</p>

<p>렉쳐에서는 제약조건 달성을 위한 세가지 기존의 방법을 설명하고, 우리가 사용할 PBD 방식의 해결법이 이 문제들을 어떻게 처리하는지 설명한다.</p>
<ul>
  <li>spring을 활용
    <ul>
      <li>stiffness를 조정해야하는 문제가 있고, 큰 stiffness는 numerical problems를 일으킨다.</li>
    </ul>
  </li>
  <li>generalized coordinates
    <ul>
      <li>원운동을 해야하면 polar coordinates로 모든 위치 계산에 사용되도록 설정해서 아예 움직임을 제한하는 방법이다.</li>
      <li>계산이 복잡해지는 문제가 있다.</li>
      <li>참고 사이트를 추천. <a href="https://myphysicslab.com/">https://myphysicslab.com/</a></li>
    </ul>
  </li>
  <li>constraint force를 푸는 방법
    <ul>
      <li>velocity를 constraint manifold에 tangential하게 만드는 방법이라고 한다.</li>
      <li>초기값이 만족되어야 하고, drift와 관련된 문제가 있다고 한다.</li>
      <li>자세한 내용은 다음의 constraint dynamics에 나와있다.</li>
    </ul>
  </li>
</ul>

<p>PBD 적용된 방식을 요약하면 다음과 같다.</p>
<ul>
  <li>bead가 not on wire이면 wire로 옮긴다.</li>
  <li>velocity도 그 옮겨준 위치를 사용해서 update한다.
    <ul>
      <li>복잡한 calculus나, 힘과 가속도 계산, drift fixing 등의 과정이 필요없다.</li>
      <li>constraint force를 간접적으로 계산해낼 수도 있다.</li>
    </ul>
  </li>
  <li>substep을 사용해서 정확도를 높일 수 있다.
    <ul>
      <li>substep을 늘리면 결국 한번의 업데이트에 사용되는 dt가 작아지게 되면서 수치들이 precision 범위 밖으로 내려갈 수도 있게 된다. 모두 float (16bytes)의 값을 사용하다가, 이 예제부터 double을 사용하도록 수정했다.</li>
    </ul>
  </li>
  <li>analytic solution과 비교해서, PBD의 방식이 정답에 converge하는 것을 확인 가능하고, constraint force등의 수치도 비교가능하다.</li>
</ul>

<h3 id="constraint-dynamics">Constraint dynamics</h3>
<p><a href="https://graphics.pixar.com/pbm2001/pdf/notesf.pdf">https://graphics.pixar.com/pbm2001/pdf/notesf.pdf</a></p>

<p>geometric constraints (일정 거리를 유지해야 한다던가, 원운동을 해야한다던가)를 만족하면서 물리적 법칙을 따르는 운동을 하도록 하는 것이 목표인 내용이다.<br />
이를 위해서 constraint force를 직접 계산해서 particle의 가속도를 legal하도록 변환하는 작업을 수행한다.<br />
결국 constraint 만족을 위해 힘과 가속도에 초점을 맞추는 방식인 반면 PBD는 위치에 초점을 맞춘다고 보면 될 것 같다. 
사용되는 용어는 notation이 유사한 것이 많아 한번 읽어보면 PBD 이해에도 도움이 된다.</p>

<p><img src="/images/vge-pbd/vge-pbd-17.png" alt="image" /></p>

<h2 id="triple-pendulum">Triple pendulum</h2>

<p>여기서는 hard constraint와 PBD 적용에 대해서 다룬다.</p>
<ul>
  <li>일정 거리가 유지되어야 함
    <ul>
      <li>stiffness가 무한인 spring으로 볼 수 있다.</li>
      <li>cloth not stretch나 hair, robot arms 등에 유용하다.</li>
    </ul>
  </li>
  <li>stiff spring 은 stiffness 튜닝이 필요하고, 클 경우에는 numerical problems의 문제가 있다.
    <ul>
      <li>그래서 constraint force를 쓰는 방법
        <ul>
          <li>두 입자 사이의 선에 수직인 방향으로만 움직이도록 constraint force를 줘서 거리를 유지시키는 개념.</li>
          <li>drift problems를 해결해야한다.</li>
        </ul>
      </li>
      <li>generalized coorindates를 쓰는 방법
        <ul>
          <li>x1, x2 대신, middle x와 각도 alpha를 쓰면, by construction으로 제약조건 만족이 가능해지지만 수식이 복잡해진다.</li>
        </ul>
      </li>
      <li>PBD 방식</li>
    </ul>
  </li>
</ul>

<p>PBD 방식에서는 x를 먼저 constraint를 만족하는 위치로 옮긴다.<br />
이때 질량에 반비례하는 weight를 줘서 constraint를 반영한다. 
벽에 고정된 묘사는 질량을 무한으로 주면 된다. (질량의 역수를 0으로 설정)<br />
XPBD라는 확장된 방식에 대해서도 언급하는데, soft constraint에서는 accuracy를 높여주지만 hard constraint에서는 차이가 없다고 한다.</p>

<p>아래는 triple pendulum의 hard constraint를 PBD 방식으로 구현한 과정이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">image</th>
      <th style="text-align: left">explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-10.png)</td>
      <td style="text-align: left">기본적으로 필요한 값들은 pos, vel, mass, length, theta, omega, prePos이다. <br /> 붉은색은 비교를 위한 analytic한 solution이다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-11.png)</td>
      <td style="text-align: left">particle 사이에 line을 추가해준 형태이다. line은 하나의 동일한 직선 모델을 transformation만 바꿔가며 보이도록 설정했다. 이제 좀 pendulum같아 보인다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-12.png) ![image](/images/vge-pbd/vge-pbd-14.png)</td>
      <td style="text-align: left">particle의 움직임을 보기위해, tail(혹은 trail, trajectory)를 추가한 모습이다.  <br /> 이전 particle 예제에서 초기에 구현했던 방식과 유사하게 구현했는데, 모든 시뮬레이션이 CPU 기반이기도 하고 particle수가 많지 않아 단순한 방식으로 CPU에서 계산한 tail을 mapped buffer에 memcpy하는 방식으로 구현했다.</td>
    </tr>
  </tbody>
</table>

<p>tailData에는 각 circle 마다 tailSize의 n개 position 정보가 순서대로 저장된다.<br />
tailIndices에는 각 circle 마다 2 * n 의 index 정보가 들어 있는데, 0-&gt;1 – 1-&gt;2 – 2-&gt;3 – 3-&gt;4 – … – (n-1)-&gt;0 의 형태이다. 이 값들은 loop형태인데, 중간의 한 부분은 끊어지도록 i-&gt;i로 index를 업데이트 해준다.</p>

<p>이 i값을 결정하기 위해서 tail의 첫 시작점을 알릴 frontIndex를 저장하고 있는데, 이 값은 shader로 전달해서 fade out 효과를 vertex shader에서 처리할 때도 사용한다.</p>

<p><img src="/images/vge-pbd/vge-pbd-pendulum.gif" alt="image" /></p>

<p>particle 수를 옵션에서 늘릴 수 있게 했는데, 다음과 같은 결과가 나온다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-16.png)</td>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-13.png)</td>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-15.png)</td>
    </tr>
  </tbody>
</table>

<h3 id="renderdoc">RenderDoc</h3>

<blockquote>
  <p><a href="https://renderdoc.org/docs/index.html">https://renderdoc.org/docs/index.html</a></p>
</blockquote>

<p>해당 post 작성하면서 자료를 구성할 때, tail 부분 bug fix를 진행했다. 이때, tail의 fade out 관련 연산이 이뤄지는 vertex shader에서의 문제를 찾기 위해서 renderDoc을 처음 사용해서 디버깅을 진행했는데, 해당 과정을 추가해놓으려 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">image</th>
      <th style="text-align: left">explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-renderDoc-1.png)</td>
      <td style="text-align: left">app launch 후, 해당 shader가 실행된 상태를 capture했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-renderDoc-2.png)</td>
      <td style="text-align: left">이후 mesh viewer에서, tail에 해당하는 VS output 정보를 보고 원하는 값이 들어 있는지 확인했다.</td>
    </tr>
  </tbody>
</table>

<p>출력한 값은 다음과 같은데, tailSize에 100이 들어있을 것으로 예상했는데, 1280이 들어있었다.</p>

<div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">tailSize</span> <span class="o">=</span> <span class="n">globalUbo</span><span class="p">.</span><span class="n">tailInfo</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">index</span> <span class="o">=</span> <span class="kt">float</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">gl_VertexIndex</span><span class="p">,</span> <span class="n">tailSize</span><span class="p">));</span>
<span class="kt">float</span> <span class="n">brightness</span> <span class="o">=</span> <span class="n">index</span><span class="o">/</span><span class="n">tailSize</span><span class="p">;</span>
<span class="n">outColor</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">tailSize</span><span class="p">,</span> <span class="n">brightness</span><span class="p">);</span>
</code></pre></div></div>

<p>확인 결과 이 값은 screenDim의 width 값이 잘못들어간 것인데, graphics global UBO의 format이 glsl과 c++ 측 차이로 인해 값이 밀려들어 간 것이었다.</p>

<h2 id="softbody">SoftBody</h2>
<p>sofybody lecture를 확인하면, 3d model에 대해서 tetrahedorn(사면체)의 부피를 보존하는 제약조건을 주어 이를 구현한다.<br />
제약조건은 크게 두가지인데, 다음과 같다.</p>
<ul>
  <li>사면체의 각 edge들의 길이 보존</li>
  <li>사면체의 부피 보존</li>
</ul>

<p>lecture의 코드에서는 이 모델과 부피보존을 위한 사면체 정보를 모두 제공하는데, 이 데이터가 어떻게 구성되었는지는 이후에 다루기때문에, 나는 3D에서 오히려 한 차원 내린 2D sofybody와 triangle을 이용해서 구현하기로 결정했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">image</th>
      <th style="text-align: left">explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-18.png)</td>
      <td style="text-align: left">초기 sofybody의 구조를 구현하고, 중력에 의한 이동을 확인했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-19.png)</td>
      <td style="text-align: left">초기 constraint를 만족 시키도록 위치를 수정해주어서, soft circle이 collapse 되는 현상이 구현된 것을 확인했다. 아직 길이와 부피 제약조건에 들어가는 계수(compliance 혹은 stiffness)를 결정하지는 않았다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-20.png)</td>
      <td style="text-align: left">soft circle이전에 더 간단한 polygon을 구현해서, 길이와 부피 제약조건의 적당한 계수들의 역할을 확인했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-21.png)</td>
      <td style="text-align: left">blender 를 활용해서 2D soft circle에 쓰일 object를 작성했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-22.png)</td>
      <td style="text-align: left">구현된 soft circle의 모습이고, 아직 collision은 구현되지 않았기에 두 softbody가 겹쳐진 모습이다.</td>
    </tr>
  </tbody>
</table>

<h3 id="xpbd">XPBD</h3>

<p>lecture 중간에 XPBD(Extended Position Based Dynamics)를 설명해주면서, 다른 방법들과 비교해주는 내용을 정리해봤다.</p>

<ul>
  <li>force based
    <ul>
      <li>관통으로 발생한 겹친 거리와 stiffness 계수를 사용해서 충돌을 처리한다.</li>
      <li>force -&gt; velocity -&gt; position 순으로 변경된다.</li>
      <li>reaction lag이 존재한다.</li>
      <li>stiff한 처리를 위해서 계수를 키우면 stability 문제와 overshooting 문제가 생긴다.
        <ul>
          <li>이 stiffness를 어떻게 정해야 하는지도 문제다.</li>
        </ul>
      </li>
      <li>k를 작게해서 squish한 system을 만들 수 있다.</li>
    </ul>
  </li>
  <li>impulse based simulation
    <ul>
      <li>관통은 detection 에만 사용된다.</li>
      <li>separating velocity가 따로 있고, impulse 개념으로 이 수치를 정한다.</li>
      <li>더 stable하고, velocity update를 통제할 수 있어서 overshooting 문제가 없다.</li>
      <li>velocity만 사용하는 방식이기에, drift 문제가 발생한다. 이를 해결하기 위한 별도의 테크닉이 필요.</li>
    </ul>
  </li>
  <li>PBD
    <ul>
      <li>관통은 detection에만 사용됨.</li>
      <li>position을 직접 바꿔서 overlap을 없앤다.</li>
      <li>그 후 dynamics를 위한 velocity update</li>
      <li>position을 통제하기 때문에, 조건없이 stable하다.</li>
      <li>drift 문제가 없다.</li>
      <li>PBD는 integrator와 solver를 합친 개념이다.</li>
      <li>constraint solve를 여러 iterative한 방식을 쓰는것 보다, substep으로 시간을 나눠서 반복하는게 더 높은 성능을 보였음.</li>
      <li>physical and accurate
        <ul>
          <li>implicit Euler integration</li>
          <li>newton minimization of a backward Euler integration step</li>
          <li>non linear Gauss-Seidel method</li>
          <li>등의 이론적 기반.</li>
          <li>하지만 softness 처리에서 계수를 곱하는 방식은 unphysical하고, time-step 크기에 dependent하다는 문제가 생김.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>XPBD
    <ul>
      <li>soft하지 않은 constraint처리에 대해서는 PBD와 동일하다. (stiffness가 inf)</li>
      <li>constraint로부터 gradient를 계산하고, lambda를 계산할 때, time-step 크기에 dependent한 compliance alpha를 넣는다.
        <ul>
          <li>이 compliance는 physical stiffness의 역수 개념이 된다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>이후 lecture에서는 변형가능한 dynamics를 구현하는 두가지 모델과 그 solver의 차이도 설명해주는데, 요약된 특성들을 나열한다.</p>
<ul>
  <li>continuous model, global solver</li>
  <li>discrete model, local solver</li>
</ul>

<h3 id="interaction">Interaction</h3>
<p>lecture와 마찬가지로, 마우스 클릭과 drag-drop을 통한 간단한 interatction part를 작성했다. 이전 particle 예제에서 사용했던, ray-cast형식의 상호작용을 활용해서 클릭한 물체를 옮길 수 있도록 구현했다.<br />
아직 충돌에 관련된 내용을 구현하지 않아 물체들이 겹쳐진다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-23.png)</td>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-24.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-soft2d.gif)</td>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-soft2d-3.gif)</td>
    </tr>
  </tbody>
</table>

<p>참고로, 출처한 자료에서는 three.js에 구현되어 있는 raycaster와 bounding sphere 기능을 사용하고 있다.</p>

<h2 id="neighbor-search">Neighbor search</h2>

<p><a href="https://www.youtube.com/watch?v=D2M8jTtKi44"></a></p>

<p>충돌을 구현하기 위해 neighbor search를 통한 충돌 인식이 먼저 필요하다.</p>

<p>여기서는 lecture를 참고해서 spatial hashing 방식을 사용했다. 이 방식은 충돌 뿐 아니라, liquid, gas, sand, snow 등의 particle 기반 시뮬레이션에 모두 사용된다고 한다. 자세한 알고리즘은 영상에 설명되어 있어 요약해서 정리해놓으려 한다.</p>

<ul>
  <li>neighbor search는 두 particle pi, pj의 거리가 d 이하인 i,j를 찾는 것이다. 이 거리 d가 2r이면, collision detection이 된다.</li>
  <li>naive한 방식. O(n^2)의 모든 particle pair에대해 intersection검사를 하는 방식.</li>
  <li>regular grid 방식.
    <ul>
      <li>particle의 center 좌표가 어떤 grid내부에 있는지를 저장하는 방식이다. 이 grid의 spacing 간격으로 좌표를 discretize하면 grid의 index를 얻을 수 있다.</li>
      <li>그 index 주변의 grid cell 들만을 대상으로 check하면 필요한 intersection check의 수를 크게 줄일 수 있다. (2D는 주변 9개, 3D는 27개의 grid cell)</li>
      <li>이 grid index를 사용하는 방식은 공간이 bounded여야만 가능하다. 그래서 필요한 개념이 hash table을 사용하는 것</li>
    </ul>
  </li>
</ul>

<h3 id="spatial-hash">Spatial hash</h3>

<p>hash table을 사용한 neighbor search 에서는 원하는 size의 table을 사용할 수 있다. 대신 서로 다른 두 grid cell이 하나의 table entry로 mapping되는 hash collision이 발생할 수 있으므로, hash function과 table size 등 설정에 주의해야한다.</p>

<p>구현은 다음 자료들을 참고했다.</p>
<ul>
  <li><a href="https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/11-hashing.html">https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/11-hashing.html</a></li>
  <li><a href="https://carmencincotti.com/2022-10-31/spatial-hash-maps-part-one/">https://carmencincotti.com/2022-10-31/spatial-hash-maps-part-one/</a></li>
  <li>hash table의 구현은 linked list로 구현하면 dense하지 않기때문에 별도의 array를 사용한 테크닉으로 구현하고 있다.
    <ul>
      <li>기본적인 아이디어는, hash table에는 해당 hash key 값에 위치한 particle의 count만 저장하고, dense array에 순차적으로 그 particle의 index를 저장한다.</li>
    </ul>
  </li>
  <li>이를 구성하는 구조는 다음처럼 나눠진다.
    <ul>
      <li>디테일은 영상 참고.</li>
      <li>hash class</li>
      <li>hash create</li>
      <li>hash query
        <ul>
          <li>query를 했을 때, 주변 cell에 포함된 모든 particle indices를 반환한다.</li>
          <li>hash collision에 의한 false positives는 단순하게 거리 check등으로 거를 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="hash-function">hash function</h3>

<p>reference</p>
<ul>
  <li><a href="https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes">https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes</a></li>
  <li><a href="https://stackoverflow.com/questions/35985960/c-why-is-boosthash-combine-the-best-way-to-combine-hash-values">https://stackoverflow.com/questions/35985960/c-why-is-boosthash-combine-the-best-way-to-combine-hash-values</a></li>
  <li><a href="https://burtleburtle.net/bob/hash/doobs.html">https://burtleburtle.net/bob/hash/doobs.html</a></li>
  <li><a href="https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/">https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/</a></li>
  <li><a href="http://myeyesareblind.com/2017/02/06/Combine-hash-values/">http://myeyesareblind.com/2017/02/06/Combine-hash-values/</a></li>
</ul>

<p>hash table 사용에서 가장 핵심이 되는 부분이다. 입력된 key 값을 어떤 hash key 값으로 변환할 지 계산하는 방식인데, 이전에 model vertex deduplication 작업에서도 잠깐 다뤘다.<br />
그때는 여러 <code class="language-plaintext highlighter-rouge">glm::vec</code> 데이터의 tuple을 combine 할때 언급했는데, pos, normal, uv, color 등이 묶여서 사용되었고, 각각의 hash key 값을 combine 해주는 방식으로 boost 구현 방식을 썼다.<br />
<a href="https://github.com/g-truc/glm/blob/master/glm/gtx/hash.inl#L6">glm의 hash 구현</a> 을 보면 vec 자체도 어떻게 hash 값이 결정되는지 볼 수 있는데, 이 역시 boost 방식이다. 이번에 그 내부를 좀 더 다뤄보려 한다.</p>

<p>hash는 결국 검색을 빠르게 하기위한 저장구조인데, data가 많으면 hash function을 통해 나온 key 값이 충돌하는 collision의 발생이 많아져 속도가 느려진다. 이 관점에서 두 data를 하나의 hash value로 합치는 간단한 방식들을 생각해보면 다음과 같다.</p>

<ul>
  <li>단순히 두 hash를 xor하는 방식 -&gt; symmetric해서 단점</li>
  <li>모든 (a, a) 형태가 0으로 매핑됨</li>
  <li>그래서 a xor b 보다는 a + b가 좀 더 좋은 hash combine이라고 볼 수 있다.</li>
  <li>hash(a) « 1 + hash(a) + hash(b)는 symmetric하지 않아서 좀 더 좋다고 볼 수 있다.</li>
  <li>이 값은 결국 hash(a) * 3 + hash(b)와 같은데, 이런식으로 홀수를 한쪽에 곱하면 bijective 한 mapping이 된다. (k-bit 데이터)</li>
  <li>boost 방식은 이와 유사하게, shift로 lhs를 섞고, 노이즈 역할의 상수를 rhs에 더한 후, 두 값을 xor 하는 원리라고 볼 수 있다.
    <ul>
      <li>이 noise가 단순히 random성을 위해서인지는 명확하지 않으나 참고 article을 보면 랜덤성과 all zero가 zero로 mapping 되지 않기 위해서 사용했다고 나와있긴하다.</li>
      <li>어떤 답변 글들은 단순히 randomness를 위해서라면 golen ratio의 역수가 아니라 pi값을 써도 된다고 하는데, 실험적으로는 큰 차이가 없다고 하는 것 같다.</li>
    </ul>
  </li>
</ul>

<p>golden ratio의 역수가 noise로 사용되는데, 이 값에 대해서 fibonacci hashing에 대한 글을 찾아봤다. 이 자료를 보면, 자료형에 따라, 2^64나 2^32를 golden ratio로 나눠서 나온 noise를 multiplicative hash 방식으로 설명하고 있다. 이를 통해 이론적으로 evenly distribute 하게 hash 값들을 mapping할 수 있는 원리라고 설명하고 있긴한데, 이 multiplicative 방식은 여러 단점이 있어 실제로 쓰이진 않지만 golden ratio가 왜 나오게 됐는지 정도의 설명은 해주는 것 같다.</p>

<p>그외에 여러 hash 방식들이 있고 실험적으로 성능들에대한 비교 자료를 남겨놨다. 참고로 c++의 std::unordered_map 같은 경우도 컴파일러마다 다른 내부 구현의 hash function을 사용한다고 하는데, VS C++은 FNV, GCC는 murmur 방식이라고 한다.<br />
이 unorderd map은 hash table의 size 마저 내부적으로 최적화해서 사용한다. hash table의 크기가 hash value에 영향을 미치기 때문인데, prime number가 되면 modulo 연산을 했을 때 collision을 줄일 수 있어서 이를 사용하는 방식과, 2의 지수 형태를 table size로 잡아서 modulo 연산의 속도를 높이는 등 각 compiler마다 hash 방식에 따라 다른 구현을 쓴다고 한다.</p>

<p>다른 rotating hash나 기법들에 대한 실험 자료도 참고 자료를 보면 상세히 알 수 있다.</p>

<h2 id="collision-by-constraint">Collision by constraint</h2>

<p>기존의 tetrahedron의 collision 처리는 다음 자료를 참고했다. (영상에서는 particle의 coliision을 다룬다.)</p>

<blockquote>
  <p><a href="https://matthias-research.github.io/pages/publications/tetraederCollision.pdf">https://matthias-research.github.io/pages/publications/tetraederCollision.pdf</a></p>
</blockquote>

<ul>
  <li>first pass
    <ul>
      <li>모든 vertices를 cell에 classified되도록 계산한다. (spacing 크기로 나누는 작업)</li>
      <li>모든 tetrahedron의 bounding rectangle AABB를 계산해서 저장해둔다.</li>
    </ul>
  </li>
  <li>second pass
    <ul>
      <li>모든 tetrahedron에 대해서 cell에 classifed 되도록 한다.</li>
      <li>저장된 AABB를 통해 cell로 mapping하고, 그 cell에 해당하는 vertices(first pass에서 계산하둥)들 모두와 intersection test를 한다.</li>
      <li>intersection test를 vertex가 tetrahedron을 관통하는지에 대해 검사하는데, barycentric coordinates를 사용.
        <ul>
          <li>그 전에 AABB내부에 있는지 검사해서 먼저 필터링한다.</li>
        </ul>
      </li>
      <li>이 방식을 사용하면, self-collision도 자연스럽게 처리가 가능하다.
        <ul>
          <li>vertex가 tetrahedron의 일부 그자체인 경우는 스킵</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>해당 자료에서는 time stamp를 사용해서 hash 초기화를 하지 않는 방식을 설명하는데, hash 생성에 관련된 부분은 영상의 방식을 선택했다.</p>

<p>먼저 좀 더 간단한 케이스인, edge-point의 collision을 distance constraint로 구현해서 동작을 확인했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-25.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-edge-constraint.gif)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p><a href="https://github.com/InteractiveComputerGraphics/PositionBasedDynamics/issues/49">https://github.com/InteractiveComputerGraphics/PositionBasedDynamics/issues/49</a></p>
</blockquote>

<p>collision handling의 경우는 rigid body의 velocity level에서 다뤄야하는데, 현재 예제들에서는 구현하지 않기로 했다.</p>

<p>collision detection과 handling에 있어서, 다른 구현들을 보면서 필요한 개념들을 찾게 되었다.</p>
<ul>
  <li>distance field</li>
  <li>bounding volume hierarchy</li>
  <li>kd-tree</li>
  <li>contact point</li>
</ul>

<p>등의 방식을 활용해서 system이 구축되어 있어야 일반적인 object간의 충돌 처리를 할 수 있을 것으로 파악했고, 우선은 constraint 기반 collision constraint 의 동작을 확인하는 것에 우선순위를 맞춰 간단한 구현을 진행했다.<br />
차선책으로 선택한 방식은, triangle과 point의 collision detection은 유지하고, handlind은 미리 저장해둔 surface(경계 edge들)와 particle을 통해 contact point를 계산해서 edge-point 의 signed distance constraint로 구현하는 방식이다.<br />
구현된 결과로 아래처럼, 충돌된 삼각형은 붉게 표시되고, 내부와 충돌하지 않도록 경계까지 밀어주는 constraint의 역할을 확인했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-26.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-pbd/vge-pbd-softbody.gif)</td>
    </tr>
  </tbody>
</table>

<h1 id="마무리">마무리</h1>

<p>아직 남은 simulation 관련 내용이 많고, 복잡도도 올라간다. 다음은 GPU 기반의 simulation을 집중해볼 생각이다. 이번에도 collision detection 및 handling 기법들에 대해서는 깊이있게 직접 구현하지 않았는데, 이런 부분들은 구현 디테일을 혼자 만들어가기에는 지금 공부하고자 하는 GPU programming 및 graphics API 활용에서 너무 벗어나게 된다. (기하 알고리즘 공부하면서 병행실습해보면 재밌을 것 같다) 이론적으로 공부하고 넘어갈 부분과 좀 더 활용까지 구현해볼 부분을 잘 나눠서 계획해나가자.</p>

<p>어디서 주워들은 이야기들로 포스트를 마무리하려 한다.</p>
<blockquote>
  <p>어떤 일을 시작할때, 어떻게 시작할지 감도 잡히지 않고 시작할 엄두가 안날때는 어떻게 해야할까?<br />
그냥 그 일을 하지 마라. 그 시작을 하지 못하는 것 자체가 진입장벽에 걸린 것이고, 그만큼 흥미가 없다는 뜻이다.<br />
진짜 하고 싶은 일은 어떻게든 찾아내서 뭔가를 시작하게 된다. 그게 1차 진입장벽을 넘은 것이다.</p>
</blockquote>

<p>어느정도 공감이 됐다. 첫 직장을 퇴사하고 시간이 꽤 흘렀는데, 알고리즘 공부나 프로그래밍 기법등 공부도 잠시 했었고, kaggle 로 사이드 프로젝트도 해봤지만 하고 싶은 일을 한다기 보다는 이직을 준비하기 위해 해야되는 것들로 생각했던 것 같다. 거기서 한발짝 더 할 일들을 찾아나가지 못했다. <br />
graphics 관련 공부를 하고 Vulkan API 관련 tutorial와 예제 구현, 블로그 정리들을 하면서는 어떻게든 다음 step을 찾게 된다. 이 tutorial을 끝내면, 이 lecture를 끝내면, 이 예제구현을 끝내면 다음에 뭘 할지 어느샌가 다음에 하고 싶은 것을 리스트업해놓게 되고 느리더라도 그 다음 스텝으로 넘어갈 수 있게 됐다.<br />
공백기간이 길어지니 준비할 방향을 잘못 잡은 것은 아닌지, 하고싶은 일을 찾는다는 생각이 오히려 기회를 좁히고 있는 것은 아닌지 하는 의심들도 들지만 이럴때 일 수록 중심을 단단하게 가져가자. 앞으로는 속도와 효율을 고려해서 스케쥴링하게되면 더 좋을 것 같다.</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[PBD(Position Based Dynamics) 관련 내용들을 습득하고 예제들을 구현해보기로 했다. lecture에는 영상과 구현 자료가 잘 정리되어 있고 논문 및 course note 등 정확한 정보가 충분해서 공부하기 좋았다. 이론과 관련되어서는 이전부터 조금씩 봐왔던 것들 중 자세히 짚고 넘어가지 못한 내용들을 정리하려 한다. numerical integration과 hash 관련 내용들이 그렇다. 여러 simtulation 예시들이 나오는데, 일부는 예시들을 그대로 구현한 것 도 있고, 일부 Vulkan 활용에 편하도록 수정한 것들도 있다. 아직은 GPU 활용한 예제를 다루지 않고 CPU base의 간단한 simulation 위주로 작성했다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vge-pbd/vge-pbd-1.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vge-pbd/vge-pbd-1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Graphics Examples - Particles</title><link href="https://keechang-choi.github.io/study/study-vge-particles/" rel="alternate" type="text/html" title="Vulkan Graphics Examples - Particles" /><published>2023-10-03T00:00:00+09:00</published><updated>2023-10-03T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-vge-particles</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-vge-particles/"><![CDATA[<p>compute shader 활용 예제를 base로, 이전에 tutorial에서 작성했던 것 보다 더 다양한 효과 구현에 목표를 뒀다.
먼저 particle 간의 gravity simulation을 작성한 후, particle dream 예제를 구현해보는 방향을 잡았다.</p>

<blockquote>
  <p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/4">https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/4</a></p>
</blockquote>

<ul>
  <li><a href="#motivation">Motivation</a></li>
  <li><a href="#prerequisites">Prerequisites</a>
    <ul>
      <li><a href="#numerical-integration">Numerical Integration</a></li>
      <li><a href="#mesh-attraction">Mesh Attraction</a></li>
    </ul>
  </li>
  <li><a href="#plan">Plan</a>
    <ul>
      <li><a href="#작업-순서">작업 순서</a></li>
      <li><a href="#cli11-and-imgui">CLI11 and ImGui</a></li>
    </ul>
  </li>
  <li><a href="#progress">Progress</a>
    <ul>
      <li><a href="#synchronization">Synchronization</a>
        <ul>
          <li><a href="#memory-barrier">Memory Barrier</a></li>
        </ul>
      </li>
      <li><a href="#particle-rendering">Particle Rendering</a>
        <ul>
          <li><a href="#graphics-pipeline">Graphics Pipeline</a></li>
        </ul>
      </li>
      <li><a href="#particle-calculate-integrate">Particle-Calculate-Integrate</a>
        <ul>
          <li><a href="#compute-pipeline-구성">Compute Pipeline 구성</a></li>
          <li><a href="#compute-shader-구성">Compute Shader 구성</a></li>
          <li><a href="#specialization-constants">Specialization Constants</a></li>
          <li><a href="#fix">Fix</a></li>
        </ul>
      </li>
      <li><a href="#two-body-simulation-and-verification">Two-Body Simulation and Verification</a></li>
      <li><a href="#trajectory">Trajectory</a>
        <ul>
          <li><a href="#visualization">Visualization</a></li>
        </ul>
      </li>
      <li><a href="#physics-and-numerical-integration">Physics and Numerical Integration</a>
        <ul>
          <li><a href="#integration-method-비교">Integration Method 비교</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#mesh-attraction-1">Mesh Attraction</a>
    <ul>
      <li><a href="#interaction">Interaction</a>
        <ul>
          <li><a href="#ray-casting">Ray-Casting</a></li>
        </ul>
      </li>
      <li><a href="#triangle-uniform-distribution">Triangle Uniform Distribution</a></li>
      <li><a href="#skinning-in-compute-shader">Skinning in Compute Shader</a>
        <ul>
          <li><a href="#recap-mesh-and-skin">Recap: Mesh and Skin</a></li>
          <li><a href="#implementation">Implementation</a></li>
        </ul>
      </li>
      <li><a href="#trajectory-in-gpu">Trajectory in GPU</a></li>
    </ul>
  </li>
  <li><a href="#demo">Demo</a></li>
  <li><a href="#마무리">마무리</a></li>
</ul>

<hr />

<h1 id="motivation">Motivation</h1>

<ul>
  <li>n body gravity simulation
    <ul>
      <li><a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/computenbody/computenbody.cpp">SaschaWillems/Vulkan-computenbody.cpp</a></li>
      <li>기본 틀은 위 예제를 따라가며 작성할 계획이다. 이전 보다 조금 더 복잡한 계산이 compute shader에서 실행되는 만큼, shared memory 사용 및 compute pipeline 구성과 syncrhonization에 초점을 맞췄다.</li>
    </ul>
  </li>
  <li>아래 자료들은 모두 particle dreams 예시의 내용을 다루는데, webGL로 작성된 것들은 demo를 브라우저에서 실행해볼 수 있게 되어 있어서 실행해보며 어떤 기능들을 넣을지 구상할 수 있었다.
    <ul>
      <li><a href="http://www.karlsims.com/particle-dreams.html">Particle Dreams (karlsims.com)</a></li>
      <li><a href="https://www.iamnop.com/works/a-particle-dream">A Particle Dream | Nop Jiarathanakul (iamnop.com)</a></li>
      <li><a href="https://github.com/byumjin/WebGL2-GPU-Particle">https://github.com/byumjin/WebGL2-GPU-Particle</a></li>
    </ul>
  </li>
  <li>animation in compute shader
    <ul>
      <li>이전 예제에서 animation 계산을 (정확히는 animation update는 cpu에서 하고, 계산된 joint matrices를 활용한 skinning계산을) vertex shader에서 실행했는데, 이번 예제 구현에서는 vertex shader 이전 단계에서 모든 animation이 완료된 animated vertices data가 SSBO형태로 필요하다.
        <ul>
          <li>이 animated vertices를 target으로 particle이 attraction 되는 효과를 만들 계획인데, 자세하게는 이 particle을 수치 적분하기 이전의 calculate compute shader에서 이 자료가 사용될 예정이다.</li>
          <li>이를 위해서 비슷한 자료를 찾아보던 중 다음의 rust로 작성된 vulkan viewer 예제에서 구조를 참고했다.</li>
        </ul>
      </li>
      <li><a href="https://github.com/KaminariOS/rustracer/blob/main/crates/examples/gltf_viewer/shaders/AnimationCompute.comp">rustracer/crates/examples/gltf_viewer/shaders/AnimationCompute.comp at main · KaminariOS/rustracer (github.com)</a></li>
    </ul>
  </li>
</ul>

<h1 id="prerequisites">Prerequisites</h1>
<h2 id="numerical-integration">Numerical Integration</h2>
<p>particle의 움직임을 나타나기 위해 처음 직관적인 접근은 뉴턴 역학을 활용하는 것이다. position을 update 하기 위해서, velocity를 사용하고, velocity를 update하기 위해서 acceleration을 사용하는 방식이다.<br />
acceleration은 우리가 지정해준 force에 따라서 계산된다.
이전까지에는 각각이 미분-적분 관계를 가진다는 기본적인 생각으로 단순하게 시간 간격 dt만 알고 있다면, 적분을 근사해서 원하는 최종 값을 얻을 수 있겠다고 생각했다. (가속도에 dt를 곱해서 속도에 누적시키고, 속도에 dt를 곱해서 위치에 누적시키는 방식)
하지만 이 dt는 fps에 영향을 받기도 하고, 계산량이 많아진다면 간격이 커지면서 오차가 커질 수 밖에 없다. 그리고, 이 누적된 오차는 global error를 만드는데, 이 error에 따라서 원하는 simulation과 전혀 다른 simulation이 나올 수도 있다. 
그래서 이 관련된 수치 적분에는 다양한 기법이 존재하는데, 처음 직관적인 방식을 <code class="language-plaintext highlighter-rouge">Euler method</code>라고 한다.<br />
이 Euler method 보다 차수를 높여서, 더 적은 오차를 갖게 하는 방식도 있는데, 여기서는 더 확장된 Runge-Kutta method에 대한 내용을 알면, 나머지는 그 특수한 경우로 볼 수도 있다.</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Euler_method">Euler method</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Midpoint_method">midpoint method</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta method</a>
    <ul>
      <li>관련 구현 자료: <a href="https://smath.com/wiki/GetFile.aspx?File=Examples/RK4-2ndOrderODE.pdf">https://smath.com/wiki/GetFile.aspx?File=Examples/RK4-2ndOrderODE.pdf</a></li>
    </ul>
  </li>
</ul>

<p>error estimation의 order이외에도, 수치 적분의 방식에따라 여러 특성을 가지는데, 아래 문서의 설명들을 보고 개념을 많이 참고 했다.</p>
<blockquote>
  <p><a href="https://adamsturge.github.io/Engine-Blog/mydoc_updated_time_integrator.html">https://adamsturge.github.io/Engine-Blog/mydoc_updated_time_integrator.html</a></p>
</blockquote>

<p>그중 <code class="language-plaintext highlighter-rouge">symplecticity</code> 라는 개념이 있는데, 이는 energy conservation과 관련된 개념으로, simulation의 장기적 결과에 큰 영향을 준다. 
위의 각 method의 order에 대응되는 method는 다음과 같다고 볼 수 있다.</p>
<ul>
  <li><a href="https://en.wikipedia.org/wiki/Semi-implicit_Euler_method">symplectic-Euler method</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Verlet_integration">Stoermer-Verlet method</a></li>
  <li><a href="https://en.wikipedia.org/wiki/Symplectic_integrator#A_fourth-order_example">fourth-order symplectic method</a></li>
</ul>

<p>해당 내용을 좀 더 이해해보려고, 수학 공부를 조금 다시 해보기도 했는데, Textbook 하나를 잡고 진득하게 공부할 필요가 있을 것 같다. 관련 키워드는 남겨놓겠다.</p>
<ul>
  <li>ODE(Ordinary Differential Equations). 관련 주제로 검색했을때는, Ernst Hairer 교재가 많이 나오긴 했다.</li>
  <li>numerical integration</li>
  <li>Hamiltonian mechanics
    <ul>
      <li>깊게 다루기보다는 주로 numerical integration을 적용할 할 예시들이 역학들이고, 수치 적분에서는 미분방정식을 evaluation해야하니 같이 나오는 것 같다.</li>
      <li>Lagrangian mechanics, calculus of variations</li>
    </ul>
  </li>
  <li>symplectic integration
    <ul>
      <li>flow, differential form</li>
      <li>differntial geoemtry관련 내용도 알면 이해하기 좋아보였다.</li>
    </ul>
  </li>
</ul>

<p>우선적으로 공부를 할 수는 없을 것 같고, 생각날때 조금씩 알아가야할 것 같아 symplectic function에 대한 개념까지만 공부했다. (integration method가 symplectic한 개념은 아직 자세히 보지 못했다.)<br />
어쨌든 해당 내용을 공부하지 않더라도, 검색해서 찾은 방식들대로 integration을 구현하면, 에너지가 보존되는 효과를 누릴수 있다.</p>

<h2 id="mesh-attraction">Mesh Attraction</h2>
<p>model의 mesh attraction에도 위의 수치 적분은 동일하게 적용된다. 단지 evalation하는 과정이, n-body simulation에서는 \(O(n^2)\) 이지만, mesh attraction에서는 미지 지정한 mesh의 vertice로 attract되도록 지정해주면 된다. (나는 attraction에 공기 저항 처럼 drag에 해당하는 force를 추가해줬다.) 여기서부터는, 물리 simulation이 아니라 특수 효과를 구성한다는 생각으로, 적절한 coefficient 조절을 통해 현실성은 고려하지 않고 보이는 것에만 집중해서 구현할 계획이다.</p>

<p>한가지 짚고 넘어갈 점은, model의 vertices 뿐만 아니라, 그 면적 자체에도 attraction이 되도록 구현하는 점이다. 이 부분을 복잡하게 생각했었는데, 다른 구현 코드들을 보니 단순히 particle 개수를 추가해서, 남는 particle들을 mesh의 내부 분할 점으로 attract 시키는 방식을 쓰고 있어 나도 그 방식을 채택했다.<br />
이때 쓰이는 테크닉이 삼각형 내부의 uniform한 random point를 생성하는 것인데, 아래 글을 참고해서 작성했다.</p>

<blockquote>
  <p><a href="https://math.stackexchange.com/questions/18686/uniform-random-point-in-triangle-in-3d">https://math.stackexchange.com/questions/18686/uniform-random-point-in-triangle-in-3d</a></p>

  <p>\(\displaylines{
  \begin{aligned}
     &amp; r_1 \sim U(0, 1) \\ 
     &amp; r_2 \sim U(0, 1) \\ 
     &amp; w_1 = \sqrt{r_1} * (1-r_2) \\ 
     &amp; w_2 = \sqrt{r_1} \\ 
     &amp; triangle \; ABC \\ 
     &amp; p = A + w_1 * (B-A) + w_2 * (C-A)
  \end{aligned}
}\)<br />
위의 방식으로 계산된 random variable p는, 삼각형 ABC 내부의 uniform distribution을 따르게 된다.</p>
</blockquote>

<p>이 좌표를 target으로, particle들이 attract되게 만들면, model의 mesh를 채우게 될 수 있을 것이다. attract되는 정도, particle의 수, 크기, 색상 등을 조정할 옵션을 만들고, mouse click 을 통한 interaction을 추가하는 것까지가 계획이다.</p>

<h1 id="plan">Plan</h1>

<h2 id="작업-순서">작업 순서</h2>
<ul>
  <li>gravity n-body simulation 구현
    <ul>
      <li>integration method를 여러 방식을 option으로 선택할 수 있도록 구현 후 비교</li>
      <li>구현 후, 2-body simulation의 analytic 한 solution 과 비교해서, 옳게 simulation 되는지 검증.
        <ul>
          <li>확인을 위한 particle의 trajectory rendering 기능 구현</li>
        </ul>
      </li>
      <li>particle 개수를 늘려서 성능확인.</li>
    </ul>
  </li>
  <li>model attraction 구현
    <ul>
      <li>model SSBO 구현 후, dynamics 없이 정지된 particle 위치 확인.</li>
      <li>skinning in compute shader 작성
        <ul>
          <li>pipeline 및 synchronization 고려</li>
        </ul>
      </li>
      <li>model 선택 기능 추가.</li>
    </ul>
  </li>
  <li>이 예제를 완료 후
    <ul>
      <li>PBD 방식에 대한 예제 구현.
        <ul>
          <li>cloth simulation도 좋을 것 같다. animation과 상호작용할 수도 있음.</li>
        </ul>
      </li>
      <li><a href="https://matthias-research.github.io/pages/publications/publications.html">Publications (matthias-research.github.io)</a></li>
      <li>CPU vs. GPU (naive) vs. GPU (PBD) 계산 성능 비교
        <ul>
          <li>collision 관련 예제를 만들어 봐도 좋겠다는 생각이 듦.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="cli11-and-imgui">CLI11 and ImGui</h2>
<p>구현하면서 command line argument와 ImGui을 통한 옵션 선택을 적극적으로 추가했다. 처음에 단순한 초기 설정들은 CLI11을 통해 구현했고, 이후 복잡한 선택이 필요한 값들은 ImGui widget을 추가해서 구현했다.<br />
상수로 박아뒀던 값들 중에서 변경이 자주 필요하거나 실험이 필요한 값들 위주로 옵션으로 변경했다. 일부 변수들은 자원 생성과 관련되어서 초기화 과정이 필요한 것들이 있는데, 이런 값들은 재시작을 통해 반영되도록 따로 표시해서 재시작 버튼을 활용할 계획이다. 재시작은 가장 편한 방법이 생성한 모든 instance를 파괴하고 새로 생성하는 것이어서 재시작 loop를 추가했다.</p>

<p>두 방식을 모두 쓰는 값도 있어서 코드의 일관성이 조금 깨진 측면도 있지만, 앞서 밝힌대로 엄격하지 않게 해당 기능들을 필요시 편하게 사용했다.</p>

<h1 id="progress">Progress</h1>
<h2 id="synchronization">Synchronization</h2>

<blockquote>
  <p><a href="https://vkguide.dev/docs/gpudriven/compute_shaders/#compute-shaders-and-barriers">https://vkguide.dev/docs/gpudriven/compute_shaders/#compute-shaders-and-barriers</a></p>
</blockquote>

<p>이전 tutorial에서 compute shader를 다룰때는, fence를 사용해서, compute shader의 계산을 host에서 기다린 후, 다음 단계 (이미지 얻어오고 draw하는 과정)를 진행했다.<br />
여기서는 다른 방식으로 synchronization을 구현하는데, pipeline barrier를 사용하는 방식이다. (필요한 이유는 제출된 command들이 submit order로 시작하지만 완료 순서는 모르기 때문)<br />
pipeline barrier에 SSBO buffer memory barrier를 사용해서 execution/memory dependency를 구성해준다.</p>
<h3 id="memory-barrier">Memory Barrier</h3>

<ul>
  <li>in a queue
    <ul>
      <li>위에서 간단히 설명한 pipeline barrier</li>
    </ul>
  </li>
  <li>two queue
    <ul>
      <li>이전 예제와의 차이점이 또 존재하는데, compute dedicated queue family의 사용이다.</li>
      <li>이전에는 하나의 queue에서 compute와 graphics 작업을 모두 수행했다면, 이번에는 compute 목적의 queue family에서 다른 queue를 하나 더 생성했다.</li>
      <li>pipeline barrier에는 이를 위한 기능이 있는데, <code class="language-plaintext highlighter-rouge">Queue family ownership transfer</code> 개념이다.</li>
    </ul>
  </li>
  <li>기본적인 설명은 다음을 참고 했다.
    <ul>
      <li><a href="https://www.khronos.org/blog/understanding-vulkan-synchronization">https://www.khronos.org/blog/understanding-vulkan-synchronization</a></li>
      <li>서로 다른 두 queue family index의 queue가 하나의 자원(buffer나 image)를 공유할 때, memory access에 synchronization을 제공.</li>
      <li>일반적인 pipeline barrier와의 차이점으로 src stage와 src access mask는 src queue쪽에, dst stage와 dst access mask는 dst queue쪽에 제출된다는 점이다.</li>
    </ul>
  </li>
  <li>자세한 설명은 spec 문서를 참고하면 된다.
    <ul>
      <li><a href="https://registry.khronos.org/vulkan/specs/1.3/html/vkspec.html#synchronization-queue-transfers">https://registry.khronos.org/vulkan/specs/1.3/html/vkspec.html#synchronization-queue-transfers</a></li>
      <li>자원을 생성할 때, <code class="language-plaintext highlighter-rouge">VkSharingMode</code>를 <code class="language-plaintext highlighter-rouge">VK_SHARING_MODE_EXCLUSIVE</code>로 지정한 경우는 명시적으로 queue family 간의 ownership을 옮겨줘야 한다.</li>
      <li>두가지 부분 release / acquire 과정으로 구성되는데,<br />
release
        <ul>
          <li>pipeline barrier가 제출하는 queue가 src queue family index에 해당한다.</li>
          <li>dst access mask는 무시된다. visibility operation이 실행되지 않는다.</li>
          <li>release operation은 availability operation이후에 실행되고, second synchronization scope의 연산들 이전에 실행된다.</li>
        </ul>

        <p>acquire</p>
        <ul>
          <li>pipeline barrier가 제출하는 queue가 dst queue family index에 해당한다.</li>
          <li>이전에 release한 자원의 영역과 일치해야 한다.</li>
          <li>src access mask가 무시된다. availability operation이 실행되지 않는다.</li>
          <li>acquire operation은 first synchronization scope의 연산들 이후에 실행되고, visibility operation 이전에 실행된다.</li>
        </ul>
      </li>
      <li>그리고 이 release와 acquire 연산들은 알맞은 순서에 실행되도록 app에서 semaphore등의 사용을 통해 execution dependency를 지정해야 한다고 한다.
        <ul>
          <li>우리도 semaphore를 통해 execution dependency를 주었는데, 사용될 부분을 미리 살펴보면 다음과 같다.
            <ul>
              <li>[1] storage buffer 로 buffer copy 직후 graphics queue에서 release (transfer queue는 별도로 쓰지 않고 graphics queue를 사용했음)</li>
              <li>[2] compute command recording에서, compute queue에서 acquire</li>
              <li>[3] recording 끝낸 후, compute queue에서 release</li>
              <li>[4] draw command recording에서, graphics queue에서 acquire</li>
              <li>[5] recording 끝낸 후, graphics queue에서 release</li>
            </ul>
          </li>
          <li>일단 첫 release는 초기화 단계이므로 가장 먼저 실행 후 마무리 된다. (<code class="language-plaintext highlighter-rouge">oneTimeSubmit()</code>을 사용했기 때문에 <code class="language-plaintext highlighter-rouge">waitIdle()</code> 과정을 통해 host에서 완료를 기다림)</li>
          <li><code class="language-plaintext highlighter-rouge">buildComputeCommandBuffers()</code> 를 먼저 호출하고 제출하게 되는데, 이때 사용하는 semaphores는 다음과 같다.
            <ul>
              <li>wait: <code class="language-plaintext highlighter-rouge">graphics.semaphores[currenrFrameIndex]</code></li>
              <li>signal: <code class="language-plaintext highlighter-rouge">compute.semaphores[currenrFrameIndex]</code></li>
            </ul>
          </li>
          <li>그 후 draw 목적의 <code class="language-plaintext highlighter-rouge">buildCommandBuffers()</code> 를 호출하고 제출하는데, 이때 사용하는 semaphores는 다음과 같다.
            <ul>
              <li>wait: <code class="language-plaintext highlighter-rouge">compute.semaphores[currenrFrameIndex]</code> (기존 presentCompleteSemaphores도 여전히 있다.)</li>
              <li>signal: <code class="language-plaintext highlighter-rouge">graphics.semaphores[currenrFrameIndex]</code> (기존 renderCompleteSemaphores도 여전히 있다.)</li>
            </ul>
          </li>
          <li>추가되는 semaphores는 두가지 종류의 frames in flight 수 만큼이고, 이 중 graphics의 것만 signaled 상태로 생성한다.</li>
          <li>정리해보면 첫 frame rendering 과정에서는 [1]의 release 이후, ([2]의 acquire과 [3]의 release)가 ([4]의 acquire과 [5]의 release) 보다 먼저 실행이 완료되고, 그 후 ([4], [5])의 실행이 완료되면 다시 ([2], [3]) 의 실행 완료가 반복되는 구조이다.
            <ul>
              <li>[2]와 [3]의 순서는 semaphore가 아니라, acquire에서 지정한 dst stage mask로 인해 생긴 execution dependency chain으로 강제된다.</li>
              <li>acquire시 second synch scope는 dst stage mask로 지정할 <code class="language-plaintext highlighter-rouge">ComputeShader</code> stage의 연산들이 되고, 그 사이에 dispatch 명령이 있고, 그 후에 release 시 first synch scope는 src stage mask로 지정할 <code class="language-plaintext highlighter-rouge">ComputeShader</code> stage의 연산들이 된다.</li>
              <li>결국 release, acquire의 정의 시 언급 된 실행 순서에 따라서, [2]의 acquire이후 [3]의 release 실행을 보장할 수 있게 된다.</li>
              <li>action type commands이외에는 stage의 개념이 없으므로, 다른 <code class="language-plaintext highlighter-rouge">vkCmdPipelineBarrier()</code> 자체가 synch scope에 포함된다고 볼 수는 없을 것 같다.</li>
            </ul>
          </li>
          <li>마찬가지로 [4]와 [5]도 중간에 지정해주는 <code class="language-plaintext highlighter-rouge">VertexInput</code> stage의 역할로 인해 execution dependency가 생길 것이다.</li>
          <li>그리고 각 pipelineBarrier에서 해당되는 src/dst stage mask 이외에는 none pipeline stage (top/bottom)을 사용해줬는데, 각각 기다릴 것이 없고 기다리게할 것이 없게 해서 알아서 최적화 되도록 설정해줄 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>예시
    <ul>
      <li><a href="https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#transfer-dependencies">https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#transfer-dependencies</a></li>
      <li>transfer 과정에서 이후에 사용할 queue의 family index가 다른 경우는 Queue family ownership transfer를 수행해주고 있다.</li>
      <li><a href="https://stackoverflow.com/questions/60310004/do-i-need-to-transfer-ownership-back-to-the-transfer-queue-on-next-transfer">https://stackoverflow.com/questions/60310004/do-i-need-to-transfer-ownership-back-to-the-transfer-queue-on-next-transfer</a>
        <ul>
          <li>위 예시에 해당하는 질문글이고, semaphore 사용과 double buffering 사용시 장점등을 답변하고 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="particle-rendering">Particle Rendering</h2>

<p>다음은 particle rendering과 shader에 관련된 부분의 진행과정이다.</p>
<ul>
  <li>vertex shader 구현 <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/shaders/particle/particle.vert">shaders/particle/particle.vert</a></li>
  <li>fragment shader 구현 <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/shaders/particle/particle.frag">shaders/particle/particle.frag</a></li>
</ul>

<p>particle의 초기 위치 설정은 원본예제의 attractor를 사용하는 방식과 동일하게 작성했다. 각 축마다 양쪽으로 2개씩 위치시키는 방식인데, 해당 위치에는 mass가 큰 particle도 하나씩 위치시켜서 attractor의 역할을 한다. 이 mass는 particle의 크기를 통해 나타내도록 shader에서 구현된다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">image</th>
      <th style="text-align: left">explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-0.png)</td>
      <td style="text-align: left">particle은 계산된 position과 <code class="language-plaintext highlighter-rouge">gl_PointSize</code> 를 이용해서, fragment shader에서 원 형태의 sprite가 되도록 표현했다. alpha값을 조절해서 중앙이 더 진하게 보이도록 설정했다. <br /> 원 주변의 사각형이 겹친 부분은 depth가 제대로 구현되지 않았는데, transparent 관련 구현 대신 depthTestEnable을 끄고 pipeline state를 생성하는 방식으로 해결했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-1.png)</td>
      <td style="text-align: left">원형의 sprite와 alpha 값 조절은 잘 표현되었지만, depthTest가 꺼졌기 때문에, 더 뒤에 있어야 할 파란 점들이 초록 점들을 뚫고 보이는 현상이다. 이를 제거하기 위해 additive color blend 방식으로 보여지도록 설정했다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-2.png)</td>
      <td style="text-align: left">additive color blend로 겹친 부분이 흰색에 가깝게 보이도록 빛나는 효과를 의도한 결과이다. <br /> color blend로 1, 1, add를 설정해 줬고, alpha blend로 src, dst, add를 설정해줬다.</td>
    </tr>
  </tbody>
</table>

<h3 id="graphics-pipeline">Graphics Pipeline</h3>
<p>graphics pipeline은 위처럼 particle rendering으로만 단순하게 구성되어 있다.
추후에 trajectory를 추가하면서, trajectory pipeline을 추가하게 된다.</p>

<h2 id="particle-calculate-integrate">Particle-Calculate-Integrate</h2>
<p>파이프라인과 그 shader 구성은 크게 2개의 step으로 이뤄진다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">step-1</code>에서 differential equation의 evalution을 통해 그 시점에 필요한 값들을 계산한다. (주로 가속도 계산이라고 생각하면 된다.)</li>
  <li><code class="language-plaintext highlighter-rouge">step-2</code>에서는 계산된 값들을 누적시키는 적분을 수행한다. 최종 position도 계산한다.</li>
</ul>

<p>이 두 단계에서 생성하는 값과 계산에 이용하는 값들은 integration method에 따라 다르다. 그리고 integration method의 stage가 여러개 필요한 경우도 있는데, Runge-Kutta method 같은 경우는 <code class="language-plaintext highlighter-rouge">step-1</code>을 4번의 stage로 나눠서 계산을 해야 한다. 결국 오차를 줄이는 것과, 계산 비용의 trade-off가 있다고 보면 될 것 같다.<br />
Euler method와 symplectic-Euler method를 비교했을 때는, 연산량의 차이가 없어서 사용하지 않을 이유가 없다.</p>
<h3 id="compute-pipeline-구성">Compute Pipeline 구성</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">step-1</code>
    <ul>
      <li>기본적으로 SSBO는 particle의 position과 velocitity 정보를 저장한다.</li>
      <li>이외에 <code class="language-plaintext highlighter-rouge">step-1</code>에서 계산해야 할 값이 \(\frac{dp}{dt}, \; \frac{dv}{dt}\)인데, integration method에 따라서 이런 값이 각각 4개씩 까지 늘어난다. 그래서 particle data의 구조는 pos, vel, pk[4], vk[4] 로 구성했다.
        <ul>
          <li>이 크기를 dynamic하게 생성해서 buffer 생성시에 설정하려고 했는데, struct 구조를 dynamic하게 바꿔야하다 보니, 적절한 방법을 찾지 못했다. 이 data 여러개를 한번에 <code class="language-plaintext highlighter-rouge">std::memcpy()</code>를 통해 SSBO로 전달해줘야 하므로 다른 stl container를 쓸 수는 없어서 조사하던 중 template programming의 방식이면 가능할지도 모르겠다는 결론에 도달했다. particle 수를 매우 큰 값으로 생성할 수 있으니 이 particle 하나의 data 량은 buffer 크기 등 영향을 많이 미치는 값이라 최적화 할 수 있으면 좋겠지만 우선은 4개씩 사용하도록 고정해놨다. 추후에 개선할 점이다.</li>
        </ul>
      </li>
      <li>이 최대 4개의 값은 순서대로 하나씩 계산될 수 있는 값이면서 differential equation의 evaluation이 필요한 과정이라 (가속도를 구하는 \(O(n^2)\)의 과정)을 최대 4번 해야한다.</li>
      <li>이 반복을 위해서, <code class="language-plaintext highlighter-rouge">step-1</code>의 pipeline과 command recording은 최대 4번 반복 가능하도록 loop를 사용해서 구현의 복잡성을 줄였다. 이 값은 처음에는 command line args로 받거나 restart imGui option으로 받아서, pipeline 생성시 사용하는 구조로 되어있다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">step-2</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">step-2</code>은 비교적 간단하다, 오래걸리는 연산도 없고 어떤 종류의 integration method 든지 한번만 실행되면 된다.</li>
      <li>binding 될 SSBO도 고정해놨으므로 각 method마다 차이점은 shader 구현에만 있다.</li>
      <li>여기서 계산된 particle의 position이 위에서 구현한 particle shader로 전달되게 된다. 그리고 그때의 graphics commands 들과의 synchronization은 Queue owenership transfer 부분에서 미리 설명한 것과 같이 semaphore를 통해 정의되게 된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">step-1</code>과 <code class="language-plaintext highlighter-rouge">step-2</code> 사이의 execution dependency
    <ul>
      <li>처음 예제를 따라 작성할때는, 하나의 SSBO만 사용했기 때문에, <code class="language-plaintext highlighter-rouge">step-1</code> 계산전에 buffer의 내용을 <code class="language-plaintext highlighter-rouge">step-2</code>에서 변경시키면 안되기 때문에 필요하다고 생각했다.</li>
      <li>현재 double-buffering(혹은 N-buffering)으로 구현한 상태에서는, 읽어오는 입력값들은 이전 <code class="language-plaintext highlighter-rouge">prevFrameIndex</code>의 SSBO를 사용하기 때문에 위의 문제는 없다.</li>
      <li>하지만, i번 particle에 대한 <code class="language-plaintext highlighter-rouge">step-1</code>의 연산이 끝나야 생성된 값들을 사용해서 i번 particle의 <code class="language-plaintext highlighter-rouge">step-2</code>번을 실행할 수 있으므로 실행 순서가 여전히 필요하긴 하다.
        <ul>
          <li>지금 드는 생각인데, calculate뒤에 integrate 내용을 붙여서 하나로 구성하면 큰 문제가 없을지도 모르겠다.</li>
          <li>성능상 이점이 있을지는 실험해봐야겠지만, 구현상 복잡도는 더 커진다. <code class="language-plaintext highlighter-rouge">step-1</code>만 여러번 반복이 필요한 경우가 있어서 <code class="language-plaintext highlighter-rouge">step-2</code>과 분리해놓는게 편하다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이 구성은 나중에 추가한 <a href="#skinning-in-compute-shader">skinning in compute shader</a> 구현 이전까지 유지되고, 이 skinnging을 위한 pipeline은 <code class="language-plaintext highlighter-rouge">step-1</code> 이전에 추가된다. (<code class="language-plaintext highlighter-rouge">step-1</code>에서 가속도 계산에 필요하므로)</li>
</ul>

<h3 id="compute-shader-구성">Compute Shader 구성</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">step-1</code>의 compute shader 구현 <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/shaders/particle/particle_calculate.comp">shaders/particle/particle_calculate.comp</a>
    <ul>
      <li>pipeline에서 설명한대로, 모든 particle pair로 발생하는 attraction의 가속도 계산의 \(O(n^2)\) 의 과정이 구현되어 있다.</li>
      <li>prevFrameIndex의 particle SSBO는 read only qualifier로 명시한다.</li>
      <li>currentFrameIndex의 particle SSBO에 이후 적분 계산에 쓰일 값들을 계산해서 저장한다.</li>
      <li>UBO로 전달되는 값들 중 사용하는 값은 다음과 같다.
        <ul>
          <li>dt: frame 사이에 시간이 얼마나 흘렀는지를 측정한 값으로 delta timing에 사용됨</li>
          <li>particleCount: particle 수 보다 많은 invocation이 이뤄질 경우에 대한 처리
            <ul>
              <li>예를들어, local workgroup dimension이 (256,1,1)이라고 하면, \(floor(numParticles/256)+1\) 만큼의 local workgroup들이 <code class="language-plaintext highlighter-rouge">vkCmdDispatch()</code>에 의해 실행될 것이다.</li>
              <li>이때 numParticles가 256의 배수가 아닐때는, 항상 <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/gl_GlobalInvocationID.xhtml"><code class="language-plaintext highlighter-rouge">gl_GlocalInvocationID</code></a>가 numParticles보다 큰 invocation이 실행될 것인데, 이런 경우를 걸러주기 위해서 필요하다.</li>
            </ul>
          </li>
          <li>gravity coefficient: 중력상수 역할의 계수</li>
          <li>power coefficient: 거리 제곱의 값에 취할 지수. 구현 상 1.5 값으로 지정하면 실제 inverse square law에 해당한다.</li>
          <li>soften coefficient 이다.</li>
        </ul>
      </li>
      <li>specialization constant 다음 값들을 전달 받는데, 이 값들은 상수로 사용되지만, compile time이 아니라 runtime에서 pipeline 생성시 전달해준 값들로 정해진다.
        <ul>
          <li>위의 계수 3가지 값도 원래는 specialization constant로 넘겨줬었는데, 실행하면서 변경해보는 것이 편해서 UBO로 형태를 바꿨다.</li>
          <li>SHARED_DATA_SIZE: \(O(n^2)\) 계산의 성능을 높이기 위한 shared memory 사용시 지정할 크기. 전체적인 shader loop와 관련있다.</li>
          <li>INTEGRATOR: integration method의 type</li>
          <li>INTEGRATOR_STEP: <code class="language-plaintext highlighter-rouge">step-1</code>을 여러번 반복하기 위해서 pipeline도 여러개를 생성하는데, 생성할 때마다 단계를 하나씩 높여서 생성하기 위한 변수이다. 내부 입출력 형태나 위치를 지정할 때 분기로 사용된다.</li>
          <li>local_size_x_id: local workgroup의 dimension
            <ul>
              <li>상수로 지정이 되어야하기 때문에 고정된 값을 사용하던 기존 구조에서 pipeline 생성시 전달해주도록 수정했다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>구조 설명
        <ul>
          <li>[<code class="language-plaintext highlighter-rouge">gl_GlobalInvocationID</code>.x]를 index로 써서 이 particle 하나에 대한 계산을 하나의 invocation에서 수행한다.</li>
          <li>한 particle의 가속도 계산에서 모든 particle의 위치가 필요하므로 loop가 필요하다. 단순히 0~ubo.particleCount-1 의 loop를 돌지 않고, 두 index i, j와 sharedData를 사용한다.</li>
          <li>i는 0부터 SHARED_DATA_SIZE 만큼 증가시키며 iteration
            <ul>
              <li>[i+<code class="language-plaintext highlighter-rouge">gl_LocalInvocationID</code>.x] index의 particle의 입력값(position 혹은 <code class="language-plaintext highlighter-rouge">step-1</code>의 이전 stage에서 계산된 결과인 <code class="language-plaintext highlighter-rouge">pk[4]</code>의 값들) 을 sharedData[<code class="language-plaintext highlighter-rouge">gl_LocalInvocationID</code>.x]에 저장한다.
                <ul>
                  <li><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/gl_LocalInvocationID.xhtml">gl_LocalInvocationID.x</a> 는 같은 work group에서의 각 invocation index이다. \(\in [0, \text{gl_WorkGroupSize.x}-1]\)</li>
                  <li>이 particleCount를 넘어가면 사용하지 않을 목적으로 입력정보 대신 0을 넣어놓는다. (이 사용하지 않을 값이 divide by zero 등의 계산상 문제를 일으키지 않을지 주의)</li>
                </ul>
              </li>
              <li>synchronization
                <ul>
                  <li>momory control
                    <ul>
                      <li><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/memoryBarrierShared.xhtml"><code class="language-plaintext highlighter-rouge">memoryBarrierShared()</code></a> 호출</li>
                      <li>invocation이 thread에 해당하는 실행 단위이므로 한 thread에서 shared variable의 변경후, 다음 접근에서 visible하도록 기다린다.</li>
                    </ul>
                  </li>
                  <li>invocation control
                    <ul>
                      <li><a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/barrier.xhtml"><code class="language-plaintext highlighter-rouge">barrier()</code></a> 호출</li>
                      <li>같은 work group의 모든 invocation이 모두 이 함수 호출 지점에 도달하도록 기다린 후 재개된다.</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>이제 j를 0부터 <code class="language-plaintext highlighter-rouge">gl_WorkGroupSize.x</code>-1 까지 iteration.
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">shardData[j]</code> 의 값을 other particle의 입력값으로 사용해서 대상 index의 particle의 가속도 정보에 누적해준다.</li>
                </ul>
              </li>
              <li><code class="language-plaintext highlighter-rouge">barrier()</code> 호출을 통해, 다음 i값의 <code class="language-plaintext highlighter-rouge">shardData</code> 업데이트를 하기 전에 사용이 끝날때까지 기다린다.(<code class="language-plaintext highlighter-rouge">memoryBarrierShared()</code> 호출은 불필요해 보여서 하지 않음.)</li>
            </ul>
          </li>
          <li>i값을 <code class="language-plaintext highlighter-rouge">SHARED_DATA_SIZE</code> 만큼 증가시켜서 반복</li>
        </ul>
      </li>
      <li>이 iteration이 끝나면, 대상 index의 particle에 영향을 주는 다른 모든 particle에 대한 가속도 계산이 끝나게 된다. (같은 workgroup내의 index의 particle들도 계산이 같은 시점에 끝났을 것이다.)</li>
      <li>이제 그 대상 particle의 <code class="language-plaintext highlighter-rouge">pk[4]</code>와 <code class="language-plaintext highlighter-rouge">vk[4]</code>에 필요한 정보의 형태로 계산해서 <code class="language-plaintext highlighter-rouge">step-1</code>의 다음 stage 혹은 <code class="language-plaintext highlighter-rouge">step-2</code>로 넘어가면 된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">step-2</code>의 compute shader 구현 <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/shaders/particle/particle_integrate.comp">shaders/particle/particle_integrate.comp</a>
    <ul>
      <li>여기서도 <code class="language-plaintext highlighter-rouge">gl_GlobalInvocationID.x</code> 의 값을 index로 사용할텐데, 차이점으로 먼저 particleCount와 비교하여 같거나 크면, <code class="language-plaintext highlighter-rouge">return;</code>을 통해 미리 계산을 종료해도 된다. (<code class="language-plaintext highlighter-rouge">step-1</code>에서는 <code class="language-plaintext highlighter-rouge">barrier()</code> 사용에 유의해야 한다.)</li>
      <li>그 후 내용은 간단하다, 넘어온 정보들을 활용해서 INTEGRATOR type에 따라 다른 방식으로 particle의 pos와 vel을 업데이트해준다.</li>
    </ul>
  </li>
  <li>업데이트가 완료된 pos값은, 이전에 작성해둔 graphics pipeline으로 넘어가서 particle rendering 부분에서 사용된다. 구현된 실행 결과들은 다음과 같다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-3.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-4.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-5.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">: ![image](/images/vge-particle-2.gif) : ||</td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th style="text-align: center">: 색 변경 및 attractor수 조절 :   |</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-6.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-7.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-8.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-9.png)</td>
    </tr>
  </tbody>
</table>

<h3 id="specialization-constants">Specialization Constants</h3>
<p>shader에서 사용하는 계수나, 상수로서 필요한 값들은 specialization constants 기능을 통해 compile 이후의 pipeline을 생성할 때, runtime에서 전달이 가능하다. 처음에는 여러 계산에 사용되는 계수들도 이 방식으로 전달해줬지만, 이후에는 실험 중 UI interation으로 변경이 필요한 값들은 Uniform buffer 사용으로 변경했다.</p>

<p>vulkan-hpp의 wrapper들을 쓰면 다음과 같은 방식으로 사용이 가능하고, 초기 전달해주던 데이터의 값들이다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vk</span><span class="o">::</span><span class="n">SpecializationMapEntry</span><span class="o">&gt;</span> <span class="n">specializationMapEntries</span><span class="p">;</span>
    <span class="n">specializationMapEntries</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
        <span class="mi">0u</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">SpecializationData</span><span class="p">,</span> <span class="n">sharedDataSize</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">));</span>
    <span class="n">specializationMapEntries</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
        <span class="mi">1u</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">SpecializationData</span><span class="p">,</span> <span class="n">gravity</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
    <span class="n">specializationMapEntries</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
        <span class="mi">2u</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">SpecializationData</span><span class="p">,</span> <span class="n">power</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>
    <span class="n">specializationMapEntries</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
        <span class="mi">3u</span><span class="p">,</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">SpecializationData</span><span class="p">,</span> <span class="n">soften</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

    <span class="n">vk</span><span class="o">::</span><span class="n">ArrayProxyNoTemporaries</span><span class="o">&lt;</span><span class="n">vk</span><span class="o">::</span><span class="n">SpecializationMapEntry</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span>
        <span class="n">specializationMapEntries</span><span class="p">);</span>
    <span class="n">vk</span><span class="o">::</span><span class="n">ArrayProxyNoTemporaries</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">SpecializationData</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="n">specializationData</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">SpecializationData</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="n">specializationData</span><span class="p">};</span>

    <span class="n">vk</span><span class="o">::</span><span class="n">SpecializationInfo</span> <span class="n">specializationInfo</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</code></pre></div></div>
<p>문법상 주의할 부분이 있는데, (a,c)로는 <code class="language-plaintext highlighter-rouge">SpecializationInfo</code>를 생성할수가 없다. compile자체가 안되는데, 다른 클래스 생성에서는 쓰던 부분이라 헷갈리는 부분이었다. 예시로 다음 사이트에서 compile해볼 수 있다. <a href="https://godbolt.org/z/v69sG4sbK">https://godbolt.org/z/v69sG4sbK</a></p>

<p>위의 compile 문제는 template argument deduction과 관련있는데, deduction 시 implicit conversion이 고려되지 않기 때문이다.<br />
a는 type이 고정되어 있기 때문에 implicit constructor 사용이 문제 없지만, c는 type T에대한 deduction이 필요해서 implicit conversion이 고려되지 않아 compile이 불가능하다.<br />
<a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction#Non-deduced_contexts">Template argument deduction - cppreference.com</a></p>

<h3 id="fix">Fix</h3>
<p>기존 원본 예제에서는 particle 수가 workgruop size의 배수가 아닐때 실행이 안되던 문제들이 있었다. 이에대해 수정한 내용들이다.</p>
<ul>
  <li>dispatch 시, 0이 들어가지 않도록 전체 <code class="language-plaintext highlighter-rouge">numParticles</code>를 workGroupSize로 나눈 후 +1을 해준다.</li>
  <li>SHARED_DATA_SIZE와 workGroupSize가 같도록 수정해줬다.
    <ul>
      <li>원본 예제에서는 다른 값이 사용될 수도 있는데, 그 경우 shader에서 index 문제가 발생하거나, 일부 particle-particle pair가 계산에 사용되지 않을 수 있다. (계산량을 줄이기 위해 의도된 것인지는 모르겠다.)</li>
    </ul>
  </li>
  <li>수정 하던 과정에서 <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/barrier.xhtml"><code class="language-plaintext highlighter-rouge">barrier()</code></a> 사용과 compute shader 개념에 부족한 부분이 있어서 computation이 멈추거나 하는 문제가 있었는데, 다음 자료를 참고했다.
    <ul>
      <li><a href="https://www.cg.tuwien.ac.at/courses/Realtime/repetitorium/VU.WS.2014/rtr_rep_2014_ComputeShader.pdf">rtr_rep_2014_ComputeShader.pdf (tuwien.ac.at)</a></li>
    </ul>
  </li>
</ul>

<h2 id="two-body-simulation-and-verification">Two-Body Simulation and Verification</h2>
<p>이제 눈에 보이는 simulation 결과를 얻게되었다. 그래서 이 결과가 의도대로 동작하는지 점검하고 다음 과정을 진행하고자 했다.</p>
<ul>
  <li>다음과 같이 다른 simulation 자료와 비교하면서 확인을 했다.
    <ul>
      <li><a href="https://evgenii.com/blog/two-body-problem-simulator/">https://evgenii.com/blog/two-body-problem-simulator/</a></li>
    </ul>
  </li>
  <li>다음 처럼 간단한 경우인 2-particle이 원운동을 하도록 수치를 조정해서 실행했다.
    <ul>
      <li>
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.\particle.exe --np 2 --na 2 -g 0.01 --rv 30 -p 1.5 -s 0.001
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>particle의 trajectory가 남지 않으니 결과를 확인하기 어려웠고, 정확한 물리량을 출력하는 것도 필요해보여 이 기능들을 먼저 추가하기로 했다.</li>
</ul>

<h2 id="trajectory">Trajectory</h2>

<p>particle이 움직이면서 만드는 궤도 혹은 자취를 남기기 위한 기능이다. 내구 구현 명칭은 <code class="language-plaintext highlighter-rouge">tail</code>로 명명했다.</p>

<ul>
  <li>첫 구현은 가장 naive 한 접근을 사용했다
    <ul>
      <li>각 particle 마다 tail이라는 queue 형태로 position을 CPU에서 저장해놓고, 이를 다시 GPU의 tail draw shader로 넘겨주는 방식이다.</li>
      <li>이때는 draw도 각 particle 수만큼 호출해줬다.</li>
      <li><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/4/commits/d0bc6b407e79fdacc48842d1acb1ac6fd186da80">commits</a></li>
      <li><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/4/commits/d465deef616374b260d36e6ae21fdb2af33f594b">commits</a></li>
    </ul>
  </li>
  <li>이후 한번의 최적화 과정을 거쳤는데, <code class="language-plaintext highlighter-rouge">drawIndexed()</code> 방식이다.
    <ul>
      <li>tail을 그릴 index는 미리 고정된 순서의 초기값을 지정해놓고, vertex만 업데이트해준 방식이다.</li>
      <li>하지만 여전히 비슷한 수준의 계산과 memory transfer가 필요했다.</li>
      <li>우선 테스트하는 수준의 numParticles에서는 적당한 연산속도로 계산이 가능해서, 당분간 이 구조를 사용했다.</li>
      <li><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/4/commits/9ee5e6cab846b452cddf3100bb5ca8307b895c93">commits</a></li>
    </ul>
  </li>
  <li>추후 model attraction부분을 작성하고 나면, 더 많은 수의 particle이 필요해서 CPU를 거치는 방식의 trajectory는 한계가 있어 모든 계산은 GPU로 옮겨줬다.
    <ul>
      <li><a href="#trajectory-in-gpu">trajectory in GPU</a></li>
    </ul>
  </li>
  <li>다음은 작성 과정에서 나온 오류와 해결 과정들이다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">&lt;div style="width:300px"&gt;image&lt;/div&gt;</th>
      <th style="text-align: left">explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-10.png)</td>
      <td style="text-align: left">처음 tailVertex의 vertex state create info에서 offset 관련 잘못된 지정으로 발생한 문제이다. 원점이 계속 포함된 trajectory가 나타났다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-11.png)</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">drawIndexed()</code> 를 사용했을 때 나타난 문제점이다. <br /> 자세히 보면, trajectory가 끊어져야하는 지점(다른 particle로 넘어갈 때)도 이어져 있는데, 파이프라인을 생성할때, inputAssemblyState의 [<code class="language-plaintext highlighter-rouge">primitiveRestartEnable</code>](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPipelineInputAssemblyStateCreateInfo.html)를 지정해주어야 하는 부분이다. 이를 통해 index buffer에 알맞는 restart index를 지정해주면, 그 index부터 geometry를 다시 그리기 시작하게 할 수 있어서 한번의 draw call로 원하는 trajectory를 모두 그릴수 있게 된다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-20.png)</td>
      <td style="text-align: left">^^</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-12.png)</td>
      <td style="text-align: left">trajectory를 올바르게 그린 후에 확인한 첫번째 오류인데, 궤도의 첫 부분의 오차가 유난히 큰 문제가 있었다. <br /> simulation 속도를 엄청 느리게 할 때는 이런 오류가 나타나지 않아 delta time과 관련된 오차 부분을 살펴봤다. 원인은 frameTimer의 값이 1.0으로 초기화 되어 있어서 발생한 integration error였고, 단순히 0으로 바꾸면서 해결됐다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-13.png)</td>
      <td style="text-align: left">최종적으로 two-particle에 대해 예상한 것과 동일한 궤도를 확인하면서 검증을 마쳤다.</td>
    </tr>
  </tbody>
</table>

<h3 id="visualization">Visualization</h3>
<p>시각적인 효과를 위해, tail의 alpha 값을 오래된 것 일수록 작아지도록 설정했다. (fade out 기능) 이 alpha 계산도 처음에는 CPU 측에서 해주다가, 이후에는 tail vertex의 head index와 차이값을 통해 shader에서 draw 직전에 계산하도록 옮겨주었다.</p>

<p>또한, tail로 사용할 vertex 수와, tail을 sampling 할 시간 간격 등을 지정해줄 수 있도록 option으로 추가했다.<br />
이 sampling 시간 간격은 0이면 매 frame update하게 되고, 그 외의 값은 seconds 단위로 update 주기에 사용된다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">: 여러 옵션으로 실행한 결과 :   |</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-14.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-15.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-16.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-17.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-18.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-49.png)</td>
    </tr>
  </tbody>
</table>

<h2 id="physics-and-numerical-integration">Physics and Numerical Integration</h2>
<p>two-body simulation 결과를 가지고, integration method를 바꿔보면서 실험을 진행했다.<br />
이를 위해 옵션 설정도 늘리고, 거리나 energy 등의 값도 plot 하도록 imGui 기능들을 추가했다.</p>

<h3 id="integration-method-비교">Integration Method 비교</h3>
<ul>
  <li>같은 시간 간격에서 error estimation order가 높은 방식을 사용할수록 오차가 줄어드는 것을 확인했다.
    <ul>
      <li>1차 -&gt; 2차 -&gt; 4차</li>
    </ul>
  </li>
  <li>같은 order라면, symplectic 방식이 장기적으로 더 안정적인 결과를 준다.
    <ul>
      <li>Euler vs. simplectic Euler</li>
      <li>midpoint vs. Verlet</li>
      <li>Runge-Kutta vs. 4th-order symplectic</li>
    </ul>
  </li>
  <li>비교를 위해 시간간격 기준을 여러번 바꿔가면서 각 방식들을 실행해봤는데, 상대적으로 큰 시간간격을 사용하면 갑자기 큰 오차가 나올때도 있고, 상대적으로 작은 시간간격을 사용하면 차이가 나타나지 않을때도 있었다.</li>
  <li>오차 수치들이 시간에 따라서 어떤 scale로 변하는지 등 구현과 상관관계를 보기위해서는 data를 export해서 더 자세히 분석할 필요가 있어서 어느정도 눈에 보이는 결과만 확인하고 정량적 분석은 하지 않고 넘어갔다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">: symplectic 하지 않은 Euler method에서의 문제점 확인 : |</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-23.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-24.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">: symplectic 하지 않은 euler method에서 장기적으로 점점 energy가 커지는 현상. tail particle 수를 늘려서 확인함.  :|</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-25.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-26.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">:어느정도 정상적인 궤도가 나오더라도 확대해보면 멀어지고 있음: |</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>높은 차수의 integrator 들을 실험한 내용은 다음과 같다.</p>
<ul>
  <li>delta time 간격이 큰 경우에 가끔씩 큰 오차가 나타남. 정확한 원인 파악하지 못함.</li>
  <li>soften 을 크게하면 잘 나타나지 않음</li>
  <li>다른 coefficient 설정에서도 동일한 양상이 나타남. 특히 거리가 가까워져서 속력이 큰 경우 오차가 커지는데, 이런 설정에서는 높은 order의 method가 더 정확한 계산을 해주는 것이 두드러짐.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">큰 delta time에서 가끔 발생하는 오차</th>
      <th style="text-align: center">다른 coefficient 설정</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-27.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-28.png)</td>
    </tr>
  </tbody>
</table>

<h1 id="mesh-attraction-1">Mesh Attraction</h1>
<p><img src="/images/vge-particle-47.png" alt="image" /></p>

<p>위의 이미지는 이전부터 사용하던 사과 model로 particle들을 위치시킨 것이다.<br />
이처럼 정적인 위치에 particle을 위치시키는 것은 단순히 초기값만 사용하면 되지만, 앞으로 추가할 기능들을 위해서는 다음의 내용들을 구현해야한다.</p>

<ul>
  <li>particle이 mesh로 attract되는 기능
    <ul>
      <li>위 이미지 처럼 model의 vertex만 사용하면 촘촘한 정도를 조정할 수 없기 때문에, mesh내부의 attract될 target position을 추가로 계산해내야 한다.</li>
      <li>particle이 움직이는 기능은 이전의 gravity simulation과 동일한 구조로 작성하면 되고, 하나의 target pos로 attract되기만 하면 돼서 더 간단하다.</li>
    </ul>
  </li>
  <li>interaction
    <ul>
      <li>특정 위치로 particle들이 모이거나, 특정 위치를 기준으로 멀어지는 기능들은 mouse interaction으로 가능하다.</li>
      <li>model을 변경했을 때, 선택한 모델로 particle들이 이동하는 기능을 구현해야 한다.</li>
    </ul>
  </li>
  <li>skinning과 animation
    <ul>
      <li>정지된 모델로 이동하는 것을 구현하고 나면, model instance를 옮기거나, model의 animation된 vertice들로 attract 되는 기능을 추가한다.</li>
      <li>이를 위해서는 미리 compute shader를 활용해서 계산된 animated model vertices를 저장하고 있어야 한다.</li>
    </ul>
  </li>
  <li>tail optimization
    <ul>
      <li>\(O(n^2)\) 연산이 필요 없으므로 vertex수가 이전보다 훨씬 많을 수 있는데, 이를 반영했을 때 이전과 같은 방식의 trajectory 기능을 사용하면 너무 느려진다.</li>
      <li>trajectory 관련 구현인 tail의 내용을 GPU 계산으로 옮겨서 연산 속도를 높이자.</li>
    </ul>
  </li>
</ul>

<h2 id="interaction">Interaction</h2>
<p><img src="/images/vge-particle-model.gif" alt="image" /></p>

<p>크게 두 가지 interaction을 추가했다.</p>
<ul>
  <li>imGui option에서 model 변경
    <ul>
      <li>모델은 모두 시작 시 load 해 놓고, option에서 선택한 model instance를 bind하는 기능만 추가하면 된다.</li>
    </ul>
  </li>
  <li>mouse click
    <ul>
      <li>glfw의 mouse input을 사용했다.
        <ul>
          <li><a href="https://www.glfw.org/docs/3.3/input_guide.html#input_mouse">https://www.glfw.org/docs/3.3/input_guide.html#input_mouse</a></li>
        </ul>
      </li>
      <li>left: 해당 position으로 모든 vertices가 끌리도록 구현</li>
      <li>right: 해당 position의 반대 방향으로 밀려나가도록 구현</li>
      <li>middle: vertices들이 초기위치로 이동하도록 구현</li>
    </ul>
  </li>
</ul>

<h3 id="ray-casting">Ray-Casting</h3>
<p>mouse left와 right 기능을 위해서는 click된 위치를 world space로 mapping 해줘야 한다.</p>

<p>개념적인 부분은 해당 <a href="http://www.opengl-tutorial.org/miscellaneous/clicking-on-objects/picking-with-a-physics-library/">opengl-tutorial</a>을 참고했다.</p>

<p>구현된 기능들을 살펴보면, <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/4/commits/d09532bb37b49a05c1795dcfed5ecc72e3eda199">commits</a></p>
<ul>
  <li>mouse position을 normalize해서 <code class="language-plaintext highlighter-rouge">normalizedMousePos</code>를 계산한다.</li>
  <li>이 값을 사용해서, ray의 방향과 시작/끝 점을 구한다.</li>
  <li><code class="language-plaintext highlighter-rouge">rayPlaneIntersection()</code> 함수를 통해, ray와 (camera의 view 방향을 normal로 하고 원점을 지나는 평면) 사이의 교점을 구한다.</li>
  <li>해당 지점을 <code class="language-plaintext highlighter-rouge">clickPos</code>로 사용해서 compute UBO에 전달한다.
    <ul>
      <li>이때, w값을 click의 종류로 지정해줬다.</li>
    </ul>
  </li>
  <li>compute shader에서 이 <code class="language-plaintext highlighter-rouge">clickData</code>를 사용해 지정된 attraction/repulsion 을 가속도에 반영한다.</li>
</ul>

<h2 id="triangle-uniform-distribution">Triangle Uniform Distribution</h2>

<p><img src="/images/vge-particle-29.png" alt="image" /></p>

<p><a href="#mesh-attraction">위에서 정리한대로</a> 삼각형 내부의 uniform한 distributon을 따르는 random한 point로 particle의 target을 추가해줬다.</p>
<ul>
  <li>전달해줄 data는 이 random weight 밖에 없다.</li>
  <li>shader에서 index를 그대로 model의 vertices로 mapping 했기 때문인데 shader에서 target position을 계산하는 방식을 보면 다음과 같다.</li>
  <li>
    <div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">vec3</span> <span class="n">targetPos</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">modelUbo</span><span class="p">.</span><span class="n">numVertices</span><span class="p">){</span>
      <span class="n">targetPos</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">pos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
      <span class="kt">uint</span> <span class="n">modIndex</span> <span class="o">=</span> <span class="kt">uint</span><span class="p">(</span><span class="n">mod</span><span class="p">(</span><span class="n">index</span><span class="o">-</span><span class="n">modelUbo</span><span class="p">.</span><span class="n">numVertices</span><span class="p">,</span> <span class="n">modelUbo</span><span class="p">.</span><span class="n">numIndices</span><span class="o">/</span><span class="mi">3</span><span class="p">));</span>
      <span class="kt">vec3</span> <span class="n">p0</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">modIndex</span><span class="o">*</span><span class="mi">3</span><span class="p">]].</span><span class="n">pos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
      <span class="kt">vec3</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">modIndex</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">]].</span><span class="n">pos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
      <span class="kt">vec3</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">modIndex</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="p">]].</span><span class="n">pos</span><span class="p">.</span><span class="n">xyz</span><span class="p">;</span>
      <span class="c1">// center of triangle</span>
      <span class="kt">vec4</span> <span class="n">attractionWeight</span> <span class="o">=</span> <span class="n">particlesIn</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">attractionWeight</span><span class="p">;</span>
      <span class="n">targetPos</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">+</span> <span class="n">attractionWeight</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">p1</span><span class="o">-</span><span class="n">p0</span><span class="p">)</span> <span class="o">+</span> <span class="n">attractionWeight</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">p2</span><span class="o">-</span><span class="n">p0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">targetPos</span> <span class="o">=</span> <span class="p">(</span><span class="n">modelUbo</span><span class="p">.</span><span class="n">modelMatrix</span> <span class="o">*</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">targetPos</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
</code></pre></div>    </div>
    <ul>
      <li>particle의 index가 model의 vertices 수보다 작을때는 mesh 내부 점을 사용하지 않는다.</li>
      <li>particle이 남는 경우는, 그 남는 index를 3개씩 묶어서 삼각형 하나씩을 찾는다.
        <ul>
          <li>그 삼각형을 기준으로 전달한 random weight에 따라 삼각형 내부의 위치를 계산한다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>위 방식에 의해, particle 수가 많으면 많을 수록 더 촘촘하게 model에 mapping 된 형상을 볼수 있게 된다.</li>
  <li>이 방식은 후에 추가할 animation in compute shader도 고려한 방식이다.
    <ul>
      <li>target vertex의 위치를 미리 지정해놓는게 아니라, index를 통해 vertex를 찾고 그 vertex위치를 기반으로 내부의 점을 계산한다.</li>
      <li>이 vertices 대신 animated vertices가 들어가기만 하면 animation된 mesh의 내부 좌표가 target으로 설정될 것이다.</li>
    </ul>
  </li>
</ul>

<p>예시 command</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.\particle.exe --np 4019 --na 6 -g 500.0 -p 0.75 -s 5.0 --tst 0.01 --ts 10 --width 1920
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-48.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-36.png)</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-30.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-37.png)</td>
      <td style="text-align: center">-</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-31.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-32.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-50.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-33.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-34.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-35.png)</td>
    </tr>
  </tbody>
</table>

<h2 id="skinning-in-compute-shader">Skinning in Compute Shader</h2>
<h3 id="recap-mesh-and-skin">Recap: Mesh and Skin</h3>
<p><a href="/_posts/2023-07-24-study-vge-pipelines.md#glTF">이전 example-pipelines</a></p>

<p><a href="/_posts/2023-08-11-study-vge-animation.md#개념">이전 example-animation</a></p>

<ul>
  <li>node가 mesh를 소유하고, skin을 참조한다.
    <ul>
      <li>mesh의 primitives에 vertex, joint index, weight 등의 정보가 들어있고, 실제 데이터는 vertex buffer에 들어있다.</li>
      <li>skin은 여러 joint node를 참조한다.</li>
    </ul>
  </li>
  <li>skinning의 정보가 mesh UBO에 들어있다.
    <ul>
      <li>기존의 구조는 node 단위로 bind 하고 draw하기에 가능한 구조.</li>
      <li>node가 skinned mesh를 가지는 경우는 skinIndex값이 해당되는 skin의 index를 가르키고, 아닌 경우는 -1 값이다.</li>
      <li>mesh가 여러 node에 나눠져 있고, skin 없이 node hierarchy만 사용하는 모델에 대한 구현은 아직 미구현이다.</li>
    </ul>
  </li>
  <li>animation update는 CPU에서 joint node의 matrix를 변경해준다.</li>
</ul>

<h3 id="implementation">Implementation</h3>
<p>이전 구현 상태에서 변경해줄 사항들이다.</p>
<ul>
  <li>glTF 모듈의 vertex/index buffer를 shader storage usage도 가능하게 한다.
    <ul>
      <li>이 값은 여러 animation 상태에 따라서 입력으로 재사용되어야 한다. 이를위해 glTF model class에서 descriptorSet bind 기능을 외부로 노출해야 한다.</li>
      <li>그리고 이 vertex가 어떤 skin을 사용하는지에 대한 정보는 compute shader에서 알 수 없으므로, attribute에 skinIndex를 추가해준다.</li>
      <li>또한 이 buffer 외에, out <code class="language-plaintext highlighter-rouge">animatedVertexBuffer</code>와 그에따른 descriptorSet이 필요하고, frames-in-flight를 고려해서 자원을 할당해야 한다.</li>
    </ul>
  </li>
  <li>node 단위의 joint matrices UBO정보를 한번에 bind할 수 있어야한다.
    <ul>
      <li>compute shader에서 skinning을 계산하기 위해서는, node 단위로 draw하지 않고, work group size로 dispatch한 결과를 <code class="language-plaintext highlighter-rouge">animatedVertexBuffer</code>에 저장해야하기 때문이다.</li>
      <li>glTF model class에서 이 모든 skin의 jointMatrices data를 외부로 반환하는 기능을 추가해야 한다.</li>
      <li>그리고 이 data는 <code class="language-plaintext highlighter-rouge">skinMatricesBuffers</code>와 <code class="language-plaintext highlighter-rouge">skinDescriptorSet</code>를 통해 SSBO로 binding 되어야 한다.</li>
    </ul>
  </li>
  <li>구현 과정에서, memory layout 관련 오류가 발생해서 정리하면서 참고했던 내용이다.
    <ul>
      <li><a href="https://stackoverflow.com/questions/16270846/when-should-i-use-std140-in-opengl">std140 usage</a></li>
      <li><a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)#Memory_layout">glsl memory layout</a></li>
    </ul>
  </li>
  <li>계획
    <ul>
      <li>model vertex attribute에 skinIndex 추가 및 저장
        <ul>
          <li>구현할 때는 따로 추가하지 않고, position의 w 값을 이용했다.</li>
        </ul>
      </li>
      <li>vertex의 descriptorSet 추가
        <ul>
          <li>기존 vertex buffer는 그대로 사용하고 usage만 추가하면됨</li>
          <li>read only로 사용할 것이므로, 기존 자원 구조 변경이 필요없음</li>
        </ul>
      </li>
      <li>mesh face attraction
        <ul>
          <li>이 부분은 미리 고려해서 구현했기 때문에 추가할 내용은 없음.</li>
        </ul>
      </li>
      <li>skin SSBO 생성
        <ul>
          <li>animation update를 매 frame하는 경우, 이 skin SSBO도 매 frame update 되어야하므로, frames-in-flight 수 만큼 생성한다.</li>
          <li>이 SSBO에는 모든 model instance의 모든 skinMatricesData가 저장된다.</li>
          <li>주기적인 update가 필요하고, 크기가 비교적 크지 않으므로, host-coherent한 타입의 buffer로 생성했다.</li>
        </ul>
      </li>
      <li>animated vertex buffer 생성
        <ul>
          <li>위 skin SSBO와 같은 이유로 같은 크기로 생성한다.</li>
          <li>각 model instance의 vertexCount 만큼의 크기가 되도록 생성하고, type은 GPU dedicated로 생성한다.</li>
          <li>animated vertex data에는 pos, normal, tangent attribute가 모두 고려되어야 한다.</li>
        </ul>
      </li>
      <li>compute shader에 필요한 데이터 binding
        <ul>
          <li>model vertices는 model class에서 구현한 bind 함수를 사용해서 bind한다.</li>
          <li>skin SSBO와 animated vertexs SSBO는 하나의 set에 다른 binding으로 지정해서 bind한다.</li>
        </ul>
      </li>
      <li>compute shader 구현
        <ul>
          <li>기존 vertex shader에서 하던 skinning 계산을 compute shader로 작성한다.</li>
          <li>skinIndex가 -1인 경우는 아무런 연산을 하지 않는다.</li>
        </ul>
      </li>
      <li>pipeline 구성 및 command buffer recording
        <ul>
          <li>기존 compute pipeline들과 유사한 방식으로 생성하고, <code class="language-plaintext highlighter-rouge">step-1</code> 이전에 recording 하고 실행이 완료되도록 pipeline barrier도 설정해준다.</li>
        </ul>
      </li>
      <li>animation 관련 내용 추가.
        <ul>
          <li>fox model의 세가지 animation을 모두 사용할 instance를 생성해서 확인한다.</li>
          <li>더 많은 vertex를 가진 ship model을 추가해서 회전하는 external animation을 하도록 추가했다.</li>
          <li>particle 수를 늘려서 테스트한다.
            <ul>
              <li>2^20 까지로 늘려서 확인.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>이번 변경으로 인해 이전에 작업해둔 내용들의 실행도 문제 없는지 확인한다.
        <ul>
          <li>n-body simulation</li>
          <li>model attraction without skinning</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">fox</th>
      <th style="text-align: center">ship</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-38.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-41.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-39.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-42.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-40.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-43.png)</td>
    </tr>
  </tbody>
</table>

<h2 id="trajectory-in-gpu">Trajectory in GPU</h2>
<p>particle 수를 늘려서 실행했을 때, fps가 매우 낮아지는 경우를 확인했다. 그리고 최대 particle 수에서는 tail길이 만큼 그 buffer 크기가 배로 커지기 때문에 너무 큰 크기로 인해 buffer 할당이 실패하는 경우도 있었다.</p>

<p>우선 적당한 particle 수에서 적당한 tail 길이에서의 성능을 높이기 위해, GPU로 해당 계산을 옮겨 tail 계산과 memory transfer 비용을 줄이기로 했다.</p>

<p>여러 방식을 고민해봤는데, 구현하기 간단한 방식을 채택했다.</p>
<ul>
  <li>tail buffer data에는 <code class="language-plaintext highlighter-rouge">numParticles</code> * <code class="language-plaintext highlighter-rouge">tailSize</code> 만큼의 vec4가 들어간다. (position + w값 color)</li>
  <li>tail buffer는 frames-in-flight 수 만큼으로 생성한다.
    <ul>
      <li>compute shader에서 변경하고, rendering에 사용되므로 중복된 자원이 필요하다고 봤다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">step-2</code> 의 integrate이 완료된 후, 계산된 새로운 particle의 position을 tail SSBO의 해당 particle index 값들 중 첫번째에 위치시켜 준다.
    <ul>
      <li>이전에 있던 값들은 한칸씩 뒤로 밀어주고 마지막 값은 버려지게한다.</li>
      <li>update할 주기가 아니라면, 아무것도 하지 않아도 된다.</li>
    </ul>
  </li>
  <li>이때 frames-in-flight를 고려하면 이전 frame의 tail buffer도 같이 bind 해줘야 하므로(particle SSBO에서 <code class="language-plaintext highlighter-rouge">preFrameIndex</code>를 쓴 것 처럼) 비효율적인 부분이 발생한다.
    <ul>
      <li>update하지 않아도 될 경우에도, 이전 frame의 tail buffer 값들을 전부 복사해줘야 한다.
        <ul>
          <li>구현 전부터 염두하던 부분인데, tailSize 만큼의 iteration이 각 particle 마다 추가되지만, particle에 대한 계산이 compute shader에서 병렬적으로 이뤄지므로 실험해볼만 하다고 생각했다.</li>
          <li>그리고 buffer 크기 한계로 인해 particle 수가 많은 경우에는 어차피 큰 tailSize를 사용할 수 없어서 성능이 치명적인 경우로 실행시키지는 않을 것 같았다.</li>
        </ul>
      </li>
      <li>이 과정을 개선시키기 위한 구조를 구상해봤는데, 구현이 복잡해지기도 하고, 이 상태로도 이미 원하는 수준의 성능 개선이 가능해서 더이상 최적화 하지 않았다.</li>
    </ul>
  </li>
  <li>queue family ownership transfer 관련 처리는 이전과 동일하게 해줘야한다. (compute queue와 graphics queue 모두에서 사용되는 SSBO이므로)</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">&lt;div style="width:300px"&gt;image&lt;/div&gt;</th>
      <th style="text-align: left">explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-19.png)</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">tailTimer</code>값을 증가시키면서 <code class="language-plaintext highlighter-rouge">tailSampleTime</code> 값을 초과하면 0.0으로 reset 시켜주고, 이 값을 UBO로 shader에 전달해, 0.0이면 tail update를 수행하는 구조로 구현했다.  <br /> 초기 구현에서는 이 0.0으로 reset을 하는 코드가 <code class="language-plaintext highlighter-rouge">frameTimer</code>만큼 increment하는 코드보다 위에 있어서 shader로 전달된 값이 0.0이 되지 않았고 tail update가 되지 않으면서 undefined 된 값이 들어가는 문제가 있었다.</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-21.png)</td>
      <td style="text-align: left">^^</td>
    </tr>
  </tbody>
</table>

<p>구현된 tail 기능을 활용해 기존 trajectory rendering이 가능했던 것 보다 더 많은 수의 particle과 긴 trajectory도 좋은 성능으로 나타낼 수 있게 됐다. 이후에 tail 관련 alpha값과, fadeout 정도, 선 width 등 수치도 수정할 수 있도록 추가해줬다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-22.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-46.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-particle-44.png)</td>
      <td style="text-align: center">![image](/images/vge-particle-45.png)</td>
    </tr>
  </tbody>
</table>

<h1 id="demo">Demo</h1>

<p>animation의 속도가 너무 느리면, particle이 이동하기 전에 target 위치가 바뀌면서 예상된 animation을 알아보기 힘든 경우가 나올 수도 있다. 관련 설정 수치들 모두 imGui 패널에서 수정가능하도록 구현되어 있다.</p>

<p><img src="/images/vge-particle-animation.gif" alt="image" /></p>

<p><img src="/images/vge-particle-ship.gif" alt="image" /></p>

<h1 id="마무리">마무리</h1>

<p>이번 compute shader 예제 작성을 하며 지난 tutorial과 이전 예제 작성에서 다뤘던 내용들이 대부분 다시 쓰였다. 그래서 애매했던 개념들은 다시 정리하면서 보충할 수 있었다. 특히 GPU memory 구조나 compute shader에서 쓰이는 기능들을 좀 더 알게되었는데, 이전 tutorial의 간단한 compute shader 구현에서는 지나쳤던 내용들을 많이 보충할 수 있었다.</p>

<p>예제에 여러기능을 추가하면서 테스트하고, 계획을 수정하다 보니 시간소요가 되는 구간들이 있었다. 처음 구조 계획을 할 때와 어느정도 기능을 구현 후 덧붙여 나가는 과정에서 좀 개발 속도가 느려진 감이 있었고, 중간에 계획한 내용들을 구현하고 조사 및 공부를 하는 과정에서는 루즈해지지 않았던 것 같다. numerical integrator 관련 이론을 공부 할 때 필요한 것 보다 더 많은 내용을 보게 되기도 했는데, 오히려 시간은 오래 걸리지 않았었다. 앞으로 필요할 때 다시 공부를 재개한다면 분명 도움이 될 것 같다.</p>

<p>이 예제 작성 완료 후 미뤄져 있던 blog 글들을 많이 쓰게 됐는데, 주로 공부나 tutorial을 따라서 연습했을 때는 게재할만한 내용이 적다는 생각이 들어서였던 것 같다. 시간이 좀 지나서 글을 쓰니 처음 기록했던 내용들이 기억에서 조금 잊혀졌을 때 다시 복습하는 느낌이 들었던 것은 좋았지만, 글을 정리하거나 여기저기 흩어진 사진이나 자료들을 모으는 시간은 더 들긴 했다.</p>

<p>이후에는 PBD와 관련된 내용의 예제를 만들어 볼 생각인데, 진행상황 기록을 좀 더 작은 단위로 나눠서 해도 좋겠다는 생각이 들었다.</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[compute shader 활용 예제를 base로, 이전에 tutorial에서 작성했던 것 보다 더 다양한 효과 구현에 목표를 뒀다. 먼저 particle 간의 gravity simulation을 작성한 후, particle dream 예제를 구현해보는 방향을 잡았다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vge-particle-42.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vge-particle-42.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Graphics Examples - Animation</title><link href="https://keechang-choi.github.io/study/study-vge-animation/" rel="alternate" type="text/html" title="Vulkan Graphics Examples - Animation" /><published>2023-08-12T00:00:00+09:00</published><updated>2023-08-12T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-vge-animation</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-vge-animation/"><![CDATA[<p>이전 예제에서 glTF모델 load와 관련 구조를 작성할 때, animation과 skinning관련된 부분들은 아직 쓰이지 않아 제외하고 구현했다.<br />
이번 예제를 통해 해당 빈 부분들의 기능을 추가했다.</p>

<blockquote>
  <p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/3">https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/3</a></p>
</blockquote>

<ul>
  <li><a href="#개념">개념</a>
    <ul>
      <li><a href="#skin">skin</a></li>
      <li><a href="#skinning-matrix">skinning matrix</a></li>
      <li><a href="#inverse-bind-matrix">inverse bind matrix</a></li>
      <li><a href="#animation">animation</a>
        <ul>
          <li><a href="#animation-channels">animation channels</a></li>
          <li><a href="#animation-samplers">animation samplers</a></li>
        </ul>
      </li>
      <li><a href="#data-transfer-structure">data transfer structure</a></li>
    </ul>
  </li>
  <li><a href="#progress">Progress</a>
    <ul>
      <li><a href="#모델">모델</a></li>
      <li><a href="#progress-0">Progress-0</a>
        <ul>
          <li><a href="#fix">fix</a></li>
        </ul>
      </li>
      <li><a href="#progress-1">Progress-1</a>
        <ul>
          <li><a href="#skinning-and-animation">skinning and animation</a></li>
          <li><a href="#skeleton-rendering">skeleton rendering</a></li>
          <li><a href="#instance-map">instance map</a></li>
        </ul>
      </li>
      <li><a href="#progress-2">Progress-2</a>
        <ul>
          <li><a href="#fix-1">fix</a></li>
          <li><a href="#bone-length-and-orientation">bone length and orientation</a></li>
          <li><a href="#bind-pose-or-empty-animation">bind pose or empty animation</a></li>
          <li><a href="#performance">performance</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a></li>
</ul>

<hr />

<style>
o { background-color: Orange }
g { background-color: Green }
r { background-color: Red }
</style>

<h1 id="개념">개념</h1>
<blockquote>
  <p><a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">gltf20-reference-guide.pdf (khronos.org)</a></p>
</blockquote>

<p>기본적인 개념은 이전과 같은 자료를 참고했다.</p>

<h2 id="skin">skin</h2>
<p>mesh에 있는 여러 vertices들이 skeleton의 각 bone 위치에 영향을 받도록 해주는 기법이다.</p>
<ul>
  <li>node는 mesh를 참조할 수 있다. (mesh가 없는 node도 있다.)
    <ul>
      <li>node는 skin도 참조할 수 있다.</li>
    </ul>
  </li>
  <li>skin은 joint들로 이뤄져 있다.
    <ul>
      <li>그리고 각 joint에 해당하는 inverse bind matrix 정보도 가지고 있는데, 이는 아래에서 설명하겠다.</li>
      <li>joint는 node의 일종이다.
        <ul>
          <li>따라서 node의 hierarchy 구조를 활용할 수 있다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>skeleton은 따로 명시적인 구조로 저장되지 않고, joint들의 계층구조가 이를 표현한다.</li>
  <li>skinned mesh는 그 primitives를 통해, joint와 weight attribute를 가진다.
    <ul>
      <li>joint는 그 vertex에 영향을 줄 joint의 index다. 보통 4개로, vec4타입을 사용한다.</li>
      <li>weight는 각 joint가 그 vertex에 얼마나 영향을 줄지를 나타낸다.</li>
    </ul>
  </li>
</ul>

<h2 id="skinning-matrix">skinning matrix</h2>
<p>skeleton의 자세에 따라서 (joint들의 변환으로 결정됨) mesh의 vertices들이 어떻게 변환될지 계산한 결과이다. 이 계산에 joint matrices와 weight들이 쓰인다.<br />
이 skin matrix를 반영한 최종 위치는 결국 shader에서 계산되는데, 
다음과 같은 예시를 들 수 있다.</p>
<blockquote>
  <p>gl_Position = P * V * M * (nodeMat) * skinMat * inPos;</p>
</blockquote>

<p>각자의 변환을 뜯어보면,</p>
<ul>
  <li>M: model space -&gt; world space
    <ul>
      <li>load된 모델자체를 이동/회전/스케일링 하는 역할로 쓰인다.</li>
    </ul>
  </li>
  <li>nodeMat: node(mesh) local space -&gt; model space
    <ul>
      <li>모델 내부의 scene graph 계층 구조를 표현하므로 별도로 필요하다.</li>
      <li>이 nodeMat이 사용되려면, mesh가 있는 node의 matrix가 있어야 하는데, 이런 자료를 많이 보진 못했다. 3D 모델링 과정 상, mesh의 좌표계를 model의 좌표계와 동일하게 보는 경우가 많은 것 같은데, <a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0">glTF-Sample-Models repo</a>를 보면, 일부 CAD 변환 데이터들에만 해당된다.</li>
    </ul>
  </li>
  <li>skinMat: mesh space -&gt; mesh space
    <ul>
      <li>
\[\sum_{i=1}^{4}{v.weight[i] * jointMatrice[v.joint[i]]}\]
      </li>
      <li>한 mesh(혹은 skin)에서 사용하는 joint들의 최대 수는 64개로 정했다. (따로 제한이 있는 것 같진 않고, buffer 크기를 고려해서 정했다.)</li>
    </ul>
  </li>
  <li>jointMat은 inverse global transform * global joint transform * inverse bind mat 으로 계산된다.
    <ul>
      <li>invese global transform: model space -&gt; mesh space
        <ul>
          <li>이 global transform은 skin을 가지고 있는 node의 matrix다.</li>
          <li>이 node를 <code class="language-plaintext highlighter-rouge">drawNode()</code> 할 때 mesh가 실제로 그려지는데, mesh의 primitives의 joint가 계산에 사용된다. 그리고 이 node의 하위에 skin이 있는게 아니라, 별도의 skin을 참조하는 것이기에 이 global transform은 shader에서 node mat을 곱하는 것을 상쇄시키도록 작용한다. 따라서 shader 구현에 따라 어떻게 계산할지가 결정된다.</li>
          <li>지금은 이게 왜 필요한지 명확히 설명되지 않았을 수 있는데, 아래에서 inverse bind matrix를 다르면서 더 자세히 설명하겠다.</li>
        </ul>
      </li>
      <li>global joint transform: joint local space -&gt; model space
        <ul>
          <li>자세에 따라 바뀌는 부분의 실질적 내용이다.</li>
          <li>animation을 구성할때도 시간에따라 이 부분이 변경된다.</li>
          <li>이름에 global이 있듯이, 모든 hierarchy의 계산이 포함된 결과가 들어간다.</li>
        </ul>
      </li>
      <li>inverse bind matrix: mesh space -&gt; joint local space
        <ul>
          <li>기본 바인드 자세에서, 각 joint의 위치가 mesh 기준 어디인지 나타내는 것이 bind matrix이다. 이 matrix의 inverse를 처음에 곱해줌으로써, mesh를 joint의 local space로 보낸다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="inverse-bind-matrix">inverse bind matrix</h2>
<p>guide의 설명으로는 inverse bind matrix관련 이해가 충분하지 않아 다음 자료들을 추가로 참고했다.</p>

<blockquote>
  <p><a href="https://github.com/KhronosGroup/glTF-Tutorials/blob/master/gltfTutorial/gltfTutorial_020_Skins.md">glTF-Tutorials/gltfTutorial/gltfTutorial_020_Skins.md at master · KhronosGroup/glTF-Tutorials (github.com)</a></p>
</blockquote>

<p>이 tutorial 자료에서, guide의 예시와 같은 자료가 쓰여서 이해에 도움이 된다.</p>

<blockquote>
  <p><a href="https://lisyarus.github.io/blog/graphics/2023/07/03/gltf-animation.html">https://lisyarus.github.io/blog/graphics/2023/07/03/gltf-animation.html</a></p>
</blockquote>

<p>더 일반적인 animation에 관련된 설명을 하는데, 가장 이해에 도움이 많이된 자료다.</p>
<ul>
  <li>skeleton based vs. <a href="https://en.wikipedia.org/wiki/Morph_target_animation">morph-target</a>
    <ul>
      <li>장점
        <ul>
          <li>저장공간이 덜 든다.</li>
          <li>frame마다 필요한 data straming이 적다.
            <ul>
              <li>mesh가 아니라, bone 정보만 전달하면 되니까. *(GPU 쪽에 animation 관련 데이터 전체를 저장해놓는 방법도 있긴 함)</li>
            </ul>
          </li>
          <li>artist 친화적</li>
          <li>animation과 model을 분리</li>
          <li>procedural animation으로 통합하기 쉽다.
            <ul>
              <li>pre-defined가 아닌 다양한 상황에서의 animation
                <ul>
                  <li>발이 땅을 통과하지 않는 것 등의 제한사항 구현</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>단점
        <ul>
          <li>정해진 format을 적절하게 parse, decode 해야함</li>
          <li>각 animated model의 bone의 변환을 계산해야함. (계산비용 및 구현 복잡도 -&gt; compute shader 사용 가능)</li>
          <li>bone data를 어떻게든 GPU로 보내야함
            <ul>
              <li>per vertex 정보가 아니고, uniform에 맞지 않을 수 있음.</li>
            </ul>
          </li>
          <li>bone transform을 vertex shader에서 적용해야해서 대략 4배 느려짐 (mat mul을 4번 더하니까, 그래도 fragment shader가 보통 더 느림)
            <ul>
              <li>이 계산을 compute shader에서 할 수도 있음. 실제로 다음 예제에서 그렇게 할 예정.</li>
              <li>성능상 차이가 있을지는 모르겠음. 확인 필요.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>bone transform(joint global transform)
    <ul>
      <li>기본적으로 joint node에 저장된 matrix를 적용하고 나서, parent의것을 적용하는 순서이다.</li>
      <li>joint local transform 이 필요한 이유는 상식적으로, 팔을 돌리는 동작을 표현할때, origin이 어깨에 있는 것이 편한 것과 같은 이유.</li>
      <li>그래서 각 bone의 local transfrom 기준은 local coorinates다. 근데 적용할 대상인 vertices들은 model(혹은 mesh)의 좌표계에 있다. (여기서 설명은 모든 mesh coordinate과 model coordinate을 동일하게 보는 것 같다.)
        <ul>
          <li>이 차이를 없애는 map: model space -&gt; bone local space 변환이 inverse bind matrix이다.</li>
        </ul>
      </li>
      <li>bone local을 옮기는 것이 다일까? 아니다. parent bone도 고려해야한다.
        <ul>
          <li>bone local transform을 적용 후, bind pose mat을 곱해서 local animation이 적용된 vertices들을 다시 모델의 기존 위치쪽으로 옮긴다.</li>
          <li>그 후 parent의 inv bind mat을 곱해서 parent bone의 local로 가져오는 방식을 반복한다.</li>
          <li>이 연속된 두 변환을 하나로 곱해서 다음처럼 표기하자.
            <blockquote>
\[\displaylines{converToParentCS(node) = \\ invBindMat(parent) * BindMat(node)}\]
            </blockquote>
            <ul>
              <li>사실 glTF에서는 이 변환을 명시적으로 가지고 있지 않다.
                <ul>
                  <li>artist들이나 3d model software에서 어떨때는 vertices들이 모델의 기본 state가 아니라, bind pose라고 하는 변환된 state의 bone에 붙어있게 하는것이 편할때가 있다. 그래서 vertices들을 각 bone이 bind pose에서 expects하는 좌표계로 옮기는 또다른 변환이 필요할지도 모르는데, 사실 필요없다고 한다.</li>
                  <li>blender에서는 world-space vertex positions가 bind pose 그 자체다. 그래서 blender에서 exported 된 animated model은 animation 없이 사용하기는 불가능하지만 효율적으로 rendering 가능한다.
                    <ul>
                      <li>이 말이 잘 이해가 안가긴하는데, bind pose라는 별도의 개념없이 rest pose가 그대로 사용된다는 말 같다. (bind pose와 rest pose가 다른 sw에서는 구분되는 개념인지도 잘 모르겠지만) 캐릭터 모델의 경우 T 자세의 bind pose 자체가 기본 vertex positions여서, animation 없이는 이 T 자세의 캐릭터 밖에 못쓴다는 말로 이해했다.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>이게 기본적인 구조인데, format에 따라 조금씩 다르다고 한다.
    <ul>
      <li>glTF에서 node로 이뤄진 구조에서 rigging/animation 관련 내용들을 정리하면 다음과 같다.</li>
      <li>armature(skeleton과 같은 뜻으로 쓰이는 것 같다.) node가 따로 있는 것이 아니고, node의 일종이다.</li>
      <li>model bind pose가 이미 모델에 적용되어 있거나, inverse bind matrix에 premultiplied 되어 있기 때문에 bind pose라는 개념을 잊어도 된다.</li>
      <li>per-bone inverse bind matrices는 accessor를 통해 접근하며 buffer에 따로 저장이 되어 있다.</li>
      <li>animation은 external하게 지정가능하거나, keyframe spline으로 저장되어 있다</li>
      <li>중요한 것은, 이 animation들이 localCS to parentCS 변환과 combined 되어있다는 것.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">converToParent()</code>에 해당하는 변환이 이미 위의 animation 결과에 반영이 되어있다는 뜻이다.</li>
        </ul>
      </li>
      <li>따라서 <code class="language-plaintext highlighter-rouge">invBindMat(parent)</code> 도 필요가 없다.</li>
    </ul>
  </li>
  <li>정리해보면, grand-parert -&gt; g-p
    <blockquote>
      <p>global(bone) =<br />
… * <o>invBindMat(g-g-p) *  bindMat(g-p) * localTransform(g-p)</o> * <br /> <g>invBindMat(g-p) * bindMat(parent) * localTransform(parent)</g> * <br /> <r>invBindMat(parent) * bindMat(current) * localTransform(current)</r> * <br /> invBindMat(current) =<br />
… * <o>converToParent(g-p) * localTransform(g-p)</o> *  <br /> <g>converToParent(p) * localTransform(parent)</g> * <br /> <r>converToParent(current) * localTransform(current)</r> * <br /> invBindMat(current) = <br />
… * <o>animation(g-p)</o> *  <br /> <g>animation(parent)</g> * <br /> <r>animation(current)</r> * <br /> invBindMat(current)</p>
    </blockquote>
    <ul>
      <li>각 색칠된 부분들이 같은 값에 대응된다고 보면 된다.</li>
      <li>이 global(bone)에 적용될 vertices는 bind pose 상태인 mesh의 vertice다.</li>
      <li>최종적으로 skin이 함께 가지고 있는 정보는, 각 bone에 해당하는 inverse bind matrices이다.</li>
    </ul>
  </li>
</ul>

<h2 id="animation">animation</h2>

<h3 id="animation-channels">animation channels</h3>
<ul>
  <li>target을 지정한다. target은 node와 path로 구성된다.</li>
  <li>path를 먼저 설명하자면, path는 translation, rotaion, scale 중 하나의 타입을 지정한다.</li>
  <li>node는 아래의 sampler를 통해 계산된 결과가 local transform으로 저장될 노드다.</li>
  <li>channel은 어떤 sampler를 사용할지도 참조한다.</li>
</ul>

<h3 id="animation-samplers">animation samplers</h3>
<ul>
  <li>sampler는 keyframe의 in/out data와 interpolation 타입으로 구성된다.</li>
  <li>input은 keyframes, output은 path에 해당하는 transform이다.</li>
  <li>원하는 time이 어느 keyframe 구간에 속하는지 찾은 후, 그 구간에 위치한 비율에 따라 output을 interpolation한 결과 transform이 channel에 명시된 node의 local transform에 저장된다.
    <ul>
      <li>보통 binary search를 통해 그 구간을 찾는다.</li>
      <li>interpolation 방식은 linear, step, cubic spline등이 될 수 있다.</li>
      <li>node가 joint에 해당하는 node이면 skinning과 결합된 animation을 만들어낸다.</li>
    </ul>
  </li>
</ul>

<h2 id="data-transfer-structure">data transfer structure</h2>

<ul>
  <li>각 model instance 의 변환
    <ul>
      <li>model instance가 움직이거나, 다른 색을 가지거나 하는 것등을 표현하기 위해 dynamic UBO를 쓰기로 결정했다.</li>
      <li>이 값은 model에 포함될 수 없다. (같은 모델이더라고, 여러개 생성해서 다른 위치에 보여주고 싶은 경우)</li>
      <li><code class="language-plaintext highlighter-rouge">maxUniformBufferRange</code>가 65536 byte일때, 4x4 matrix 하나가 64 bytes 이므로, 대략 2^10개의 model instance를 표현할 수 있으므로 충분하다고 봤다.</li>
      <li>이 dynamic UBO는 매 frame마다 update가 이뤄지므로, <code class="language-plaintext highlighter-rouge">MAX_FRAMES_IN_FLGHT</code> 수 만큼 중복해서 생성해줬다.</li>
      <li>주의해야 할 점은 aligment관련이다. 이를 위해 ubo크기보다 크게 padding을 넣어서 buffer를 생성해야 할 수 있는데, 다음 자료를 참고했다.<br />
<a href="https://vkguide.dev/docs/chapter-4/descriptors_code_more/">https://vkguide.dev/docs/chapter-4/descriptors_code_more/</a></li>
    </ul>
  </li>
  <li>skin 당 joint(bone) 의 수를 제한을 64로 뒀다.
    <ul>
      <li>어차피 한 vertex 계산에 필요한 joint matrice는 4개이긴 하지만, 그 4개는 joint index를 통해 접근한 값이다.</li>
      <li>결국 draw전에 64개의 joint matrices 전부를 bind 해야하긴 하다.</li>
      <li>node matrix와 이 joint matrices는 mesh에서 소유하는 uniform buffer로 전달한다.</li>
      <li>이때 각 joint node의 global transform을 구하는 과정에서, 매 frame마다 이 UBO의 update가 이뤄진다. 따라서 이 ubo는 <code class="language-plaintext highlighter-rouge">MAX_FRAMES_IN_FLGHT</code> 수 만큼 중복해서 생성해줬다.</li>
      <li>이 data는 크기가 크기도 하고, model마다 skin이 여러개 있을 수 있기때문에, dynamic UBO로 생성하기에는 offset mapping 도 적절치 않아 이런 구조를 사용하게 됐다.</li>
      <li>이후에 vertex shader가 아닌 compute shader에서 미리 animation을 계산할 경우에도, 모든 skin에 대해, 각 skin 하나에 해당하는 UBO의 내용을 묶어서 하나의 SSBO로 전달하고, vertex의 attribute에 skin index를 추가해주는 구조로 사용이 가능하다.</li>
    </ul>
  </li>
</ul>

<p>이에 해당 descriptor set 부분까지 작성을 완료하면, 다음처럼 animation이 없는 model instance를 그리는 것이 가능해진다.</p>

<p><img src="/images/vge-animation-0.png" alt="image" /></p>

<h1 id="progress">Progress</h1>
<h2 id="모델">모델</h2>
<p><a href="https://github.com/KhronosGroup/glTF-Sample-Models/tree/master/2.0/Fox">glTF-Sample-Models/2.0/Fox at master · KhronosGroup/glTF-Sample-Models (github.com)</a></p>

<p>해당 모델에는 rigging 작업이 이뤄져있어서, blender로 열어보면 다음처럼 skeleton과 그에따른 animation을 확인 가능하다.<br />
<img src="/images/vge-animation-1.png" alt="image" /></p>

<h2 id="progress-0">Progress-0</h2>
<ul>
  <li>axis
    <ul>
      <li>blender에서는 model의 up이 +z 방향인데, glTF로 export하면서 +y로 변환하는 옵션이 있어서 사용했다.</li>
      <li>예제들 project에서 사용하는 world space상, -y가 up이기 때문에 위 아래가 바뀐다.</li>
    </ul>
  </li>
  <li>pretransform
    <ul>
      <li>axis 관련해서, model을 loading 할때, pretransfrom과 flipY기능을 넣어놨는데, 헷갈릴 수 있어 모두 사용하지 않고 loading했다.</li>
    </ul>
  </li>
  <li>ubo
    <ul>
      <li>data transfer structure 계획에 맞춰서, joint matrices와 model matrix를 넘겨줄 buffer와 descriptorSet을 구성한다.</li>
      <li>descriptor Pool size 관련 수정도 유의해야 한다.</li>
    </ul>
  </li>
</ul>

<p>animation과 pretransform 없이 model instance만 생성하면 다음과 같은 화면이 렌더링된다.</p>

<p><img src="/images/vge-animation-5.png" alt="image" /></p>

<h3 id="fix">fix</h3>
<ul>
  <li>index
    <ul>
      <li>drawIndexed 만 지원했었는데, glTF 모델에 index 정보가 없는 경우 사용하지 않도록 추가했다.</li>
    </ul>
  </li>
  <li>normal
    <ul>
      <li>glTF 모델에 vertex attribute로 normal vector 정보가 없는 경우, 직접 삼각형으로부터 계산하도록 추가했다.</li>
    </ul>
  </li>
  <li>skeleton
    <ul>
      <li>skeleton draw 과정을 처음부터 추가하려 했는데, animation 없이 joint에 저장된 초기값을 사용해서 skeleton을 구성할 수 있을 줄 알았다.</li>
      <li>예상된 skeleton이 나오지 않았는데, glTF에는 bind pose가 명시적으로 필요 없다는 내용을 보고 이 부분 구현은 animation 이후로 조정했다. (bind pose 가 mesh 자체에 적용되어 있으니 )</li>
      <li>이 bind pose의 bones에 대해서 아직 명확히 해결책을 찾지 못했다.</li>
      <li>blender 에서는 glTF model의 import 할 때, <a href="https://docs.blender.org/manual/en/latest/addons/import_export/scene_gltf2.html#id2">guess original bind pose</a> 라는 옵션이 있는데, 이걸보면 명시적으로 저장되진 않았지만 guess는 가능한 것 같다. 그리고 joint node의 transform 으로 들어있는 초기값도 의미가 있는 값인지 확인하지 못했다.</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">: animation 추가 과정에서 발생가능한 문제 경우들:</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-animation-2.png)</td>
      <td style="text-align: center">![image](/images/vge-animation-3.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">: pre-transform 관련 문제가 있을 때 :</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-animation-4.png)</td>
      <td style="text-align: center">![image](/images/vge-animation-6.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">animation 없이 초기 joint matrices value 활용 시 문제</td>
      <td style="text-align: center">inverse bind matrix 사용하지 않았을 시 문제</td>
    </tr>
  </tbody>
</table>

<h2 id="progress-1">Progress-1</h2>
<h3 id="skinning-and-animation">skinning and animation</h3>
<ul>
  <li>skinning과 animation structure와 update animation 관련 함수를 추가한다.
    <ul>
      <li>skin
        <ul>
          <li>여러 joint Node를 raw ptr의 vector로 참조한다.</li>
          <li>그 순서에 맞게, inverse bind martices를 vector로 가진다.</li>
          <li>이 skin data의 소유는 model에서 하고, 각 node에서 skinned mesh를 가지는 경우는 skinIndex와 skin data의 raw ptr을 참조한다.</li>
        </ul>
      </li>
      <li>animation
        <ul>
          <li>animation channel들과 sampler들을 소유한다.</li>
          <li>animation channel
            <ul>
              <li>path type과 대상이 될 node의 raw ptr을 참조한다.</li>
              <li>이 node ptr을 통해 node의 transform을 변경할 것이므로, const가 아닌 raw ptr이다.</li>
            </ul>
          </li>
          <li>animation sampler
            <ul>
              <li>interpolation type</li>
              <li>key frame inputs를 vector로 가진다.</li>
              <li>output vec4를 vector로 가진다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">updateAnimation()</code>
        <ul>
          <li>args
            <ul>
              <li>frameIndex: node의 UBO 변경하므로 필요</li>
              <li>animationIndex: 한 model에 여러 animation이 있을 수 있다.</li>
              <li>time: animation에 사용될 time stamp</li>
              <li>repeat: animation을 반복할 것인지에 대한 설정</li>
            </ul>
          </li>
          <li>repeat 여부 및 key frame 값 범위를 통해 입력 time으로부터 samplerTime을 구한다.</li>
          <li>samplerTime으로 binary search를 통해 포함하는 구간을 찾는다. (<code class="language-plaintext highlighter-rouge">std::upper_bound()</code>)</li>
          <li>그 구간의 값으로 normalized 된 samplerTime의 값 <code class="language-plaintext highlighter-rouge">u</code>를 구한다.</li>
          <li><code class="language-plaintext highlighter-rouge">u</code> 값을 비율로 지정해서 그 구간의 양쪽에 해당하는 channel의 outputs 두 값을 interpolation한다.</li>
          <li>계산된 결과를 node의 transform으로 지정하는데, 이 type은 path type에 따라 translation, rotation, scale 중 적절하게 변환한다.</li>
          <li>위 과정을 animation의 모든 channel에 대해 반복한다.</li>
          <li>joint matrices 들이 변경됐을 것이므로, <code class="language-plaintext highlighter-rouge">updateNode()</code>를 호출해 UBO를 update 한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="skeleton-rendering">skeleton rendering</h3>
<p>이전에 추가 했던 skeleton rendering 부분에 대해 문제가 있었는지 재 점검하고 다듬었다. 결론적으로 기존 로직에 문제는 없었다. 흐름은 다음과 같다.</p>
<ul>
  <li>model class에 <code class="language-plaintext highlighter-rouge">getSkeletonMatrices()</code>를 구현한다.
    <ul>
      <li>모든 skin의 joint matrices를 외부로 반환한다.</li>
    </ul>
  </li>
  <li>얻어온 값은 example class의 dynamic UBO에 사용된다.
    <ul>
      <li>bone에 해당하는 수 만큼 미리 bone의 모델을 여러개 생성해놓는다.</li>
      <li>이 bone instance 하나 자체도 dynamic ubo를 통해 전달할 수 있으므로, 각각 bone에 얻어온 joint matrix를 적용해준다.</li>
      <li>이때 pre-multiply로 bone의 scale을,</li>
      <li>post-multiply로 bone이 표현할 대상 model instance의 modelMatrix를 곱해준다.</li>
    </ul>
  </li>
  <li>이후 draw에서도 이 여러 bones를 모두 draw해준다.</li>
</ul>

<p><img src="/images/vge-animation-10.png" alt="image" /> 
bone 모델은 blender를 사용해서 간단하게 만들었다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">bind pose의 bones를 의도했지만 실패한 것</th>
      <th style="text-align: center">animation 중인 bones</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-animation-17.png)</td>
      <td style="text-align: center">![image](/images/vge-animation-7.png)</td>
    </tr>
  </tbody>
</table>

<p>좌측의 이미지는 이전 step에서 실패 했던 bind pose의 skeleton을 그리려는 과정이다. 처음에는 좌표축이나 변환의 문제로 보고, 여러 방향과 위치를 다른 색 bone으로 rendering 해보면서 원인을 파악하려 했는데, 변환이나 좌표축 문제는 아닌 것으로 결론지었다.<br />
우측의 animation 구현 후, skeleton이 제 위치에 맞게 출력된 것으로 보아 skeleton과 animation은 제대로 구현된 것을 확인할 수 있었다. bone의 방향과 길이가 적절치 않은 문제는 남아있는데, 이 부분은 다음 step에서 다시 확인한다.</p>

<h3 id="instance-map">instance map</h3>

<p>다음으로 넘어가기전에, 여러 model instance를 관리하기 위한 구조를 작성했다. bone이 많아지니 model instance가 갑자기 늘어나서, 단순히 index로 관리하기에는 복잡해서 instance 이름을 활용한 map을 추가했다.</p>
<ul>
  <li>Model instance는 model을 shared_ptr로 소유한다.
    <ul>
      <li>같은 모델의 instance를 여러개 생성하기 위한 의도로 작성했는데,</li>
      <li>현재 구현에서는 같은 모델이지만 animation이 다른 경우는 분리된 model을 만들어야 하는 한계가 있다.</li>
      <li>instance name과 bone model 인지 여부, animation index, animation time을 가진다.</li>
    </ul>
  </li>
  <li>model instance 들은 vector로 example에서 소유한다.</li>
  <li>name과의 mapping을 위한, instance map은 name을 key, index vector를 value로 가진다.
    <ul>
      <li>같은 이름을 가지는 instance 여러개를 저장하기 위함인데, instance가 vector에 순서대로 저장돼서 굳이 사용할 일은 없었다.</li>
    </ul>
  </li>
  <li>model을 추가할 때는, <code class="language-plaintext highlighter-rouge">addModelInstance()</code> 함수를 사용한다.
    <ul>
      <li>instance index는 현재 <code class="language-plaintext highlighter-rouge">modelInstances</code>의 size로 지정한다.</li>
      <li><code class="language-plaintext highlighter-rouge">modelInstances</code>에 새로운 model instance를 추가한다.</li>
      <li><code class="language-plaintext highlighter-rouge">instanceMap[name]</code> 에 해당 index를 추가한다.</li>
    </ul>
  </li>
  <li>모델을 찾을때는 <code class="language-plaintext highlighter-rouge">findInstances()</code> 함수를 사용한다.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">instanceMap</code>에서 name으로 access 한 index vector를 반환한다.</li>
      <li>보통 이 반환 결과의 첫번째 값만 사용하면 되고, bones의 경우 모든 값을 사용하면 된다. 혹은 첫번째 bone의 index를 찾는다면, bone count 만큼 증가시켜가며 사용해도 무방하다.</li>
    </ul>
  </li>
</ul>

<h2 id="progress-2">Progress-2</h2>

<p>이제 여러 model instance를 다루기 편해져서, model을 늘리면서 남은 문제점들을 파악하고 있었다.<br />
해당 과정에서, 기존에 사용하던 바로 받은 glTF 모델과, blender를 거쳐서 export 된 glTF 모델을 비교하던 중 다음과 같은 문제가 발견돼서 먼저 수정하고 진행했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">laptop</th>
      <th style="text-align: center">desktop</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-animation-8.png)</td>
      <td style="text-align: center">![image](/images/vge-animation-9.png)</td>
    </tr>
  </tbody>
</table>

<h3 id="fix-1">fix</h3>
<p>다른 두 환경에서 undefined 된 상황의 문제가 벌어진 것으로 보여 디버깅 하면서 이상한 값이 변수에 들어있는지 확인하는 과정을 거쳤다.<br />
이 부분에서 원인을 찾는게 시간이 오래 걸렸던 것으로 기억하는데, 결국 문제는 다음과 같았다.</p>
<ul>
  <li>blender model을 사용하면서 문제가 생기기 시작해서 해당 model을 load한 직후 member 변수들을 살펴봤음.</li>
  <li>joint attribute 중 하나의 값에 4096이라는 수치가 들어있었는데, 이 값은 0x1000으로 joint의 index 값으로는 너무 큰 값이어서 이상했음.</li>
  <li><a href="https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#skinned-mesh-attributes">glTF specification</a>을 확인하던 중, joint component의 type이 두가지가 가능하다는 사실을 알게됨.</li>
  <li>buffer와 accessor 를 사용하는 방식으로 gltf format에서 load후 접근할텐데, 이 단위가 맞지 않아 joint에 적절치 않은 큰 값이 들어가는 상황이 가능하다고 분석함.</li>
  <li>기존 코드에서는 joint component가 unsigned-short인 경우만 구현이 되어 있었음.</li>
  <li>tinyGlTF 에서 load된 joint component type을 <code class="language-plaintext highlighter-rouge">jointAccessor.componentType</code> 통해 알 수 있는데, <code class="language-plaintext highlighter-rouge">TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE</code> 와 <code class="language-plaintext highlighter-rouge">TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT</code> 일때를 구분해서 처리해줌으로써 해결.</li>
</ul>

<p>여담으로 model 관련 살펴보다가 추가로 알게된 사실인데, blender에서 modeling을 한 후, glTF로 export하면 vertex 수가 바뀔 수 있다(주로 늘어난다). 이는 glTF에서는 모든 mesh가 triangulation 되어야해서 export 하는 과정에서 알아서 변환해주기 때문이라고 한다. reimport 하면 달라진 mesh를 확인할 수 있다.</p>

<h3 id="bone-length-and-orientation">bone length and orientation</h3>
<p>bone의 방향에 관해서는 위의 문제를 해결하니 바로 해결됐다.</p>
<ul>
  <li>기존 bone만 blender에서 export된 모델을 쓰고, fox model은 다운로드 받은 모델을 쓰고 있어서, 서로 axis가 달랐다.</li>
  <li>blender에서 export된 fox와 bone 모델을 사용하니 문제가 해결됐다.</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">:fixed fox, skeleton:</th>
      <th style="text-align: center"> </th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-animation-11.png)</td>
      <td style="text-align: center">![image](/images/vge-animation-12.png)</td>
      <td style="text-align: center">![image](/images/vge-animation-13.png)</td>
    </tr>
  </tbody>
</table>

<p>bone의 length는 실제로 glTF에 명시적으로 저장되는 값이 아니라고 한다. 이미 length 개념없이도 animation과 skinning을 표현하는데에는 문제가 없었으므로, 보조적인 개념이라 최적화를 위해 포함하지 않는 것으로 이해했다.</p>

<h3 id="bind-pose-or-empty-animation">bind pose or empty animation</h3>

<p>animation을 쓰지 않은 type은 animation index를 -1로 주어 아예 skinning을 적용하지 않도록 처리해서 구현했다.<br />
초기 joint matrix들에 들어 있는 값을 쓸 경우는 이상하게 뭉쳐진 skinning이 됐는데, 결국 이 초기 값은 bind pose와 관련있을 필요가 없다는 결론을 지었다. glTF specification에 이를 명시하지 않았기 때문이라고 이해했는데, 관련 검색 자료를 남겨놓겠다.</p>

<ul>
  <li><a href="https://github.com/KhronosGroup/glTF-Blender-IO/issues/360">https://github.com/KhronosGroup/glTF-Blender-IO/issues/360</a></li>
  <li><a href="https://github.com/mrdoob/three.js/issues/24772">https://github.com/mrdoob/three.js/issues/24772</a></li>
</ul>

<h3 id="performance">performance</h3>
<p>debugging mode로 build했을 때, 생각보다 너무 느린 400 fps 정도가 측정됐다.<br />
release mode로 build하니 4000 fps 가까이 측정이 돼서, validation layer나 optimization 관련 여부로 인해 차이가 큰 것을 확인했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">: dynamic UBO (color 적용 및 external animation) 추가한 최종 결과:</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-animation-14.png)</td>
      <td style="text-align: center">![image](/images/vge-animation-15.png)</td>
    </tr>
  </tbody>
</table>

<p>두 이미지 모두 중앙 좌측에 있는 정지한 fox model은 skeleton이 이상한 위치에 나오고 있다. 이 경우에는 joint matrices를 사용하지 않기때문에 skeleton도 의미가 없게 된다.<br />
animation을 사용하지 않는 경우는, <code class="language-plaintext highlighter-rouge">node::update()</code> 가 초기에만 호출되고 이후에는 animationUpdate에서 호출하지 않게되면서 node UBO가 변하지 않게 되는데, 이 초기 설정에서 그 skinned mesh를 가진 node의 transform의 inverse만 가지도록 해줬다. identity를 주는 것이 node hierarchy를 표현하기 위해서 맞을지도 모르겠는데, 아직 이런 예시의 gltf파일은 사용하지 않아서 이 방식으로 유지해놨다. 추후 필요시 수정하면 될 부분이다.</p>

<p><img src="/images/vge-animation-3.gif" alt="image" /></p>

<h1 id="마무리">마무리</h1>
<p>animation 관련 개념을 다루고 rendering 하는 기본적인 예제를 작성했다. skeletal-animation 기본 개념을 알고 나서야, 다른 여러 sw나 format에서 사용하는 animation 구조가 다른 것이 아니고 이 기본의 생략되거나 변형된 방식이라는 사실이 보이기 시작했다. 이런 기본 개념을 먼저 이해하는 것이 선행되어야 하는 이유를 다시 한번 느꼈다.</p>

<p>skinning 과 animation model을 loading해서 rendering하는 것에 추가로, skelton rendering 과 dynamic uniform buffer 사용의 내용을 추가했는데, 이런 단순한 변경으로도 구조를 계획하고 구현 중 문제를 해결하는데에는 꽤 긴 시간이 소요됐다. 특히 중간에 debugging 하는 과정에서 원본 glTF 예제에서 가져온 부분에서 내가 사용한 model을 커버하지 못하는 케이스가 여럿 발견됐는데, 단순히 code를 옮겨서 사용하기만 했다면 찾기 더 오래걸렸을 것이라는 생각을 했다.</p>

<p>그러면서 <a href="https://www.jeremyong.com/c++/vulkan/graphics/rendering/2018/03/26/how-to-learn-vulkan/">How to Learn Vulkan</a> 내용이 생각나서 다시 읽어 봤는데, 단순히 typing 할빠엔 copy-paste를 하는게 낫다고 하면서 중요한 건 개념을 익히는 것이기 때문에 세세한 구현에는 너무 신경을 쓰지 말라고 한다. 또 own renderer를 만들면서 더 적극적으로 안써본 기능들을 실험해보라고 하는데, 이런 방향성은 잘 가고 있다고 생각했다. 지금 보다 좀 더 적극적으로 안써본 것 들을 쓰면서 목표를 공격적으로 잡아도 좋겠다고 느꼈다.</p>

<p>앞으로도 비슷한 방식으로 예제들을 추가해 갈 텐데, 다음과 같은 점들을 유념해야겠다.</p>
<ul>
  <li>기반이 되는 기본 개념 숙지 - spec과 api 문서 자주 보기</li>
  <li>추가할 구조 및 변경점 계획 - 공격적으로 목표 설정
    <ul>
      <li>궁극적으로는 아예 참고할 원본 예제 없이 0에서부터 계획하기</li>
    </ul>
  </li>
  <li>참고한 코드가 추가/변경에 호환되는지 확인
    <ul>
      <li>모든 경우를 사전에 파악할 순 없으니, debugging에 익숙해지기</li>
    </ul>
  </li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[이전 예제에서 glTF모델 load와 관련 구조를 작성할 때, animation과 skinning관련된 부분들은 아직 쓰이지 않아 제외하고 구현했다. 이번 예제를 통해 해당 빈 부분들의 기능을 추가했다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vge-animation-16.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vge-animation-16.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Graphics Examples - Pipelines</title><link href="https://keechang-choi.github.io/study/study-vge-pipelines/" rel="alternate" type="text/html" title="Vulkan Graphics Examples - Pipelines" /><published>2023-07-25T00:00:00+09:00</published><updated>2023-07-25T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-vge-pipelines</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-vge-pipelines/"><![CDATA[<p>이번 예제는 pipelines 예제이다. 하나의 모델을 파일로부터 로드한 후, lighting rendering, toon rendering, wireframe rendering의 세가지를 위한 각각의 pipeline을 생성해서 화면을 분할하여 보여주는 예제이다.<br />
사실 pipeline 생성하는 작업에 대한 내용은 많지 않고, model loading을 위한 작업이 대부분을 차지했다.</p>

<blockquote>
  <p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/2">https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/2</a></p>
</blockquote>

<ul>
  <li><a href="#gltf">glTF</a>
    <ul>
      <li><a href="#model">model</a></li>
      <li><a href="#scene">scene</a></li>
      <li><a href="#node">node</a></li>
      <li><a href="#mesh">mesh</a></li>
      <li><a href="#primitive">primitive</a></li>
      <li><a href="#material">material</a></li>
      <li><a href="#texture">texture</a></li>
    </ul>
  </li>
  <li><a href="#loading-assets">Loading assets</a>
    <ul>
      <li><a href="#flags">flags</a></li>
      <li><a href="#texture-loading">texture loading</a></li>
      <li><a href="#materials-loading">materials loading</a></li>
      <li><a href="#nodes-loading">nodes loading</a></li>
    </ul>
  </li>
  <li><a href="#draw">draw</a>
    <ul>
      <li><a href="#pipelines">pipelines</a></li>
    </ul>
  </li>
  <li><a href="#todo">TODO</a></li>
</ul>

<hr />

<h1 id="gltf">glTF</h1>
<p>모델 loading과 관련된 내용을 먼저 작업했다. pipeline 구성을 위해선 어떤 종류의 data를 사용할지 (descriptorSetLayout)에 대한 정보가 필요했기 때문이다.</p>

<p>사용한 3d model format은 glTF 라는 format인데, KhronosGroup에서 개발한 loading괴 크기 효율에 중점을 맞춘 형식이다. 기본적인 개념은 다음 정보를 참고했다.</p>

<p><a href="https://www.khronos.org/files/gltf20-reference-guide.pdf">https://www.khronos.org/files/gltf20-reference-guide.pdf</a></p>

<p>해당 내용들은 <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/src/base/vgeu_gltf.cpp">vgeu_gltf.cpp</a>에 구현했다. 원본의 pipelines 예제에서는 glTF 기능들을 분리하지 않고 필요한 내용들울 포함하는데, glTF 예제에는 조금 더 확장된 기능을 분리된 코드로 정리해 나가면서 다룬다. 두 예제를 합친 내용을 여기서 한번에 구현했다고 봐도 된다.</p>

<h2 id="model">model</h2>
<ul>
  <li>외부에서 사용할 가장 큰 클래스다.
    <ul>
      <li>load와 draw method를 외부에서 호출하는 구조다.</li>
    </ul>
  </li>
  <li>node들을 전부 소유</li>
  <li>texture도 전부 소유</li>
  <li>material도 전부 소유</li>
  <li>animation등 필요한 모든 resource를 소유.</li>
  <li>하위 구조들에서도 서로 참조하거나 소유하는 구현이 많이 등장하는데, 다음 기준으로 구현했다.
    <ul>
      <li>우선적으로 기본 생성주기를 같이하는 member variable 형태가 가능하면 사용한다.</li>
      <li>소유하지만 lazy loading이 필요한 member는 unique_ptr을 사용한다.</li>
      <li>소유하지 않지만 null이 불가능한 경우는 reference로 참조한다.</li>
      <li>소유하지 않지만 null이 가능해야 하는 경우는 raw ptr로 참조한다.</li>
    </ul>
  </li>
</ul>

<h2 id="scene">scene</h2>
<ul>
  <li>여러 node를 가리킨다.</li>
  <li>node들은 Tree 구조로 구성된다.</li>
  <li>node를 load할 때 시작점으로서 사용된다.</li>
</ul>

<h2 id="node">node</h2>
<ul>
  <li>mesh를 소유</li>
  <li>skin은 소유하지 않고 참조한다.
    <ul>
      <li>아직 쓰이지 않음.</li>
    </ul>
  </li>
  <li>다른 node들을 children으로 소유해서 tree형태로 참조하는 구조를 가진다.
    <ul>
      <li>root node가 모든 node를 소유하게 되는데 이 root node는 실재하지 않고 model에서 parent가 없는 node 모두를 소유한다.</li>
      <li>이렇게 구성한 이유는, 상위 node가 destruct 될때, 하위 children도 모두 destruct 되는 구조를 위해서다. cycle이 있거나 DAG 구조이면 구현이 좀 복잡해질텐데, 다행히 tree여서 간단히 구현했다.</li>
    </ul>
  </li>
  <li>transform matrix정보를 가지고 있다. 이 transform은 parent를 기준으로 가져서 sceneGraph를 구성한다.</li>
  <li>node 구조는 mesh들 간의 관계나 skinning 등에 사용가능한 계층구조를 위한 abstraction으로 보면 될 것 같다.</li>
</ul>

<h2 id="mesh">mesh</h2>
<ul>
  <li>3d model의 mesh에 해당한다.</li>
  <li>여러 primitive를 vector로 소유</li>
  <li>ubo 소유
    <ul>
      <li>skinning을 위한 jointMatrice</li>
      <li>NodeTransformMatrix</li>
      <li>이를 위한 buffer와 descriptorSet소유</li>
    </ul>
  </li>
  <li>vertex/index buffer는 model에서 소유하고, mesh는 primitive를 통해 index 정보만 가지고 있다.
    <ul>
      <li>model의 모든 vertex는 하나의 buffer로 관리되고, 각 mesh는 offset으로 접근하도록 해서 효율을 높인 것으로 보인다.</li>
    </ul>
  </li>
</ul>

<h2 id="primitive">primitive</h2>
<ul>
  <li>vertex/index offset and count</li>
  <li>material을 참조한다.
    <ul>
      <li>소유는 model에서 소유한다.</li>
    </ul>
  </li>
  <li>dimension
    <ul>
      <li>모든 노드의 메쉬의 vertices의 좌표의 최대, 최소, center, radius 등의 값을 계산할 때 사용되는데, 아직 사용한 적은 없다.</li>
    </ul>
  </li>
</ul>

<h2 id="material">material</h2>
<ul>
  <li>여러 texture를 참조한다. color/normal/metalic/occlusion/emissive…
    <ul>
      <li>texture의 소유도 역시 model에 있다.</li>
    </ul>
  </li>
  <li>하나의 descriptorSet을 가진다.
    <ul>
      <li>여러 texture의 image들은 set의 각 binding으로 들어간다.</li>
    </ul>
  </li>
</ul>

<h2 id="texture">texture</h2>
<ul>
  <li>하나의 image 자원을 소유한다.
    <ul>
      <li>imageView를 image class에 추가해서 구현했다.</li>
      <li>view와 VkImage의 분리가 필요한 경우가 생기면 분리하려 하는데 아직 찾지는 못했다.</li>
      <li>mipmap 생성과 관련해서 view를 만들때 levelCount를 미리 알아야 하는 문제가 있었는데, 이 levelCount만 미리 지정해놓으면 이후 mip images의 내용은 변경해도 되는지 의문이 있었다.
        <ul>
          <li>이런 생각이 든 이유는 이전 tutorial에서는 image를 먼저 생성하면서 mipmap 생성을 다 한 후, image view를 만들었다면</li>
          <li>이번에는 image view를 image와 같이 먼저 생성해놓고, image mipmap을 생성하려니 순서의 문제가 없는지에 대한 의문이었다.</li>
          <li>결론적으로 문제는 없었다. image view가 image access를 위한 handle 개념이므로 접근 영역에 대한 정보와 이미지의 내부 내용은 서로 독립적인 개념으로 이해했고, 다음 <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageViewCreateInfo.html#VUID-VkImageViewCreateInfo-subresourceRange-01718">명세 부분</a>을 참고했다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>sampler를 소유한다.</li>
  <li>texture loader와 mipmap 생성을 위한 method를 가진다.</li>
</ul>

<p>그외의 skin과 animation 관련된 구조는 아직 구현하지 않고 TODO로 남겨놨다. 이후 예제에서 추가할 계획이다.</p>

<h1 id="loading-assets">Loading assets</h1>

<p>model class에서는 각 자원들을 glTF file로부터 loading한다. 이후 그 자원들의 사용에 필요한 buffer와 descriptor set 등을 생성하고 초기화한다.</p>

<h2 id="flags">flags</h2>

<p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/src/base/vgeu_flags.hpp">vgeu_flag.hpp</a></p>

<p>glTF 구현에도 여러 flag의 사용이 필요했는데, vulkan-hpp에 구현된 template 형식을 참고해서 작성했다. template programming 관련 참고한 내용도 남겨두겠다.</p>

<ul>
  <li><a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/vulkan/vulkan_enums.hpp">https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/vulkan/vulkan_enums.hpp</a></li>
  <li><a href="https://modoocode.com/295">https://modoocode.com/295</a>
    <ul>
      <li>SFINAE 라는 principle을 처음 알았는데, modern c++ 관련 기본적인 내용도 한번 정리할 필요성을 느꼈다.</li>
    </ul>
  </li>
</ul>

<h2 id="texture-loading">texture loading</h2>

<p>glTF 내장된 image loading으로 파일에서 읽어온 image를 생성하고 mipmap 생성을 하는 내용이다. 원본 예제에서는 KTX format을 권장해서 이에 대한 구현이 들어있는데, 여기서는 우선 glTF 내장 texture 사용만 구현했다.</p>

<p>mipmap 생성과 관련해서는 tutorial에서의 방식과 유사한데 같은 결과를 내는 조금 다른 layout transition의 방식이 원본에 구현되어 있어서, 두 방식을 비교할 겸 좀 더 정리해봤다.</p>

<p>두가지 비슷한 구조가 나와서 정리해두려한다.</p>
<ul>
  <li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceLayers.html">ImageSubresourceLayers</a>
    <ul>
      <li>buffer copy to image나 image blit에서 사용된다.</li>
      <li>blit에서는 src/dst를 나눠서 2개가 사용된다.</li>
      <li>여러 layer를, 고정된 mipLevel에 대해 지정한다.
        <ul>
          <li>layer가 여러개인 image는 다루지 않았는데, <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/texturecubemap/texturecubemap.cpp">cube map</a>이 대표적인 예시다. skybox 구현에도 사용된다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkImageSubresourceRange.html">ImageSubresourceRange</a>
    <ul>
      <li>pipeline barrier에서 image layout transition을 지정할 때 사용된다.
        <ul>
          <li>vgeu_utils.cpp에 구현된 <code class="language-plaintext highlighter-rouge">setImageLayout()</code> 내부에서 사용된다.</li>
        </ul>
      </li>
      <li>여러 layer와 더불어, 여러 mipLevels를 지정한다.
        <ul>
          <li>buffer copy to image 전의 transition에서 사용될때는 0~mipLevels 전부 범위를 사용하지만,</li>
          <li>mipmap generate에서의 transition에서는 , i번에서 1개씩 mipLevel 지정으로 사용한다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>이번에 구현할 방식에서는 mipmap generation은 흐름이 다음과 같다</p>

<ul>
  <li>create mipLevels-count image by staging buffer</li>
  <li>transition: undefined → transfer dst: base 0, <o>count 1</o></li>
  <li>CopybufferToImage: mipLevel 0</li>
  <li>
    <o>transition: transfer dst → transfer src : base 0, count 1</o>
  </li>
  <li>submit and flush(wait idle)</li>
  <li>mipmap generation for i in [1, mipLevels-1]
    <ul>
      <li>transition: <o>undefined → transfer dst: : base [i]</o>, count 1</li>
      <li>blitImage using [i-1] → [i]</li>
      <li>transition: <o>transfer dst → transfer src: base[i]</o>, count 1</li>
    </ul>
  </li>
  <li>transition: <o>transfer src  → shader read only:  base 0, count mipLevels</o></li>
</ul>

<style>
o { background-color: Orange }
</style>

<p>이전 tutorial 에서 구현했었던 mipmap generation은 다음과 같다.</p>
<blockquote>
  <p><a href="../study-Vulkan-mipmap-multisampling#generating-mipmaps-1">Recap</a></p>
</blockquote>

<ul>
  <li>create mipLevels-count image by staging buffer</li>
  <li>transition: undefined → transfer dst: base 0, count <o>mipLevels</o></li>
  <li>CopybufferToImage: mipLevel 0</li>
  <li>
    <o>transition 안함</o>
  </li>
  <li>submit and flush (wait idle)</li>
  <li>mipmap generation for i in [1, mipLevels-1]
    <ul>
      <li>transition: <o>transfer dst → transfer src  : base [i-1]</o>, count 1</li>
      <li>blitImage using [i-1] → [i]</li>
      <li>transition: <o>transfer src→ shader read only: base[i-1]</o>, count 1</li>
    </ul>
  </li>
  <li>transition: <o>transfer dst  → shader read only:  base [mipLevels-1], count 1</o></li>
</ul>

<p>차이를 정리해보면 다음과 같다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">step</th>
      <th style="text-align: center">this example transition</th>
      <th style="text-align: center">past tutorial transition</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">첫 buffer copy 이전</td>
      <td style="text-align: center">base mipLevel , undefined -&gt; dst</td>
      <td style="text-align: center">전체 levels, undefined -&gt; dst</td>
    </tr>
    <tr>
      <td style="text-align: center">copy 후 iteration 이전</td>
      <td style="text-align: center">base mipLevel , dst -&gt; src</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">mipmap iteration for i=1~mipLevels-1</td>
      <td style="text-align: center">[i] level, undefined -&gt; dst <br /> blit <br /> [i] level, dst -&gt; src</td>
      <td style="text-align: center">[i-1] level, dst -&gt; src <br /> blit <br /> [i-1] level, src -&gt; sharer read only</td>
    </tr>
    <tr>
      <td style="text-align: center">after iteration</td>
      <td style="text-align: center">전체 levels, src -&gt; shader read only</td>
      <td style="text-align: center">[mipLevels-1] level, dst -&gt; shader read only</td>
    </tr>
  </tbody>
</table>

<p>최종 layout 들의 결과는 동일하다. 과정에서의 차이가 있긴한데, 성능상 비교는 하지 못했다.<br />
과거 tutorial에서의 방식이 command가 하나 적긴하다. 마지막 레벨의 변환은 src layout으로의 변환이 필요없어서 그 중간단계가 차이.</p>

<h2 id="materials-loading">materials loading</h2>
<ul>
  <li>glTF material에 있는 texture index를 통해 load된 texture의 raw ptr을 const로 참조한다.</li>
  <li>여러 종류의 texture중 있는 것들만 확인하여 전부 가져온다.</li>
  <li>새로 생성된 material들은 model에서 vector로 소유해서 관리한다.</li>
</ul>

<h2 id="nodes-loading">nodes loading</h2>
<ul>
  <li>node는 tree 구조를 위해 recursive하게 loading 된다.
    <ul>
      <li>한 node를 load하면 새로운 newNode를 local에서 unique_ptr로 생성한다.</li>
      <li>child 정보를 recursive하게 모두 생성한다. 이때 parent로 newNode의 raw ptr을 전달한다.</li>
      <li>mesh가 있는 node는 make_unique로 생성해서 소유한다.</li>
      <li>그 mesh의 primitives 정보도 make_unique_를 통해 소유하도록 생성한다.</li>
      <li>완료되면, newNode의 raw ptr은 model class의 멤버인 linearNodes에 저장한다.</li>
      <li>그 newNode가 parent가 있으면 parent의 children에 move로 소유권을 넘겨 추가한다.</li>
      <li>그 newNode가 parent가 없으면 model class의 멤버인 nodes에 move로 소유권을 넘겨 추가한다.</li>
    </ul>
  </li>
  <li>결과적으로 linearNodes는 모든 node를 소유없이 참조하고,</li>
  <li>nodes는 root node들만 소유하게 된다.</li>
  <li>그리고 각 node는 그 node의 childeren들을 모두 소유한다.</li>
</ul>

<h1 id="draw">draw</h1>
<ul>
  <li>model의 <code class="language-plaintext highlighter-rouge">draw()</code>는 모든 nodes를 돌면서 <code class="language-plaintext highlighter-rouge">drawNode()</code>를 호출해서 draw commands를 recording 한다.</li>
  <li><code class="language-plaintext highlighter-rouge">drawNode()</code>는 tree traversal을 위해서 recursive하게 recording 된다.</li>
  <li><code class="language-plaintext highlighter-rouge">drawNode()</code> 내부에서는
    <ul>
      <li>그 node가 소유한 mesh의 primitives를 돌면서 <code class="language-plaintext highlighter-rouge">vkCmdDrawIndexed()</code>를 호출한다. primitive의 index count와 first index가 사용된다.</li>
      <li>이때 texture 가 필요시, primitive가 참조한 material을 통해 bind DescriptorSets을 호출한다.</li>
    </ul>
  </li>
</ul>

<h2 id="pipelines">pipelines</h2>
<p>최종 결과를 확인하기 위해서, 세개의 pipeline과 그에 해당하는 shader를 작성한다.</p>

<ul>
  <li>phong
    <ul>
      <li>기본이 되는 pipeline이고, allow derivative flag를 통해 아래 두 pipeline 생성의 base가 되어 효율을 높인다.</li>
      <li><a href="https://registry.khronos.org/vulkan/specs/1.3/html/chap10.html#pipelines-pipeline-derivatives">https://registry.khronos.org/vulkan/specs/1.3/html/chap10.html#pipelines-pipeline-derivatives</a></li>
      <li>shader는 blinn-phong lighting으로 구현했다.</li>
      <li>
        <div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec3</span> <span class="n">color</span> <span class="o">=</span> <span class="kt">vec3</span><span class="p">(</span><span class="n">texture</span><span class="p">(</span><span class="n">samplerColorMap</span><span class="p">,</span> <span class="n">inUV</span><span class="p">));</span>

<span class="c1">// High ambient colors because mesh materials are pretty dark</span>
<span class="kt">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">color</span> <span class="o">*</span> <span class="nf">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">3</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">inNormal</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">L</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">inLightVec</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">V</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">inViewVec</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">R</span> <span class="o">=</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">L</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">halfAngle</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">L</span> <span class="o">+</span> <span class="n">V</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">color</span><span class="p">;</span>
<span class="c1">// vec3 specular = pow(max(dot(R, V), 0.0), 64.0) * vec3(0.35);</span>
<span class="kt">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">halfAngle</span><span class="p">,</span> <span class="n">N</span><span class="p">),</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">),</span> <span class="mi">64</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="nf">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">35</span><span class="p">);</span>
<span class="n">outFragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">ambient</span> <span class="o">+</span> <span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>	
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>toon
    <ul>
      <li>base pipeline과 다를게 없다. viewport의 경우 dynamic state로 지정했기 때문에, command buffer recording에서 변경해줄 수 있다.</li>
      <li>shader는 다음과 같이 밝기 단계가 discrete 되도록 지정했다.</li>
      <li>
        <div class="language-glsl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">vec3</span> <span class="n">N</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">inNormal</span><span class="p">);</span>
<span class="kt">vec3</span> <span class="n">L</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">inLightVec</span><span class="p">);</span>

<span class="kt">float</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">);</span>
<span class="kt">float</span> <span class="n">shade</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
<span class="n">shade</span> <span class="o">=</span> <span class="n">intensity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">80</span> <span class="o">?</span> <span class="mi">0</span><span class="p">.</span><span class="mi">9</span> <span class="o">:</span> <span class="n">shade</span><span class="p">;</span>
<span class="n">shade</span> <span class="o">=</span> <span class="n">intensity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">65</span> <span class="o">?</span> <span class="mi">0</span><span class="p">.</span><span class="mi">75</span> <span class="o">:</span> <span class="n">shade</span><span class="p">;</span>
<span class="n">shade</span> <span class="o">=</span> <span class="n">intensity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">35</span> <span class="o">?</span> <span class="mi">0</span><span class="p">.</span><span class="mi">45</span> <span class="o">:</span> <span class="n">shade</span><span class="p">;</span>
<span class="n">shade</span> <span class="o">=</span> <span class="n">intensity</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span> <span class="o">?</span> <span class="mi">0</span><span class="p">.</span><span class="mi">15</span> <span class="o">:</span> <span class="n">shade</span><span class="p">;</span>

<span class="n">outFragColor</span> <span class="o">=</span> <span class="kt">vec4</span><span class="p">(</span><span class="n">inColor</span><span class="o">*</span><span class="n">shade</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>	
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>wireframe
    <ul>
      <li>rasterization state 의 polygon mode를 line으로 지정한다.</li>
    </ul>
  </li>
</ul>

<p>이 세가지의 pipeline을 <code class="language-plaintext highlighter-rouge">buildCommandBuffers()</code>에서 bindPipeline을 통해서 바꿔가며 각각의 draw와 호출하면 모든 로직의 구성이 완료된다.
이때 서로 화면 분할된 결과를 위해서, <code class="language-plaintext highlighter-rouge">setViewPort()</code>를 서로 다른 영역이 되도록 3분할 해주면 된다.</p>

<p>이전부터 써오던 사과모델의 glTF format을 추가해서 다음과 같은 결과를 얻었다.
<img src="/images/vge-pipelines-3.gif" alt="image" /></p>

<h1 id="todo">TODO</h1>
<p>현재 구현된 glTF는 pipelines 예제 구현에 필요한 것들 위주로만 작성해서 남겨둔 부분이 있다.</p>

<ul>
  <li>texture
    <ul>
      <li>base color texture 만 사용했는데, normal texture 및 다른 다양한 texture를 가진 material의 모델 추가.</li>
    </ul>
  </li>
  <li>node hierarchy
    <ul>
      <li>사용한 사과 모델이 단일 mesh여서, 이를 테스트 할 수 있는 계층구조 node의 glTF 파일 추가.</li>
    </ul>
  </li>
  <li>animation
    <ul>
      <li>animation과 skinning에 해당하는 부분은 미구현했으므로 추가 구현.</li>
    </ul>
  </li>
</ul>

<p>다양한 glTF-sample은 다음 repo에서 얻을 수 있는데 저작권에 주의해야한다.<br />
<a href="https://github.com/KhronosGroup/glTF-Sample-Models">https://github.com/KhronosGroup/glTF-Sample-Models</a></p>

<p>참고로 해당 프로젝트에서 사용하는 모든 asset의 정보와 cc license는 <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/tree/main/assets">/assets</a> 위치에 들어있다.</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[이번 예제는 pipelines 예제이다. 하나의 모델을 파일로부터 로드한 후, lighting rendering, toon rendering, wireframe rendering의 세가지를 위한 각각의 pipeline을 생성해서 화면을 분할하여 보여주는 예제이다. 사실 pipeline 생성하는 작업에 대한 내용은 많지 않고, model loading을 위한 작업이 대부분을 차지했다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vge-pipelines-1.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vge-pipelines-1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Graphics Examples - Base</title><link href="https://keechang-choi.github.io/study/study-vge-base/" rel="alternate" type="text/html" title="Vulkan Graphics Examples - Base" /><published>2023-07-15T00:00:00+09:00</published><updated>2023-07-15T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-vge-base</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-vge-base/"><![CDATA[<p>이전 글에서 적은대로, vulkan tutorial에 대한 학습을 마치고, 예제 구현 중심의 학습 방향으로 전환을 했다.<br />
들어가기 전에, 어떤 내용들을 다룰 것인지와 repo 구성 환경에 대해서 정리해 놓으려 한다.<br />
그 후, 예제 코드 구조의 기본이 되는 base 구조에 대한 작업 내용과 첫번째 예제인 triangle rendering 예제 구현까지의 내용을 다루겠다.</p>

<ul>
  <li><a href="#whats-next">What’s next?</a>
    <ul>
      <li><a href="#cloth-simulation">Cloth simulation</a></li>
      <li><a href="#pbd---position-based-dynamics">PBD - Position Based Dynamics</a></li>
      <li><a href="#계획">계획</a></li>
    </ul>
  </li>
  <li><a href="#vge-repo-구성">VGE repo 구성</a></li>
  <li><a href="#vge---base">VGE - base</a>
    <ul>
      <li><a href="#initvulkan">initVulkan</a></li>
      <li><a href="#prepare">prepare</a></li>
      <li><a href="#renderloop">renderLoop</a></li>
      <li><a href="#triangle">triangle</a></li>
      <li><a href="#interface">Interface</a>
        <ul>
          <li><a href="#imgui">imGui</a></li>
          <li><a href="#cli11">CLI11</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a>
    <ul>
      <li><a href="#readings">readings</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="whats-next">What’s next?</h1>
<blockquote>
  <p><a href="https://github.com/SaschaWillems/Vulkan">https://github.com/SaschaWillems/Vulkan</a></p>
</blockquote>

<p>이 레포에 있는 여러 예제들을 실행시켜보고, 코드 구조를 훑어보면서, 앞으로 뭘 할지에 대해 생각해봤다. 예제 종류는 기본적인 내용과 glTF 모델, PBD, ray-tracing 등 다양한 주제가 있어서 처음부터 이 모든걸 공부하겠다고 잡으면 너무 주제가 넓어질 것 같아 우선 하나의 목적성을 두고 단계를 밟아가면서 살펴보려한다.<br />
그 중 마지막 tutorial 내용과 연결되기도 하고, 실행시켜봤을 때 흥미롭다고 느낀 내용이 compute shader와 simulation 부분이어서 해당 주제로 방향을 잡고 진행하기로 결정했다.</p>

<h2 id="cloth-simulation">Cloth simulation</h2>
<p><a href="https://www.youtube.com/watch?v=kCGHXlLR3l8">(1) Unite 2016 - GPU Accelerated High Resolution Cloth Simulation - YouTube</a><br />
cloth simulation과 관련된 내용을 더 찾아보다가, Jim Hugunin 이라는 사람이 Unity 2016에서 발표한 영상을 보게 됐다.<br />
unity와 compute shader, real-time high resolution cloth simulation을 주제로한 발표인데, 내용을 정리하면 다음과 같다.</p>
<ul>
  <li>당시 unity 내장 cloth simulation 내용은 cpu based 계산이기도 하고, resolution 관련 문제가 있었다.
    <ul>
      <li>빠른 속도로 움직이는 물체와의 상호작용이 제대로 안됐음. fps 관련 한계로 인해서.</li>
    </ul>
  </li>
  <li>당시  Flex의 PhysX 에서 만든 엔진에서는 cloth simulation 이 GPU base로 동작했지만, Nvidia와 c++ 기반으로 구현돼어서 Unity C#에서 적용하면 최적화 문제가 있었다.
    <ul>
      <li>결국 Flex의 물리엔진은 더 일반적인 물리 엔진이라 Cloth 특화된 engine을 자체 개발해서 좋은 성능을 냈다.</li>
    </ul>
  </li>
  <li>demo 영상을 시연하며 영상이 마무리된다.
    <ul>
      <li>관련해서 release한 프로그램도 있는 것 같은데, 유지 및 개발이 진행되고 있는 지는 모르겠다. <a href="https://artfulphysics.com/">https://artfulphysics.com/</a></li>
    </ul>
  </li>
</ul>

<h2 id="pbd---position-based-dynamics">PBD - Position Based Dynamics</h2>
<p>simulation 관련해서 검색해보던 중 다음의 사이트를 찾았다.</p>
<blockquote>
  <p><a href="https://matthias-research.github.io/pages/tenMinutePhysics/index.html">https://matthias-research.github.io/pages/tenMinutePhysics/index.html</a></p>
</blockquote>

<p>사이트 안에는, 논문과 유튜브 영상, lecture 자료, web simulation 등 볼 자료가 상당히 많았는데, 주로 Postion-Based Dynamics 라는 시뮬레이션 method에 눈이 갔다.<br />
아직 내용을 많이 살펴보진 않았는데, 간단하게 말하면 기존의 acceleration과 velocity등의 값들을 기반으로 한 Newton dynamics에서 벗어나서, position과 constraint를 기반으로 한 계산 방식을 사용하면, 여러 물리 현상을 좋은 효율로 계산하고 시뮬레이션 하기 적합하다는 내용으로 이해했다.</p>

<p>tutorial 16에 해당하는 내용에서는, python + OpenGL + warp (Nvidia python GPU computation framework) 를 사용해서 해당 PBD의 기법이 GPU에서 계산하기에도 적합하다는 내용이 들어있다. 앞으로 주제 하나씩을 정해서 학습을 병행해서 Vulkan compute shader에대한 내용의 숙련도가 올라갔을 때, 작업을 시작하면 좋겠다고 생각했다.</p>

<h2 id="계획">계획</h2>

<ul>
  <li>tutorial 내용 반영 및 example 예제들 추가
    <ul>
      <li>base, triangle</li>
      <li>pipelines, glTF model loading</li>
      <li>animation, skinning</li>
      <li>compute shader</li>
    </ul>
  </li>
  <li>PBD 적용
    <ul>
      <li>cloth simulation</li>
      <li>혹은 흥미로워 보이는 simulation등</li>
      <li><a href="https://www.youtube.com/watch?v=MgmXJnR62uA">https://www.youtube.com/watch?v=MgmXJnR62uA</a></li>
      <li><a href="https://www.youtube.com/watch?v=GjbcvqEOIuE">https://www.youtube.com/watch?v=GjbcvqEOIuE</a></li>
    </ul>
  </li>
</ul>

<h1 id="vge-repo-구성">VGE repo 구성</h1>
<blockquote>
  <p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example">https://github.com/keechang-choi/Vulkan-Graphics-Example</a></p>
</blockquote>

<p>이전에 LVE와 tutorial을 공부할때는, desktop에 환경을 구성해놓고, wsl2 환경도 구성해서 ubuntu 환경에서 테스트도 할 겸 remote로도 실행했었는데, laptop으로도 내장 gpu를 사용하는게 성능이 더 좋아서 따로 환경구성부터 시작하기로 했다.</p>
<ul>
  <li>lunarG에서 windows vulkan intall
    <ul>
      <li>환경변수 등록, VK_SDK_PATH 확인</li>
    </ul>
  </li>
  <li>glm, glfw 등 lib 설치 -&gt; github submodule 활용으로 대체</li>
  <li>cmake install</li>
  <li>mingw C++ compiler install
    <ul>
      <li>visual studio 기반으로 작성하는게 windows에서 더 자주 보이긴 하는데, 향후 다른 platform 지원까지 고려하면 CLI 방식으로 컴파일하고 실행하는게 더 편해서 이렇게 하기로 했다.</li>
      <li>환경변수 MINGW_PATH 등록, Path에 bin 경로 추가</li>
    </ul>
  </li>
  <li>cmake, subdir build 구조 구성
    <ul>
      <li>third-party 관리</li>
      <li>glfw</li>
      <li>glm</li>
      <li>vulkan-hpp</li>
      <li>imgui</li>
    </ul>
  </li>
</ul>

<h1 id="vge---base">VGE - base</h1>
<p>가정 먼저 여러 example 예제들의 공통 내용이 될 base를 작성하고, 첫 예제인 trinagle rendering을 작성하면서 정리한 내용이다.</p>

<p><a href="https://github.com/SaschaWillems/Vulkan/blob/master/base/vulkanexamplebase.h#L511-L521">원본 base의 main부분</a><br />
를 참고하면 가장 먼저 main에서 실행되는 구조를 알 수 있는데,</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>													    
<span class="p">{</span>																									
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">VulkanExample</span><span class="o">::</span><span class="n">args</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="p">};</span>  				
	<span class="n">vulkanExample</span> <span class="o">=</span> <span class="k">new</span> <span class="n">VulkanExample</span><span class="p">();</span>															
	<span class="n">vulkanExample</span><span class="o">-&gt;</span><span class="n">initVulkan</span><span class="p">();</span>																	
	<span class="n">vulkanExample</span><span class="o">-&gt;</span><span class="n">setupWindow</span><span class="p">();</span>					 												
	<span class="n">vulkanExample</span><span class="o">-&gt;</span><span class="n">prepare</span><span class="p">();</span>																		
	<span class="n">vulkanExample</span><span class="o">-&gt;</span><span class="n">renderLoop</span><span class="p">();</span>																	
	<span class="k">delete</span><span class="p">(</span><span class="n">vulkanExample</span><span class="p">);</span>																			
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>																						
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/ui-overlay/src/base/vge_base.hpp#L134-L149">구현한 base의 main부분</a> 나는 조금 다른 구조로 작성했다.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>            
    <span class="n">vge</span><span class="o">::</span><span class="n">VgeExample</span> <span class="n">vgeExample</span><span class="p">{};</span>           
    <span class="n">CLI</span><span class="o">::</span><span class="n">App</span> <span class="n">app</span><span class="p">;</span>                           
    <span class="n">vgeExample</span><span class="p">.</span><span class="n">setupCommandLineParser</span><span class="p">(</span><span class="n">app</span><span class="p">);</span> 
    <span class="n">CLI11_PARSE</span><span class="p">(</span><span class="n">app</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>           
    <span class="n">vgeExample</span><span class="p">.</span><span class="n">initVulkan</span><span class="p">();</span>                
    <span class="n">vgeExample</span><span class="p">.</span><span class="n">prepare</span><span class="p">();</span>                   
    <span class="n">vgeExample</span><span class="p">.</span><span class="n">renderLoop</span><span class="p">();</span>                
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>       
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>     
    <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>                    
  <span class="p">}</span>                                         
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>   
</code></pre></div></div>

<ul>
  <li>이 main은 macro로 선언되어있는데, examples에서 각자 호출해서 서로 독립된 실행파일을 만드는데 사용된다.
    <ul>
      <li>example class가 base를 상속하기 때문에, 더 나은 구조로 작성할 수 있을 것 같은데 우선은 동일한 구조로 갔다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">setupWindow()</code> method 대신, window class의 unique_ptr을 통한 instance 생성으로 window 관련 처리를 했다. 원본 구조에서는 여러 OS를 지원하기때문에 window 설정이 모두 달라서 저런식으로 macro 사용을 통한 복잡한 구조가 되어 있는데, 나는 glfw를 사용한 windows OS에서의 window 생성만 구현했으므로 좀 더 간단하게 구조를 가져갔다.</li>
  <li><code class="language-plaintext highlighter-rouge">initVulkan()</code> 에서는 기본적으로 Vulkan 사용을 위한, Vulkan instance나 physical device 관련 설정을 관리한다.</li>
  <li><code class="language-plaintext highlighter-rouge">prepare()</code> 에서는 사용할 자원들에 대한 생성 및 초기화를 수행한다.</li>
  <li><code class="language-plaintext highlighter-rouge">renderLoop()</code> 에서는 실제로 rendering loop를 구현하고, 이벤트 처리나 FPS 측정 등 로직이 구성된다.</li>
</ul>

<h2 id="initvulkan">initVulkan</h2>

<p>window 생성에 대한 내용이 추가된 것을 제외하면 대부분 원본과 동일하다. 전체적으로 vulkan-hpp wrapper를 쓸 것이므로 다음을 참고해서 작성했다.<br />
RAII 관련 기능들을 사용했는데, (원본과 비교했을 때, 메모리 해제 관련된 코드들을 신경 쓰지 않아도 돼서 훨씬 수월했다.) 사실 window 생성등이나 여러 자원 생성 부분에서 lazy loading과 관련된 목적에도 많이 사용을 해서 RAII라는 이름과 좀 뜻이 맞지 않는 부분도 있는 것 같긴 했다. vulkan-hpp의 raii wrapper에서도 이런식의 초기 값은 nullptr로 줘서 아예 생성을 하지 않고 lazy loading에 쓰는 부분이 많이 있다.</p>

<ul>
  <li><a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/RAII_Samples/utils/utils.hpp">Vulkan-Hpp/RAII_Samples/utils/utils.hpp at main · KhronosGroup/Vulkan-Hpp · GitHub</a></li>
  <li><a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/samples/utils/utils.hpp">Vulkan-Hpp/samples/utils/utils.hpp at main · KhronosGroup/Vulkan-Hpp · GitHub</a></li>
  <li><a href="https://github.com/KhronosGroup/Vulkan-Hpp/blob/main/samples/utils/utils.cpp">Vulkan-Hpp/samples/utils/utils.cpp at main · KhronosGroup/Vulkan-Hpp · GitHub</a></li>
</ul>

<p>이 함수는 virtual 로 선언돼서, base 하위의 example class의 <code class="language-plaintext highlighter-rouge">initVulkan()</code> 내부에서 호출된다. base에 포함된 내용들은 다음과 같다.</p>
<ul>
  <li>VkInstance 생성</li>
  <li>debug messenger 설정</li>
  <li>physical device 생성</li>
  <li>queue family properties 설정</li>
  <li>logical device 생성</li>
  <li>queue 생성</li>
  <li>commandPool 생성</li>
  <li>depth format 설정</li>
  <li>window surface 생성</li>
  <li>VMA allocator 생성
    <ul>
      <li>VMA를 써서 buffer와 image 생성 wrapper를 생성했는데, 관련 정보는 다음에서 얻을 수 있다.<br />
  <a href="https://gpuopen-librariesandsdks.github.io/VulkanMemoryAllocator/html/usage_patterns.html">https://gpuopen-librariesandsdks.github.io/VulkanMemoryAllocator/html/usage_patterns.html</a></li>
      <li>구현한 내용은 따로 <a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/src/base/vgeu_buffer.cpp">vgeu_buffer.cpp</a>에 들어있다.</li>
    </ul>
  </li>
</ul>

<p>또한 이 함수 내부에서 사용하는 여러 기능들은 util로 빼서 따로 구현했다.<br />
<a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/blob/main/src/base/vgeu_utils.cpp">vgeu_utils.cpp</a></p>

<h2 id="prepare">prepare</h2>
<p>이 함수역시 virtual 로 선언돼서, base 하위의 example class의 <code class="language-plaintext highlighter-rouge">prepare()</code> 내부에서 호출된다. base에 포함된 내용은 다음과 같다.</p>
<ul>
  <li>swapChain 생성</li>
  <li>frameBuffer 와 관련 자원 생성</li>
  <li>renderPass 생성</li>
  <li>commandPool 생성</li>
  <li>draw command buffer 생성</li>
  <li>draw semaphores와 fences 생성</li>
  <li>ui overlay 생성</li>
</ul>

<h2 id="renderloop">renderLoop</h2>

<ul>
  <li>camera transform에 대한 및 update</li>
  <li>render loop
    <ul>
      <li>window의 종료 버튼에 대한 처리</li>
      <li><code class="language-plaintext highlighter-rouge">glfwPollEvents()</code></li>
      <li>view change update</li>
      <li>Mouse input 처리</li>
      <li>ui overlay update</li>
      <li><code class="language-plaintext highlighter-rouge">render()</code> 함수 호출
        <ul>
          <li>pure virtual로 선언된 이함수는 하위 class인 example에서 각각 구현된다.</li>
          <li>각 예제에서 들어가는 기본적인 내용은 다음과 같다.
            <ul>
              <li>UBO 업데이트</li>
              <li><code class="language-plaintext highlighter-rouge">draw()</code> 호출</li>
              <li>draw에는 synchronization primitive 사용과, <code class="language-plaintext highlighter-rouge">prepareFrame()</code>, <code class="language-plaintext highlighter-rouge">buildCommandBuffers()</code>, command buffer submit, <code class="language-plaintext highlighter-rouge">submitFrame()</code> 호출 등이 들어가게 된다.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">prepareFrame()</code>, <code class="language-plaintext highlighter-rouge">submitFrame()</code>은 공통된 내용으로 base에서 구현했는데,
        <ul>
          <li>swapchain image 얻어오기와, present queue 제출 등의 내용과 <code class="language-plaintext highlighter-rouge">windowResize()</code> 및 그에따른 swapchain recreate 의 내용이 들어간다.</li>
        </ul>
      </li>
      <li>FPS 측정 및 update에 사용될 timer count</li>
    </ul>
  </li>
  <li>render loop 종료시 device wait idle 호출</li>
</ul>

<h2 id="triangle">triangle</h2>

<p>기존의 example repo 원본에서도, triangle 예시는 제일 처음으로 나온다. 차이점은, 원본에서는 첫 예제인 만큼 구현된 wrapper 들을 쓰지 않고 모든 코드를 triangle 예제에 설명과 함께 넣어놨지만, 나는 이미 구현해본 내용인 만큼 최대한 구현된 wrapper들을 활용하는 방식으로 작성했다.<br />
또 원본의 모든 예제에 해당되는 내용인데, single buffering만을 사용한 구현이 되어있어서 한번 queue에 제출한 내용은 모두 wait idle을 통해 기다리는 간단한 구조이다. 나는 double buffering 지원을 계속 할 수 있는 방식으로 구현하려고 하고, 이와 관련한 synchronization primitives 사용등의 부분에서 조금 변경을 했다.</p>
<ul>
  <li>기본적으로 이 <a href="https://github.com/SaschaWillems/Vulkan/issues/871">issue</a>에서 밝힌 것과 같이 이 원본 example repo는 기능 구현에 초점을 맞춰서 성능이나 synchronization 관련 최적화는 이뤄져있지 않다.</li>
  <li>대부분 확인한 예제들에서 한 frame이 끝날때마다(command를 제출한 직 후) 바로 waitIdle을 통해서 queue에 제출된 command 들이 모두 실행을 완료할 때 까지 기다린다. 따라서 race condition이 발생할 경우를 줄인 간단한 구현들이 가능하다.</li>
  <li>그래서 이전 tutorial에서와 마찬가지로, swapchain 이미지 수와 <code class="language-plaintext highlighter-rouge">MAX_FRAMES_IN_FLIGHT</code>(<code class="language-plaintext highlighter-rouge">MAX_CONCURRENT_FRAMES</code>) 값을 분리된 것으로 설정하고, 관련된 자원들도 <code class="language-plaintext highlighter-rouge">MAX_FRAMES_IN_FLIGHT</code> 값에 따라 복수개로 생성했다.</li>
</ul>

<p>구현하면서 camera의 view matrix와 projection maxtrix 계산을 직접 하던 것에서, glm을 사용하는 방식으로 변경했다.<br />
처음에는 <code class="language-plaintext highlighter-rouge">glm::lookAt()</code>, <code class="language-plaintext highlighter-rouge">glm::perspective()</code>을 바로 호출해서 사용했는데, 의도와 다른 방향의 결과가 나왔다. 관련해서 내부 구현을 살펴보면서 left/right-handed system과 NDC 개념 등 헷갈렸던 것 들을 정리했다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">correct</th>
      <th style="text-align: center">wrong</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vge-base-2.png)</td>
      <td style="text-align: center">![image](/images/vge-base-3.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vge-base-4.png)</td>
      <td style="text-align: center">![image](/images/vge-base-5.png)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>자료 출처
    <ul>
      <li><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></li>
      <li><a href="http://anki3d.org/vulkan-coordinate-system/">http://anki3d.org/vulkan-coordinate-system/</a></li>
      <li><a href="https://stackoverflow.com/questions/68508935/vulkan-default-coord-system-for-vertex-positions">Vulkan default coord system for vertex positions - Stack Overflow</a></li>
      <li><a href="https://stackoverflow.com/questions/21841598/when-does-the-transition-from-clip-space-to-screen-coordinates-happen">https://stackoverflow.com/questions/21841598/when-does-the-transition-from-clip-space-to-screen-coordinates-happen</a></li>
      <li><a href="https://learnopengl.com/Getting-started/Coordinate-Systems">https://learnopengl.com/Getting-started/Coordinate-Systems</a></li>
    </ul>
  </li>
  <li>내용
    <ul>
      <li>결과적으로 호출한 함수들은 <code class="language-plaintext highlighter-rouge">glm::lookAtLH()</code>, <code class="language-plaintext highlighter-rouge">glm::perspectiveLH_ZO()</code> 이다.
        <ul>
          <li>left-handed와 depth zero-to-one 에 해당하는 함수들이다.</li>
        </ul>
      </li>
      <li>흔히 Vulkan에서는 right-handed coordinates, OpenGL에서는 left-handed coordinates라고 하는데 이게 정확이 어떤 개념일까?
        <ul>
          <li>이 left or right의 기준은 NDC(Normalized Device Coordinate) 인데, NDC space는 다음과 같은 space transformation의 단계에서 나타나는 좌표계다.
            <ul>
              <li>local(or objects) space -&gt; model matrix</li>
              <li>world space -&gt; view matrix</li>
              <li>view(or eye, camera) spcae -&gt; projection matrix</li>
              <li>clip space -&gt; perspective division</li>
              <li>NDC space -&gt; viewport transform
                <ul>
                  <li>rasterization stage에서 일어나고, 이 normalized  된 좌표계를 벗어난 값들은 screen에 들어가지 않게 되면서 clipping이 일어난다.</li>
                </ul>
              </li>
              <li>screen space</li>
            </ul>
          </li>
          <li>결론적으로, 이 left or right 의 개념은 API의 내부 NDC 기준이기때문에, 내가 view matrix와 projection matrix를 설정할때 필요한 world coordinate은 내 맘대로 정할 수 있고, 그에 맞는 변환을 지정해주면 되는 것이다.</li>
        </ul>
      </li>
      <li>glm 함수들의 이름이 Left/Right Handed인 이유는, 조금 misleading 할 수 있는데, +x와 +y 방향이 right, up인 기준에서 +z 방향이 forward인지, backward인지에 따라서 함수명을 정해서 라고 한다. 그래서 계산 상 실질적인 효과는 +z가 forward인지 backward인지로 matrix가 달라지는데 이때문에 우리는 +z가 forward 이기 때문에, left handed 함수를 쓰면 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="interface">Interface</h2>
<p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/1">https://github.com/keechang-choi/Vulkan-Graphics-Example/pull/1</a><br />
화면에 text를 표시하거나, user interface를 위해서 Dear ImGuI라는 library를 사용했다. 여러 Graphics API와의 사용을 지원하고 간단하게 쓸 수 있는 장점이 있어보였다.
command line argument 는 따로 직접 구현하지 않고, CLI11 이라는 library를 추가했다.</p>

<h3 id="imgui">imGui</h3>
<p>ImGui는 <code class="language-plaintext highlighter-rouge">bloat-free graphical user interface library for C++</code> 이라고 소개하는데,</p>

<p>imGui vulkan example 을 참고해서 사용했다.</p>
<blockquote>
  <p><a href="https://github.com/ocornut/imgui/blob/master/examples/example_glfw_vulkan/main.cpp">https://github.com/ocornut/imgui/blob/master/examples/example_glfw_vulkan/main.cpp</a></p>
</blockquote>

<p>imGUI 사용은 다음 guide를 참고했다.</p>
<blockquote>
  <p><a href="https://vkguide.dev/docs/extra-chapter/implementing_imgui/">https://vkguide.dev/docs/extra-chapter/implementing_imgui/</a></p>
</blockquote>

<p>원본에서는 imgui에서 제공되는 backends기능들을 직접 구현해서 쓰는데(cross-platform 환경을 위해서로 보임), 나는 <a href="https://github.com/ocornut/imgui/blob/master/backends/imgui_impl_glfw.cpp">imgui_impl_glfw backends</a> 의 기능들만 사용했다.</p>

<p><img src="/images/vge-base-1.png" alt="image" /><br />
좌측 GUI에 띄워논 내용은 demo로 제공되는 내용인데, 모든 기능의 예시를 볼 수 있는 demo 여서 실행시켜보면서 필요한 기능들은 추후 추가하는 식으로 진행했다.</p>

<h3 id="cli11">CLI11</h3>
<p><a href="https://github.com/CLIUtils/CLI11">CLI11</a> 이라는 command line parser를 사용했다. 간단한 것들은 직접 문자열 처리를 해서 구현할 수 있을텐데 (실제로 원본의 방식), 최대한 기존 third-party들을 활용하기로 계획한 만큼, 이 library를 사용했다. 써보니 실제로 간단하고 직관적이어서 편했다.</p>

<p>CLI11 examples를 보고 사용예시에 맞는 내용들을 참고했다.</p>
<blockquote>
  <p><a href="https://cliutils.github.io/CLI11/book/chapters/flags.html">https://cliutils.github.io/CLI11/book/chapters/flags.html</a></p>
</blockquote>

<p><img src="/images/vge-base-6.png" alt="image" /><br />
이미지 상단에 보면 다음 처럼 comand line argument를 주어 실행시켰는데, 앞으로의 예제들에서도 필요한 초기 옵션을 설정하는데 사용할 계획이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./traingle.exe -f 3 --height=720
</code></pre></div></div>

<p>ImGui를 활용한 옵션 선택과 겹칠수도 있는데, 엄격하게 구분하지 않고 필요시 자유롭게 두 기능을 모두 쓸 생각이다.</p>

<h1 id="마무리">마무리</h1>

<p>base 작성과 코드 structure 구현 등이 끝났으므로, 앞으로는 각 예제의 내용에 초점을 맞춰서 정리할 계획이다.<br />
렌더링 관련 코드를 작성할때 답답한 부분이, 초반에 아무것도 눈에 보이지 않을때인 것 같다. 뭔가 화면에 보이는게 달라진다면 변화를 주면서 디버깅 하거나 한 단계씩 추가하는게 용이할텐데, 아무것도 안나오는 검은 화면이 쭉 유지되다가 어느 순간 점프하면서 화면에 내용들이 보이기 시작한다. (디버깅 관련해서는 확실히 renderDoc 등의 툴 사용법을 익혀봐야겠다. 렌더링 관련 구현이 막혔을때 생산성이 달라지지 않을까?)<br />
Vulkan 공부법에 대한 자료(<a href="https://www.jeremyong.com/c++/vulkan/graphics/rendering/2018/03/26/how-to-learn-vulkan/">How to Learn Vulkan</a>)에서도 나와있는 말인데,</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>눈에 보이는 progress 가 없다고 해서 progress가 없다고 생각하지 마라
</code></pre></div></div>
<p>는 말이 떠올랐다.<br />
그래도 확실히 처음 Vulkan을 접했을 때 보다는 수월하고 빠르게 구현할 수 있기도해서, 어느정도 익숙해졌음을 느끼기도 했다.</p>
<h2 id="readings">readings</h2>
<p>Vulkan API specification과 관련해서 잘 정리해놓은 블로그와 여러 설명 풍부한 블로그가 있어서 같이 남겨놓겠다.</p>

<ul>
  <li><a href="https://lifeisforu.tistory.com/397">[ Vlukan 연구 ] 들어가며 :: 그냥 그런 블로그 (tistory.com)</a></li>
  <li><a href="https://blog.naver.com/dmatrix/221858062590">Vulkan의 파이프라인 베리어 : 네이버 블로그 (naver.com)</a></li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[이전 글에서 적은대로, vulkan tutorial에 대한 학습을 마치고, 예제 구현 중심의 학습 방향으로 전환을 했다. 들어가기 전에, 어떤 내용들을 다룰 것인지와 repo 구성 환경에 대해서 정리해 놓으려 한다. 그 후, 예제 코드 구조의 기본이 되는 base 구조에 대한 작업 내용과 첫번째 예제인 triangle rendering 예제 구현까지의 내용을 다루겠다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vge-base-1.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vge-base-1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Tutorial - Compute shader</title><link href="https://keechang-choi.github.io/study/study-Vulkan-compute-shader/" rel="alternate" type="text/html" title="Vulkan Tutorial - Compute shader" /><published>2023-06-29T00:00:00+09:00</published><updated>2023-06-29T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-Vulkan-compute-shader</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-Vulkan-compute-shader/"><![CDATA[<p><a href="https://vulkan-tutorial.com/en/Compute_Shader">https://vulkan-tutorial.com/en/Compute_Shader</a></p>

<p>튜토리얼 문서에서 마지막으로 extra-chaper로 compute shader를 다루고 끝이 난다.<br />
<a href="https://github.com/Overv/VulkanTutorial/pull/320">Sascha Williems</a> 라는 사람이 이 챕터를 작성했다고 해서, github repo를 찾아봤는데, 다양한 vulkan 예제 구현 repo가 있었다.<br />
해당 코드를 받아서 여러 예제들을 실행시켜봤는데, 다음으로 공부할 방향을 이 레포와 같게 구현해나가면 좋겠다는 생각이 들어서 내 repo도 새로 정리하고, 예제들을 하나씩 구현해나가는 형태로 계획을 세웠다.<br />
이 example repo에 대한 내용은 다음 글에서 계획과 추가한 예제마다 post를 하나씩 작성할 계획이다.</p>

<ul>
  <li><a href="#compute-shader">Compute Shader</a>
    <ul>
      <li><a href="#intro">Intro</a></li>
      <li><a href="#advatages">Advatages</a></li>
      <li><a href="#vulkan-pipeline">Vulkan pipeline</a></li>
      <li><a href="#example">example</a></li>
      <li><a href="#예제-구현-방향">예제 구현 방향</a></li>
      <li><a href="#data-manipulation">data manipulation</a>
        <ul>
          <li><a href="#ssbo---shader-storage-buffer-objects">SSBO - shader storage buffer objects</a></li>
        </ul>
      </li>
      <li><a href="#compute-queue-families">compute queue families</a></li>
      <li><a href="#compute-shader-stage">compute shader stage</a></li>
      <li><a href="#loading-compute-shaders">loading compute shaders</a></li>
      <li><a href="#preparing-the-shader-storage-buffers">preparing the shader storage buffers</a></li>
      <li><a href="#descriptors">descriptors</a></li>
      <li><a href="#compute-pipelines">compute pipelines</a></li>
      <li><a href="#compute-space">compute space</a>
        <ul>
          <li><a href="#gpu-architecture">GPU architecture</a></li>
        </ul>
      </li>
      <li><a href="#compute-shaders">compute shaders</a></li>
      <li><a href="#rungging-compute-commands">rungging compute commands</a>
        <ul>
          <li><a href="#dispatch">dispatch</a></li>
          <li><a href="#submitting-work">submitting work</a></li>
          <li><a href="#synchronizing-graphics-and-compute">synchronizing graphics and compute</a></li>
        </ul>
      </li>
      <li><a href="#drawing-the-particle-system">drawing the particle system</a></li>
      <li><a href="#conclusion">conclusion</a></li>
    </ul>
  </li>
  <li><a href="#additional-readings">additional readings</a>
    <ul>
      <li><a href="#youtube-video---introduction-to-vulkan-compute-shaders">Youtube video - Introduction to Vulkan Compute Shaders</a></li>
      <li><a href="#blog---gpugpgpu-series-mkblog">Blog - GPU/GPGPU series MKBlog</a></li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a>
    <ul>
      <li><a href="#new-vulkan-example-repo-for-studying">New Vulkan example repo for studying</a></li>
    </ul>
  </li>
</ul>

<hr />

<h1 id="compute-shader">Compute Shader</h1>
<h2 id="intro">Intro</h2>
<p>vulkan에서는 필수적으로 compute shader를 지원하는데, 구 api들과의 차이점이다.<br />
즉 고성능 desktop gpu든, 저전력 임베디드 장치이든 compute shader를 사용할 수 있다는 뜻이다.<br />
GPGPU로서 전통적인 그래픽스 작업 뿐 아니라, 여러 계산이 활용될 수 있는 내용이다.</p>
<ul>
  <li>image manipulation</li>
  <li>visibility test</li>
  <li>post processing</li>
  <li>lighting calculation</li>
  <li>animation</li>
  <li>physics</li>
  <li>headless compute
    <ul>
      <li>number crunching. 숫자 계산 관련 작업</li>
      <li>AI</li>
    </ul>
  </li>
</ul>

<p>AI 관련 작업의 경우는 pytorch나 tensorflow, Caffe등 다른 여러 특화된 framework가 있어서 Vulkan compute shader를 쓸 일은 없지 않을까 싶다.
Vulkan compute shader를 쓰는 장점은 Graphics 작업과 연계된 계산을 수행할 때, 별도의 데이터 변환이나 전송 작업 없이 작성할 수 있어서 성능과 구현 상 이점에 있지 않을까 싶다.</p>

<h2 id="advatages">Advatages</h2>
<p>compute shader를 쓰는 장점</p>
<ul>
  <li>CPU의 workload를 분산한다.</li>
  <li>CPU memory에서 GPU memory로 data moving이 필요없다.
    <ul>
      <li>이 말은 예를 들어 물리 시뮬레이션의 결과를 graphics shader를 통해 렌더링하고 싶을때, CPU를 사용했다면 결과를 GPU로 옮겨줘야하는 작업이 필요하지만, GPU에서 계산되었다면 그런 단계가 필요 없다는 뜻으로 이해했다.</li>
    </ul>
  </li>
  <li>GPU의 강력한 parallelized computing.</li>
</ul>

<h2 id="vulkan-pipeline">Vulkan pipeline</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">![image](https://vulkan-tutorial.com/images/vulkan_pipeline_block_diagram.png)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">*[https://vulkan-tutorial.com/images/vulkan_pipeline_block_diagram.png](https://vulkan-tutorial.com/images/vulkan_pipeline_block_diagram.png)*</td>
    </tr>
  </tbody>
</table>

<p>우측의 compute shader stage는 기존 graphics pipeline stage에 포함되지 않는 것들인데, 중앙의 descriptor set들의 사용은 동일하게 할 수 있다.</p>

<h2 id="example">example</h2>
<p>여기서 구현할 예제는 particle system이다.</p>
<ul>
  <li>vertices -&gt; vertex buffer</li>
  <li>update based on some equation.</li>
</ul>

<p>classical한 cpu basd particle system에서는 host의 main memory에 particle data를 저장하고, cpu에서 업데이트 한다. 그 다음 vertices가 gpu의 memory로 전송된 다음 display된다.
결국 vertex buffer를 매 frame마다 새로 만들어주는 구조이고, 이 부분의 비용이 높다. 구현 방법에 따라서, gpu의 memory가 cpu에 의해 written 되게 하는 방식 (resizable BAR라고 하는 시스템을 쓰거나, integrated GPU의 unified memory를 쓰는 등)을 쓰거나 혹은 host local buffer를 써서(가장 느림) CPU가 particle을 update하는 우회방식을 써야한다.</p>

<p>GPU방식에서는, gpu에 처음 upload한 vertice를 가지고 compute shader를 통해 GPU memory상에서 바로 update할 수 있다. 이 방식이 빠른 원리는 GPU와 그 local memory의 bandwidth가 훨씬 크기 때문인데, PCI-E bandwidth와 main memory에 의해 CPU 기반에서는 제한되게 된다.</p>

<p>또한 particle을 update하고 rendering 하는게 병렬로 가능해지는데, 이를 asynch compute 라고하고 여기서는 다루지 않는다.</p>

<h2 id="예제-구현-방향">예제 구현 방향</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이 tutorial에서의 예제</th>
      <th style="text-align: center">실제 구현된 예제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](https://vulkan-tutorial.com/images/compute_shader_particles.png)</td>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-9.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">*[https://vulkan-tutorial.com/images/compute_shader_particles.png](https://vulkan-tutorial.com/images/compute_shader_particles.png)*</td>
      <td style="text-align: center">실행한 예제 코드</td>
    </tr>
  </tbody>
</table>

<p>차이점은 기존에 LVE와 tutorial 후반부에서 구현해놓은 내용들 위에 compute particle 내용을 추가했다는 점이다.</p>

<p>이 시점에서의 코드 구조와 구현할 계획들을 정리하면 다음과 같다.</p>

<ul>
  <li>현재 구조
    <ul>
      <li>render system의 하위로 pipeline이 포함되어 있고, graphics pipeline만이 구현되어 있음. 이
        <ul>
          <li>이 pipeline은 <code class="language-plaintext highlighter-rouge">renderGameObjects()</code> 내부에서 frameInfo의 command buffer와 함께 bind된다.</li>
        </ul>
      </li>
      <li>renderer가 swapchain과 command buffer 자원을 가지고 있다.
        <ul>
          <li>renderer에서 얻은 render pass로 render system이 pipeline을 생성함.</li>
        </ul>
      </li>
      <li>descriptor set과 ubo는 app에서 선언되어 있다.</li>
      <li>seamphore와 fence는 swapChain 내부에 구현되어 있다.</li>
    </ul>
  </li>
  <li>Requirements
    <ul>
      <li>기존 point light system과 simple render system의 기능을 유지한다.</li>
      <li>추가할 particle compute system은 graphics와 compute pipeline을 둘다 소유한다.
        <ul>
          <li>swapchain과 render pass는 공용.</li>
          <li>어차피 submit, synchronization 관련은 swapchain image를 공유하기 때움.</li>
          <li>compute semaphore와 command buffer는 별도로 필요하다.</li>
        </ul>
      </li>
      <li>command buffer와 ubo, descriptor set 등 자원이 compute 용도 별도로 필요하다.</li>
    </ul>
  </li>
  <li>구조
    <ul>
      <li>renderer는 graphics, compute 공용으로 사용한다.
        <ul>
          <li>swapchain - queue family index, sema, fence등. graphics 관련 자원들이 이미 들어있다.
            <ul>
              <li>sema - graphics / compute</li>
            </ul>
          </li>
          <li>cmd buffer - graphics / compute</li>
          <li>여기서 submit 할때 synch관련 내용을 조정한다.</li>
          <li><code class="language-plaintext highlighter-rouge">beginFrame()</code> / <code class="language-plaintext highlighter-rouge">endFrame()</code> 과 별도로 compute 과정 bigin/End for each frame이 필요하다.</li>
        </ul>
      </li>
      <li>system graphics - point light / simple / particle
        <ul>
          <li>descriptorSets, layout (not global)</li>
          <li>pipeline, layout</li>
          <li>ubo (not global)</li>
        </ul>
      </li>
      <li>system compute - particle
        <ul>
          <li>튜토리얼에서 <code class="language-plaintext highlighter-rouge">recordComputeCommandBuffer</code>에 해당하는 기능을 구현
            <ul>
              <li>bind 및 dispatch cmd recording</li>
            </ul>
          </li>
          <li>computeDescriptorSets가 별도로 필요하고, 거기에 ubo 및 SSBO(shader storage buffer obejct) 관련 자원이 필요함.
            <ul>
              <li>descriptorPool은 공용으로 쓰고, descriptorSetLayout은 별도로 사용.</li>
              <li>이미 graphics 목적의 ubo와 object별 texture에 사용되는 자원들은 구현되어 있으므로 compute 관련 자원만 추가하면 됨.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>포함 관계 및 순서
        <ul>
          <li>ssbo, ubo 생성</li>
          <li>descriptorSet 생성 (layout-allocate-write(buffer bind))
            <ul>
              <li>graphics와 compute 분리</li>
              <li>pool생성시 타입(pooSize) 및 수(maxSets) 반영</li>
              <li>descriptorPool의 경우, 하나의 pool을 써야하는지에 대한 확실한 정답은 없다.
                <ul>
                  <li><a href="https://www.khronos.org/blog/vk-ext-descriptor-buffer">https://www.khronos.org/blog/vk-ext-descriptor-buffer</a> 에서 관련 글을 찾아봤다.</li>
                  <li>여러개를 쓰게 되면 memory 할당에 의한 overhead가 있다는 것 같고, over allocate의 위험이 증가하는 문제가 있다.</li>
                  <li>그렇다고 하나의 pool만 쓰자니 각 descriptor를 얼마나 쓸지 미리 정해야하는 어색함이 생긴다.</li>
                  <li>보통 쓰는 방법이 thread 별로 pool을 나눠쓰는 방식이라고 한다.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>pipeline 생성 (layout에 descriptor 정보가 필요함)</li>
          <li>compute &amp; render 작성 (recording)</li>
          <li>shader module 작성
            <ul>
              <li>comp shader 및 particle render shader</li>
              <li>pipeline 생성시 확인.</li>
            </ul>
          </li>
          <li>이후 renderer에서 <code class="language-plaintext highlighter-rouge">beginFrame()</code> / <code class="language-plaintext highlighter-rouge">endFrame()</code>을 확장해서 적절한 사이에 recording 파트를 넣고, submit도 추가</li>
          <li>synchronization 관련 발생 가능한 문제는 기존 코드에 추가해서 swapchain에서 전부 해결</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">without gravity</th>
      <th style="text-align: center">with gravity</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-1.png)</td>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-5.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-2.png)</td>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-6.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-3.png)</td>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-7.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-4.png)</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-10.gif)</td>
      <td style="text-align: center">![image](/images/vulkan-tut-compute-particles-8.gif)</td>
    </tr>
  </tbody>
</table>

<p>변경 내용 PR<br />
<a href="https://github.com/keechang-choi/Vulkan-Game-Engine-Tutorial/tree/study-compute">https://github.com/keechang-choi/Vulkan-Game-Engine-Tutorial/tree/study-compute</a></p>

<p>추가 찾아본 자료들</p>
<ul>
  <li><a href="https://vkguide.dev/docs/extra-chapter/abstracting_descriptors/">https://vkguide.dev/docs/extra-chapter/abstracting_descriptors/</a></li>
  <li><a href="https://blog.hybrid3d.dev/2020-12-21-reason-for-slow-of-if-statement-in-shader#fn:1">https://blog.hybrid3d.dev/2020-12-21-reason-for-slow-of-if-statement-in-shader#fn:1</a></li>
</ul>

<h2 id="data-manipulation">data manipulation</h2>
<p>여러 buffer타입을 다뤘다.</p>
<ul>
  <li>vertex/index로 primitives를 전달</li>
  <li>uniform으로 data를 shader로 전달</li>
  <li>이미지 써서 texture mapping</li>
</ul>

<p>지금까지의 내용들은 data를 cpu에서 썼던 것들을 GPU에서 읽는 작업만 수행했음.<br />
compute shader에서 중요한 것은 buffer에 읽는 것 뿐만 아니라 쓰는것이기에, storge type의 새로운 buffer type을 다뤄야 함.</p>

<h3 id="ssbo---shader-storage-buffer-objects">SSBO - shader storage buffer objects</h3>
<p>SSBO를 통해 sahder가 buffer에 쓰는 것을 가능케 해준다.<br />
uniform buffer 쓰는 것과 유사한데, 차이는 다른 버퍼 타입을 ssbo로 alias할 수 있고(vertex buffer를 ssbo로도 쓸 수 있다), 크기가 커도 된다는 것.</p>

<p>compute shader에서 write하고, vertex shader에서 read도 하고, staging buffer를 통해 transfer도 해야하는데, buffer info에 이런 여러 usage를 지정해주면 된다.<br />
처음 staging buffer를 통해 이 ssbo로 전달하고 나면 더이상 host에서 접근할 필요가 없으므로, GPU 메모리에만 머물도록 memory property를 device local로 지정해서 생성한다.</p>

<p>shader에서 해당 SSBO를 선언해주는데, 크기를 unbound로 선언해놓을 수 있는 장점이 있다. 그리고 memory layout qualifier를 지정해줘야하는데, 메모리에 어떻게 alignment 될지에 대한 형식이다. 여기서는 std140을 사용했는데, std430도 가능하다.</p>

<p>memory layout qualifier 관련 자료</p>
<ul>
  <li><a href="https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)">https://www.khronos.org/opengl/wiki/Interface_Block_(GLSL)</a></li>
  <li><a href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt">https://github.com/KhronosGroup/GLSL/blob/master/extensions/khr/GL_KHR_vulkan_glsl.txt</a></li>
</ul>

<h2 id="compute-queue-families">compute queue families</h2>
<p><a href="https://vulkan-tutorial.com/en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families#page_Queue-families">https://vulkan-tutorial.com/en/Drawing_a_triangle/Setup/Physical_devices_and_queue_families#page_Queue-families</a></p>

<p>튜토리얼 초반에 graphics queue family를 정했는데, vulkan에서는 graphics와 compute 연산이 둘다 가능한 queue family를 적어도 하나 지원하도록 강제해서 우리는 하나의 queue를  사용한다.<br />
하지만 dedicated compute queue를 쓸수도 있고, 이는 async compute queue 방식에서 사용된다.</p>

<h2 id="compute-shader-stage">compute shader stage</h2>
<p>compute shader 에서도 graphics 예시들에서와 비슷하게, compute stage pipeline을 쓴다. binding point가 graphcis와 compute 별도로 있는 것에 주의.</p>

<h2 id="loading-compute-shaders">loading compute shaders</h2>
<p><code class="language-plaintext highlighter-rouge">VK_SHADER_STAGE_COMPUTE_BIT </code> 를 써서 compile 된 shader 코드를 loading 한다.</p>

<h2 id="preparing-the-shader-storage-buffers">preparing the shader storage buffers</h2>
<p>GPU로 초기데이터를 전송한다. 그리고 frames-in-flight 수 만큼 준비해서 utilization을 높인다.<br />
SSBO를 생성한 후 이에 맞게 resize하고, staging buffer를 사용해서 transfer 한다.<br />
staging buffer는 transfer-src의 usage와, host-visible, host-coherent memory property를 써서 생성한다.</p>

<h2 id="descriptors">descriptors</h2>
<p>거의 graphics 부분과 동일하다. stage flag로 <code class="language-plaintext highlighter-rouge">VK_SHADER_STAGE_COMPUTE_BIT</code> 를 주는 것이 차이다. vertex shader 에서도 쓰고 싶으면 stage flag를 combine하면 된다.<br />
SSBO도 마찬가지로 command 에서 접근하기 위해서는 bind를 먼저 해줘야 한다. 여기서 주의할 점으로, 우리는 한 frame을 계산하기 위해서는 이전 frame의 결과를 읽어야 하므로, descriptor set에 이 정보를 추가한 두개의 SSBO를 담아야 한다. 우리는 하나의 descriptor set에 binding으로 추가하는 방식으로 구현한다.<br />
uniform buffer와 ssbo 두개를 포함한 총 3개의 binding을 사용하는 descriptor set 한개를 생성하고 write 해줘야 한다. 이에 맞는 descriptor pool size도 frames-in-flight 수를 고려하여 정해줘야 한다.</p>

<h2 id="compute-pipelines">compute pipelines</h2>
<p>compute 단계는 graphics pipeline의 일부가 아니므로, 새로운 pipeline 생성이 필요하다.
rasterization stage가 없어서 설정할 것이 많지 않고 간단하다.</p>

<h2 id="compute-space">compute space</h2>
<p>어떻게 compute workloads가 GPU의 3dim에서 처리되는지에 대한 두가지 개념이 있다.</p>
<ul>
  <li>work group
    <ul>
      <li>gpu의 compute hardware에서 어떻게 wkrloads가 형성되고 처리되는지.</li>
      <li>work group의 dimension은 dispatch command를 사용할 때 결정된다.</li>
      <li><code class="language-plaintext highlighter-rouge">vkCmdDispatch</code>에서 dim이 정의된다.</li>
    </ul>
  </li>
  <li>invocation
    <ul>
      <li>그리고 각 그룹은 invocation의 묶음이다.</li>
      <li>invocation들은 잠재적으로 병렬로 실행되고, 각 차원은 compute shader에 설정된다.</li>
      <li>한 work group 안의 invocation 들은 shadred momory에 대한 접근을 가진다.</li>
      <li>compute shader의 local size에서 dimension이 정의된다.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">maxComputeWorkGroupCount</code>, <code class="language-plaintext highlighter-rouge">maxComputeWorkGroupInvocations</code>,   <code class="language-plaintext highlighter-rouge">maxComputeWorkGroupSize</code>등의 값이 device마다 다르므로 항상 확인하고 compute shader를 사용해야 한다. <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkPhysicalDeviceLimits.html">VkPhysicalDeviceLimits</a></li>
</ul>

<h3 id="gpu-architecture">GPU architecture</h3>
<p>GPU 구조에 관한 배경이 없이는 이해하기 힘든 내용들이라 판단되어 추가로 찾아본 내용들이다.</p>
<ul>
  <li>compute shader 와 work group
    <ul>
      <li><a href="https://stackoverflow.com/questions/54750009/compute-shader-and-workgroup">https://stackoverflow.com/questions/54750009/compute-shader-and-workgroup</a></li>
      <li>
        <blockquote>
          <p>여러 api에서 유사한 계층의 grid subdivision of work 개념이 있다.<br />
vulkan 에서는 invocation(thread) -&gt; subgroup -&gt; local work group -&gt; global work group의 계층이 있고, subgroup은 더 복잡한 개념이라 우선 넘어가는게 편하다.<br />
shader 에서 설정한 local_size는 a local workgroup에서의 각 invoation의 dim을 결정하고, <code class="language-plaintext highlighter-rouge">vkCmdDispatch</code>에서 정하는 dim이 global workgroup에서의 local workgroup의 dim을 결정한다.<br />
그래서 dispatch(M,N,P) 하고 layout(X,Y,Z)이면 vulkan이 M<em>N</em>P개의 local work group들을 실행시킬거로, 각각은 X<em>Y</em>Z 번의 invocation of shader로 구성된다.</p>
        </blockquote>
      </li>
      <li>GPU programming 개념
        <ul>
          <li><a href="https://enccs.github.io/gpu-programming/4-gpu-concepts/#gpu-execution-model">https://enccs.github.io/gpu-programming/4-gpu-concepts/#gpu-execution-model</a></li>
          <li>
            <blockquote>
              <p>parallelism</p>
              <ul>
                <li>computing
                  <ul>
                    <li>distributed vs. shared-memory</li>
                    <li>분산 환경은 process based vs. 공유메모리는 thread based.</li>
                    <li>message exchange vs. serial + parallel region.</li>
                  </ul>
                </li>
              </ul>
            </blockquote>
          </li>
          <li>
            <blockquote>
              <p>실행 모델</p>
              <ul>
                <li>CPU
                  <ul>
                    <li>low latency, low throughput</li>
                    <li>heavy cachine과 branch prediction을 통해 달성</li>
                  </ul>
                </li>
                <li>GPU
                  <ul>
                    <li>high latency, high throughput</li>
                    <li>개별 thread는 cpu보다 훨씬 가벼워서, context switching의 penalty가 적다. 그래서 어떤 threads는 메모리 관련 연산을 하면서, 다른 threads는 다른 명령들을 실행하는 형태가 가능.</li>
                  </ul>
                </li>
                <li>thread
                  <ul>
                    <li>내부적으로 index를 가져서 계산과 접근에 사용되는 구조다.</li>
                    <li>global gpu memory에 접근 가능하지만, 다른 threads에서 변경된 내용은 kernel을나눠서 update 된 후 사용해야 한다.</li>
                    <li>threads들은 warp라는 group으로 묶인다.</li>
                    <li>gpu memory 접근은 특정 사이즈 단위로 묶이고, 같은 warp에 있는 threads들은 memory에서 인접한 데이터에 접근해야 한다. coalesced memory access</li>
                    <li>한 warp에서는 같은 명령을 실행하게 해서 성능을 높이는데, 만약 if branch등이 있어서 한 warp내부에서 다른 path를 실행해야 한다면, 두 branch를 sequential하게 두번 실행하게 된다. 이걸 lock-step 실행이라고 하는데, 그래서 이 warp divergence 비용을 줄이려고 lock-step 실행이 없는 구조도 있음</li>
                    <li>그 위의 계층: block. 각 block은 하나의 SM(Streaming Multiprocessor) 단위에 배정됨. 각 SM(or SMP)는 하나이상의 SIMT 단위를 포함하고, 스케쥴러와 매우 빠른 on-chip memory(shared memory)를 가짐.</li>
                  </ul>
                </li>
              </ul>
            </blockquote>
          </li>
        </ul>
      </li>
      <li>GPU 메모리 모델
        <ul>
          <li><a href="https://www.khronos.org/blog/comparing-the-vulkan-spir-v-memory-model-to-cs">Khronos Blog - The Khronos Group Inc</a></li>
          <li><a href="https://mkblog.co.kr/gpgpu-series-3-gpu-architecture-overview/">[GPGPU Series 3] GPU Architecture Overview – MKBlog</a></li>
          <li><a href="https://comsys-pim.tistory.com/6">[NVIDIA] GPU Architecture (tistory.com)</a>
            <ul>
              <li>SM안에 여러 SIMT unit이 있고
                <ul>
                  <li>그 SIMT UNIT 안에는 SP(Streaming Processor)가 여러개, warp scheduler, register 등이 위치함.</li>
                </ul>
              </li>
              <li>SM안에는 shared memory도 있고, L1 cache도 있음.</li>
              <li>이런 SM에 여러개 모인걸 하나의 gpu cluster라고 보면 됨.</li>
              <li>L2 cache에 해당하는 cache는 gpu memory partition에 DRAM과 함께 위치하는 구조.</li>
            </ul>
          </li>
          <li><a href="https://www.rastergrid.com/blog/gpu-tech/2021/01/understanding-gpu-caches/">Understanding GPU caches – RasterGrid</a>
            <ul>
              <li>보통 GPU core라고 하면 SM과 같은 뜻임.
                <ul>
                  <li>이 코어 안에는 여러개의 warp(wave) 들이 있다.</li>
                  <li>각 wave 안에는 여러 thread가 있다.</li>
                </ul>
              </li>
              <li>이 core/SM은 per core data cache를 가지는데 보통 CPU의 L1 cache에 해당한다고 보면 됨.
                <ul>
                  <li>shared memory도 가지는데, 이건 cache가 아니라 scratchpad memory의 일종으로 cache와 비슷한 역할을 하게 해준다.</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>용어 비교 및 정리
    <ul>
      <li><a href="https://github.com/googlefonts/compute-shader-101/blob/main/docs/glossary.md">compute-shader-101/docs/glossary.md at main · googlefonts/compute-shader-101 (github.com)</a></li>
      <li>thread =&gt; invocation / work-item</li>
      <li>warp =&gt; sub-group / wave
        <ul>
          <li>병렬실행 단위.</li>
          <li><a href="https://www.khronos.org/blog/vulkan-subgroup-tutorial">https://www.khronos.org/blog/vulkan-subgroup-tutorial</a></li>
        </ul>
      </li>
      <li>block =&gt; work-group</li>
    </ul>
  </li>
</ul>

<h2 id="compute-shaders">compute shaders</h2>
<p>shader input</p>
<ul>
  <li>binding 0 =&gt; UBO</li>
  <li>binding 1 =&gt; last frame particle SSBO</li>
  <li>binding 2 =&gt; current frame particle SSBO</li>
  <li>invocation dimenstions
    <ul>
      <li><code class="language-plaintext highlighter-rouge">gl_GlobalInvocationID</code> 이 invocation across current dispatch인데, 이 값을 particle array의 index로 쓸 것임.</li>
    </ul>
  </li>
</ul>

<h2 id="rungging-compute-commands">rungging compute commands</h2>
<h3 id="dispatch">dispatch</h3>
<p>work group dim을 [particle count / 256, 1, 1] 로 지정해준다.<br />
그러면 한 work group의 compute shader는 256번의 invocation을 할 것이므로, 전체 particle에 대한 계산을 하게 된다.<br />
pipeline 생성때와 마찬가지로, render pass나 viewport 등의 설정이 필요없어서 더 간단하다.</p>
<h3 id="submitting-work">submitting work</h3>
<p>먼저 compute queue에 제출해서 particle position을 update한 후, graphics queue에 submit 한다.</p>
<h3 id="synchronizing-graphics-and-compute">synchronizing graphics and compute</h3>
<p>write가 끝나기전에 read 하면 read-after-write hazard가 있을 수 있다.<br />
혹은 read 하고 있을때 update를 하면 write-after-read hazard가 발생한다.<br />
그래서 두 queue 사이의 synch가 필요한데, 이는 semaphore와 fence를 통해 달성할 것이다. 왜냐하면 submit 은 순서대로 하더라도 끝나는 순서는 보장되지 않기 때문.</p>

<p><code class="language-plaintext highlighter-rouge">computeInFlightFences</code>와 <code class="language-plaintext highlighter-rouge">computeFinishedSemaphores</code>를 추가하는데 graphics와 마찬가지로 fence는 signaled state로 시작한다.</p>

<p>이 tutorial code 에서 synch 순서를 요약하면 다음과 같다.</p>
<ul>
  <li>wait <code class="language-plaintext highlighter-rouge">computeInFlightFences</code></li>
  <li>update UBO(시간 등 정보는 compute shader에서도 필요하다)</li>
  <li>reset <code class="language-plaintext highlighter-rouge">computeInFlightFences</code></li>
  <li>record compute command buffer</li>
  <li>submit to compute queue
    <ul>
      <li>sema
        <ul>
          <li>signal: <code class="language-plaintext highlighter-rouge">computeFinishedSemaphores</code></li>
        </ul>
      </li>
      <li>fence: <code class="language-plaintext highlighter-rouge">computeInFlightFences</code></li>
    </ul>
  </li>
  <li>기존 graphics Fence wait. <code class="language-plaintext highlighter-rouge">inFlightFences</code></li>
  <li>acquire next image</li>
  <li>record draw</li>
  <li>reset Fence. <code class="language-plaintext highlighter-rouge">inFlightFences</code></li>
  <li>submit to graphics queue
    <ul>
      <li>sema
        <ul>
          <li>wait:
            <ul>
              <li><code class="language-plaintext highlighter-rouge">computeFinishedSemaphores</code></li>
              <li><code class="language-plaintext highlighter-rouge">imageAvailableSemaphores</code></li>
            </ul>
          </li>
          <li>signal:
            <ul>
              <li><code class="language-plaintext highlighter-rouge">renderFinishedSemaphores</code></li>
            </ul>
          </li>
          <li>fence: <code class="language-plaintext highlighter-rouge">inFlightFences</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>submit to present queue
    <ul>
      <li>sema
        <ul>
          <li>wait: <code class="language-plaintext highlighter-rouge">renderFinishedSemaphores</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Q. compute queue submit에 wait가 없어도 괜찮은 이유:</p>
<blockquote>
  <p>wait fence로 그 frame에서 compute command buffer의 사용이 끝난 다음 recording -&gt; submission 하도록 강제하고 있어서.</p>
</blockquote>

<p>Q. graphics queue submit에 wait가 필요한 이유:</p>
<blockquote>
  <ol>
    <li>compute buffer가 업데이트 되고 있을때는 vertices ssbo를 읽으면 안됨. (이를 위한 <code class="language-plaintext highlighter-rouge">computeFinishedSemaphores</code>)
  이때 wait stage는 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_VERTEX_INPUT_BIT </code></li>
    <li>기존 present engine에서 acquire next image를 통해 present가 끝났는지를 fragment shader가 color attachment에 output하기 전에 확인하는 절차는 여전히 필요. (이를 위한 <code class="language-plaintext highlighter-rouge">imageAvailableSemaphores</code>)
  이때 wait stage는 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT </code></li>
  </ol>
</blockquote>

<h2 id="drawing-the-particle-system">drawing the particle system</h2>
<p>shader storage buffer를 생성할 때 여러 usage를 가지도록 설정했었는데, drawing의 vertex buffer로도 사용가능해서 바로 draw가 가능함.</p>
<h2 id="conclusion">conclusion</h2>
<p>compute shader 관련 추가 topic</p>
<ul>
  <li>shared memory</li>
  <li>asynchronous compute</li>
  <li>atomic operations</li>
  <li>subgroups</li>
</ul>

<h1 id="additional-readings">additional readings</h1>
<p>따로 내용을 정리하지는 않으려 한다.</p>
<h2 id="youtube-video---introduction-to-vulkan-compute-shaders">Youtube video - Introduction to Vulkan Compute Shaders</h2>
<p><a href="https://www.youtube.com/watch?v=KN9nHo9kvZs&amp;t=251s">Introduction to Vulkan Compute Shaders - YouTube</a><br />
말미에 현실을 그대로 복제하는 것만이 graphics의 목표는 아니라고 하면서 다음 인용구를 남겼는데 인상적이었다.</p>
<blockquote>
  <p><em>We do computer graphics because we want to convey our dreams to other people.</em> <br />
  <a href="https://en.wikipedia.org/wiki/Ken_Perlin"><code class="language-plaintext highlighter-rouge">Ken Perlin</code></a></p>
</blockquote>

<h2 id="blog---gpugpgpu-series-mkblog">Blog - GPU/GPGPU series MKBlog</h2>
<p><a href="https://mkblog.co.kr/category/research_study/gpusresearch/page/4/">GPU/GPGPU – Page 4 – MKBlog</a></p>

<h1 id="마무리">마무리</h1>

<p>Vulkan tutorial에 관한 내용을 모두 마쳤다. tutorial 수준에서 넘어간 부분도 많고 간소화 시켜서 핵심만 이해한 내용들도 많아서 앞으로 중복되는 내용이 나올때 마다 조금씩 더 깊게 살펴보는 방향으로 공부하면 좋을 것 같다.</p>

<p>향후 계획에 대해서, <a href="https://github.com/keechang-choi/Vulkan-Game-Engine-Tutorial">이 Vulkan Game Engine lecture로 시작한 repo</a>를 마무리 하고, 예제 구현 중심의 repo를 새로 작성하려 한다. 이유는 더이상 Game engine의 구조를 따라갈 이유도 없고, (해당 lecture도 추가되는 내용이 없는데 새로운 내용이 추가되면 반영해도 좋을 것 같다.) 마지막 compute shader 구현 부분에서 봤듯이, 기존 내용에 새로운 내용을 얹어가는 구현에 비효율이 크게 느껴졌기 때문이다. 앞으로는 각기 다른 주제의 예제를 작성할 때 공통 interface를 활용해서 핵심이 되는 부분만 빠르게 작성할 수 있는 구조의 repo를 관리하고자 한다.</p>

<h2 id="new-vulkan-example-repo-for-studying">New Vulkan example repo for studying</h2>

<p><a href="https://github.com/keechang-choi/Vulkan-Graphics-Example">https://github.com/keechang-choi/Vulkan-Graphics-Example</a></p>

<p>새로운 레포에 대한 생각은 <a href="https://github.com/SaschaWillems/Vulkan">SaschaWillems의 repo</a>를 보면서 들게 됐는데(직접 실행해보면 흥미로운 예제들이 많다.), 다양한 vulkan 활용 예제를 담고 있다. 처음에 이 repo의 fork를 떠서 수정할까 싶었는데, 그러면 기존 구현된 내용들을 너무 싶게 이용하면서 공부의 효과가 떨어질 것 같아 구조를 모방한 새로운 repo를 0부터 시작하기로 했다.</p>

<p>그렇다고 똑같은 코드를 따라쓰기 하는 것 역시 의미가 없다고 생각해서, 조금 변형한 구조와 예제 내용을 중심으로 예제를 하나씩 추가할 계획이다. 특히 레포 구조가 여러 cross platform을 지원하기 위해서 깔끔하지 않은 부분도 있고, c-api와 c-style 코드가 많아서 관리하기 깔끔한 구조는 아니라고 생각했다. 그래서 필요한 수정들은 적극적으로 구조 변경을 할 생각이며, 필요한 third-party 활용도 적극적으로 할 생각이다.</p>

<p>정해둔 변경은 vulak-c++ api 활용, VMA 메모리 allocation  활용이다.</p>
<ul>
  <li><a href="https://github.com/KhronosGroup/Vulkan-Hpp">KhronosGroup/Vulkan-Hpp: Open-Source Vulkan C++ API (github.com)</a></li>
  <li><a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">GPUOpen - VulkanMemoryAllocator (github.com)</a></li>
</ul>

<p>구현 주제와 순서 계획은 대략 다음과 같고, 하나씩 추가할때마다 포스트를 작성할 계획이다.</p>
<ul>
  <li>triangle rendering</li>
  <li>pipelines and model loading</li>
  <li>animation and skinning</li>
  <li>particle compute system</li>
  <li>position-based-simulation on compute shader
    <ul>
      <li>cloth?</li>
      <li>other physics simulation</li>
    </ul>
  </li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[https://vulkan-tutorial.com/en/Compute_Shader]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vulkan-tut-compute-particles-5.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vulkan-tut-compute-particles-5.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Tutorial - Recap Synchronization &amp;amp; RenderPass</title><link href="https://keechang-choi.github.io/study/study-Vulkan-recap-synchronization-renderpass/" rel="alternate" type="text/html" title="Vulkan Tutorial - Recap Synchronization &amp;amp; RenderPass" /><published>2023-05-27T00:00:00+09:00</published><updated>2023-05-27T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-Vulkan-recap-synchronization-renderpass</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-Vulkan-recap-synchronization-renderpass/"><![CDATA[<p>Vulkan Game Engine 영상에서 tutorial로 중간에 넘어오게 되면서, synchronization과 renderpass에서 가볍게 다루고 넘어간 내용들이 있어 구현에 헷갈리는 부분들이 있었다.<br />
특히 pipeline barrier와 subpass dependency 관련 검색해본 내용들을 위주로 정리하고, 관련 자료들 link를 남겨놓으려 한다.<br />
그리고 코드 구현에서 정확히 파악하고 있지 않은 부분들을 정리한 후, tutorial의 extra-chapter인 compute shader로 넘어가려 한다.</p>

<ul>
  <li><a href="#synchronization">Synchronization</a>
    <ul>
      <li><a href="#tutorial-rendering-and-presentation">tutorial rendering and presentation</a>
        <ul>
          <li><a href="#outline-of-a-frame">outline of a frame</a></li>
          <li><a href="#synchronization-1">synchronization</a></li>
          <li><a href="#semaphore">semaphore</a></li>
          <li><a href="#fence">Fence</a></li>
          <li><a href="#what-to-choose">What to choose?</a></li>
          <li><a href="#creating-synchronization-objects">creating synchronization objects</a></li>
          <li><a href="#이전-프레임-기다리기">이전 프레임 기다리기</a></li>
          <li><a href="#command-buffer-녹화">command buffer 녹화</a></li>
          <li><a href="#command-buffer-제출">command buffer 제출</a></li>
          <li><a href="#subpass-dependency">subpass dependency</a></li>
          <li><a href="#presentation">presentation</a></li>
          <li><a href="#q-subpass-dependency-vs-semaphore">Q. subpass dependency vs. semaphore</a></li>
        </ul>
      </li>
      <li><a href="#cg-at-tu-wien-ep7">CG at TU wien ep7</a>
        <ul>
          <li><a href="#recap">recap</a>
            <ul>
              <li><a href="#commands">commands</a></li>
              <li><a href="#pipeline-stages">pipeline stages</a></li>
              <li><a href="#recording">recording</a></li>
            </ul>
          </li>
          <li><a href="#wait-idle-operation">wait idle operation</a></li>
          <li><a href="#fences">fences</a></li>
          <li><a href="#semaphores">semaphores</a></li>
          <li><a href="#pipeline-barriers">pipeline barriers</a></li>
          <li><a href="#memory-availability-and-visibility">memory availability and visibility</a></li>
          <li><a href="#renderpass-subpass-dependencies">renderPass subpass dependencies</a></li>
          <li><a href="#events">events</a></li>
        </ul>
      </li>
      <li><a href="#fix">fix</a>
        <ul>
          <li><a href="#frames-in-flight">frames in flight</a></li>
          <li><a href="#single-depth-buffer">single depth buffer</a></li>
          <li><a href="#frame-buffer-and-swapchain-image">frame buffer and swapchain image</a></li>
          <li><a href="#additional-fence">additional fence</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#renderpass">RenderPass</a>
    <ul>
      <li><a href="#framebuffer">FrameBuffer</a></li>
      <li><a href="#renderpass-1">RenderPass</a></li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a></li>
</ul>

<hr />

<h1 id="synchronization">Synchronization</h1>

<h2 id="tutorial-rendering-and-presentation">tutorial rendering and presentation</h2>
<p><a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation">https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation</a></p>

<p>먼저 tutorial의 위 챕터 내용을 정리해봤다.</p>
<h3 id="outline-of-a-frame">outline of a frame</h3>
<p>tutorial에서는 다음과 같이 frame에 관련된 task들을 요약 가능하다.</p>
<ul>
  <li>이전 frame이 끝나기까지 대기</li>
  <li>swapChain으로부터 image 얻기</li>
  <li>이미지에 scene을 그리는 command buffer 녹화 (recording)</li>
  <li>녹화된 command buffer 제출 (submit)</li>
  <li>swapChain image를 present</li>
</ul>

<h3 id="synchronization-1">synchronization</h3>
<p>vulkan의 핵심 철학 중 하나가 gpu의 실행 동기화가 명시적이라는 것이다. synch primitives를 사용해서 연산의 순서를 정의하는데, vulkan api 호출들은 GPU에서의 작업이 비동기적으로 이뤄지고 그 작업 끝나기 전에 함수가 먼저 반환되기 때문이다.<br />
위의 작업들의 함수 호출은 실제로 끝나기 전에 반환되기 때문에 각 작업이 끝나고나서 실행되는 순서를 강제하기 위해서는 다음의 primitives를 잘 써야한다고 한다.</p>

<h3 id="semaphore">semaphore</h3>
<p>command buffer를 제출하는 등의 queue 연산의 순서를 주고 싶을때 쓴다.</p>
<ul>
  <li>graphics queue</li>
  <li>presentation queue</li>
</ul>

<p>두 가지가 현재 쓰였고, semaphore는 binary, timeline 두가지 종류가 있지만 우선 binary 타입만 다룬다.</p>

<p>세마포어는 signaled or not 두 상태를 가지는데, 처음 시작은 unsignaled로 시작한다.<br />
같은 semaphore S를 한 queue operation에 signal sema로 지정하고, 다른 queue op에 wait sema로 지정하는 형식으로 사용된다.</p>

<p>주의할 점으로, <code class="language-plaintext highlighter-rouge">vkQueueSubmit()</code> 호출은 바로 반환되고 실제 waiting은 GPU에서 발생한다는 것이다. CPU에서는 blocking 없이 계속 실행이 된다. CPU가 wait 하게 만드려면 다음의 Fence synch primitive를 사용해야 한다.</p>

<h3 id="fence">Fence</h3>
<p>host(CPU)에서 GPU의 연산이 언제 끝났는지 알 필요가 있을때 쓴다.<br />
fence도 signaled or not의 state를 가지는데, queue에 실행할 작업을 제출할때, 그 작업에 fence를 붙여 그 작업이 완료되면 fence가 signaled 되고 이후 host에서 특정 fence를 wait하는 방식으로 동작한다.</p>

<p>예시로, GPU에서 작업이 끝난 이미지를 CPU로 transfer한 후, file로 저장하고 싶을때 쓸 수 있다.</p>

<p>host를 block한다는 점이 semaphore와 차이점.</p>

<p>요약하면 semaphore는 GPU에서의 연산 실행 순서를 명시하고, fence는 CPU와 GPU가 서로 동기화 되도록 할 때 사용한다.</p>

<h3 id="what-to-choose">What to choose?</h3>
<p>현재 tutorial 구현에서 적용되어야할 부분이 두 군데가 있다.</p>
<ul>
  <li>swapchain operations</li>
  <li>이전 frame이 끝나기 기다리기.</li>
</ul>

<p>swapchain 관련 연산들은 GPU에서 일어나기때문에 semaphore를 쓰면 된다.</p>

<p>현재 구조에서는 매 frame 마다 command buffer를 re-recording 하고 있는데, *(미리 recording 해놓은 command buffer를 재사용 하는 방식도 가능하지만) 여기서는 recording을 Host에서 할 때, GPU에서 아직 실행되고 있는 command buffer에 overwrite하고 싶지 않기에 fence를 쓴다.</p>

<h3 id="creating-synchronization-objects">creating synchronization objects</h3>
<ul>
  <li>이미지가 swapchain으로부터 얻어지고, 렌더링 준비가 완료되었다는 signal을 위한 semaphore</li>
  <li>렌더링이 완료되어서 presentation이 가능하다는 semaphore</li>
  <li>그리고 동시에 하나의 frame만 렌더링 되고 있도록 하는 fence</li>
</ul>

<p>총 2개의 semaphore와 1개의 fence가 필요한데, 이전 LVE 구조에서는 fence를 한 종류 더 총 2개 종류를 쓰고 있었다. 이 부분에 대한 수정 history는 아래의 <a href="#fix">fix</a> 에서 좀 더 자세히 다루려 한다.<br />
각 primitive들은 <code class="language-plaintext highlighter-rouge">MAX_FRAMES_IN_FLIGHT</code> 별로 하나씩 필요하다.</p>

<h3 id="이전-프레임-기다리기">이전 프레임 기다리기</h3>
<p>처음 <code class="language-plaintext highlighter-rouge">acquireNextImate()</code> 에서 이 fence를 기다린 후 <code class="language-plaintext highlighter-rouge">vkAcquireNextImageKHR()</code> 를 호출한다. 이때 초기 설정은 signaled 되어 있도록 한다.
<code class="language-plaintext highlighter-rouge">imageAvailableSemaphore</code> 는 이미지를 얻어오는 작업이 끝나면 signaled 되도록 인자로 지정해준다.</p>

<h3 id="command-buffer-녹화">command buffer 녹화</h3>
<p><code class="language-plaintext highlighter-rouge">vkResetCommandBuffer()</code> 관련해서 차이점이 있는데, 이는 tutorial 구현과 다르게, command pool 생성시 <code class="language-plaintext highlighter-rouge">VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT</code> 사용 여부와 관련이 있다.<br />
<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html">https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkCommandPoolCreateFlagBits.html</a></p>

<h3 id="command-buffer-제출">command buffer 제출</h3>
<p>submitInfo 관련</p>
<ul>
  <li>어떤 semaphore를 사용해서 wait할지
    <ul>
      <li><code class="language-plaintext highlighter-rouge">imageAvailableSemaphore</code></li>
      <li>draw등 제출한 command들은 그 swapchain에서 이미지를 얻어오는 것이 완료된 이후에 그 이미지에 write을 하고 싶다.</li>
    </ul>
  </li>
  <li>어떤 pipeline stage에서 기다릴지
    <ul>
      <li><code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code></li>
      <li>최적화와 관련된 부분인데, graphics pipeline stages에서 이미지가 사용가능한 상태가 아니더라도, color attachment output stage 이전까지는 gpu에서 실행이 되도록 하고 싶다는 뜻이다.</li>
    </ul>
  </li>
  <li>이 제출한 command들이 완료되면 signal을 보낼 semaphore가 있는지?
    <ul>
      <li><code class="language-plaintext highlighter-rouge">renderFinishedSemaphore</code></li>
      <li>이 semaphore를 사용해서 렌더링이 끝난 이미지를 present하도록 설정해준다.</li>
    </ul>
  </li>
</ul>

<h3 id="subpass-dependency">subpass dependency</h3>

<p>renderPass에 있는 subpass에서는 이미지의 layout transition을 명시하지 않아도 고려한다. 
이 transition은 subpass들간의 memory &amp; execution dependency를 명시한다.</p>

<p>기본 built-in dependencies는 render pass의 시작과 끝에서의 transition에 관한 것인데, 시작 부분에서는 이미지를 아직 얻어오지 않을 수 있는 문제가 있다.</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">vkCmdBeginRenderPass()</code> 를 가장 먼저 recording 하는데, 그 시점에서 built-in dependency에 의한 image layout transition이 일어나기에는 문제가 있다는 뜻으로 이해함. <br />
두가지 해결법이 있는데,</p>
  <ul>
    <li>draw command 를 제출할 때, <code class="language-plaintext highlighter-rouge">imageAvailableSemaphore</code> 의 waitStages를 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>로 주어서, render pass가 이미지가 가용해진 이후에 시작하도록 하거나 (최적화 관련 단점이 될 듯?)</li>
    <li>subpass dependency를 명시해서 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code> 로 지정하는 방법.
      <ul>
        <li>subpass dependency를 external -&gt; 0 명시해서 직전 subpass 지정</li>
        <li>srcStageMask를 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code>로 지정, dstStageNask를 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code>로 지정.</li>
        <li>srcAccessMask를 0, dstAccessMask를 <code class="language-plaintext highlighter-rouge">VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT</code> 로 지정</li>
        <li>직전 subpass의 color output stage와 현재 subpass의 color output stage 사이에서 any -&gt; color write 로의 layout transition이 이뤄지도록 지정해줌.</li>
        <li>사실 이 부분 관련해서 여러 설명을 검색해봤는데, 잘 이해가 안됐다. 아래의 <a href="#q-subpass-dependency-vs-semaphore">질답</a>에서 추가할텐데, spec 문서의 first, second synchronization scope를 그대로 이해하는게 가장 정확한 설명인 것 같아 정리해놓으려 한다.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="presentation">presentation</h3>

<p>graphics queue submit이 끝난 후, <code class="language-plaintext highlighter-rouge">renderFinishedSemaphore</code> 를 wait로 주어서 <code class="language-plaintext highlighter-rouge">vkQueuePresentKHR()</code> 를 호출한다.<br />
graphics queue submit에서 signal sema로 지정해놓았기 때문에, rendering이 끝날때까지 기다렸다가 presentation engine으로 요청을 하게 한다.</p>

<h3 id="q-subpass-dependency-vs-semaphore">Q. subpass dependency vs. semaphore</h3>
<blockquote>
  <p>Q. subpass dependency와 semaphore의 설정이 각각 필요한 이유가 뭔지? 서로 중복되는 내용은 아닌지?<br />
<a href="https://stackoverflow.com/questions/59693320/use-of-vksubpassdependency-vs-semaphore">https://stackoverflow.com/questions/59693320/use-of-vksubpassdependency-vs-semaphore</a></p>

  <p>A. semaphore에서 지정해주는 <code class="language-plaintext highlighter-rouge">pWaitDstStageMask</code>는 같이 제출한 command 실행하기 전까지 기다릴 어떤 pipeline stage를 명시하는 것이고, <code class="language-plaintext highlighter-rouge">vkAcquireNextImageKHR()</code> 에서 주는 image index는 queue 연산이 아니기 때문에 presentation engine에서 그 이미지의 사용이 끝났는지 알수가 없기 때문에 필요했던 것임.</p>

  <p>반대로 subpass dependency는 layout transition이 언제 일어날지에 대한걸 지정해주기 때문에 필요함. 지정하지 않으면 아무때나 알아서 일어날텐데, presentation engine에서 아직 이미지를 읽고 있는데 layout을 바꾸버리는 상황이 발생 가능함. (지정하지 않은 <code class="language-plaintext highlighter-rouge">srcStageMask</code>는 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT</code>가 default.)</p>

  <p>이걸 막기위해, <code class="language-plaintext highlighter-rouge">pWaitDstStageMask</code>를 top of pipe (all commands) 로 주면, vertex processing등도 하지 않고 모든 것을 기다린 다음 시작하니까 layout 변경이 없어도 되긴함. 근데 optimal 하지 않을 수 있음.</p>

  <p>그래서 우리가 하려는 방식은 layout transition의 <code class="language-plaintext highlighter-rouge">srcStageMask</code>를 <code class="language-plaintext highlighter-rouge">VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT</code>로 지정해서 이 이후에 write로 변경을 하는 방식. 이전 render pass의 commands들이 이 color att output stage에 도달한 이후에 layout transition이 일어나도록 강제하는 것인데, 이 시점은 sema wait가 끝난 시점이므로, presentation engine이 그 이미지 사용을 끝냈고, image layout을 변경해도 괜찮게 됨. <br />
여기서 헷갈렸던 부분은, swap chain 이미지가 여러개 있는 상황에서는 이전 render pass에서 presentation engine이 image를 사용하고 있더라도 이번 render pass에서는 layout transition을 해도 문제가 없지 않냐는 의문이었는데, 이 swap chain 이미지의 수와는 독립적으로 (최악의 경우 1개인 상황에서도) 실행에 문제가 없도록 보장하기 위한 내용이라고 이해하고 넘어갔다.</p>
</blockquote>

<p>이 시점에서 헷갈렸던 것이, 어떤 개념이 (commands, pipeline, render pass, subpass)이 실행 (execution)과 관련이 이떻게 있는지에 대한 큰 그림이었다.</p>

<p><a href="https://stackoverflow.com/questions/65047176/vulkan-is-the-rendering-pipeline-executed-once-per-subpass">https://stackoverflow.com/questions/65047176/vulkan-is-the-rendering-pipeline-executed-once-per-subpass</a></p>

<p>해당 내용을 찾아보다가 언급된 아래의 CG at TU wien Series영상을 보고 이런 큰 흐름을 이해하는데 도움이 되었다.</p>

<hr />
<h2 id="cg-at-tu-wien-ep7">CG at TU wien ep7</h2>

<p><a href="https://www.youtube.com/playlist?list=PLmIqTlJ6KsE1Jx5HV4sd2jOe3V1KMHHgn">https://www.youtube.com/playlist?list=PLmIqTlJ6KsE1Jx5HV4sd2jOe3V1KMHHgn</a></p>

<p>이 series 내용들을 통해 명확히 이해하지 않고 넘어갔던 개념들을 한 번 크게 볼 수 있었다. animation과 적절한 이미지가 곳곳에 등장해서 글로 정리할수 있는 부분은 많지 않은 것 같다. 마지막 내용인 synch 관련 내용만 정리해놓으려 한다.</p>

<h3 id="recap">recap</h3>
<h4 id="commands">commands</h4>
<ul>
  <li>state type
    <ul>
      <li>bind, set, pushConstants 등</li>
    </ul>
  </li>
  <li>action type
    <ul>
      <li>device에 특정 작업을 실행하는 명령들</li>
      <li>draw, transfer, dispatch, ray-tracing 관련</li>
    </ul>
  </li>
  <li>synchronization type
    <ul>
      <li>실행이나 리소스 접근의 synchronization</li>
      <li>pipeline barrier, waitEvent, begin renderPass 등</li>
      <li>예를 들어 fragment shader stage에서 draw call이 실행되기 전에, copy commands가 먼저 완료되도록 기다리는 것 등</li>
    </ul>
  </li>
</ul>

<h4 id="pipeline-stages">pipeline stages</h4>
<ul>
  <li>graphics
    <ul>
      <li>draw processing</li>
      <li>vertex processing</li>
      <li>tesselation</li>
      <li>primitive processing</li>
      <li>rasterization</li>
      <li>fragment processing</li>
      <li>pixel processing</li>
      <li>api나 용어 차이가 조금 있을 수 있겠지만 큰 개념들은 graphics 전반에 적용됨.
        <ul>
          <li>처음에 LVE에서 다룰땐 다음처럼 핵심만 간단히 다뤘었음.</li>
          <li>inpute assembles =&gt; vertex shader =&gt; rasterization =&gt;fragment shader =&gt; color blending</li>
        </ul>
      </li>
      <li>programmable한 vertex/fragment shader stage에 shader language로 compile된 코드를 업로드해서 GPU에서 실행.</li>
    </ul>
  </li>
  <li>compute
    <ul>
      <li>draw processing</li>
      <li>compute shader</li>
    </ul>
  </li>
  <li>ray tracing
    <ul>
      <li>위 두개와 다르게 분기와 cycle이 있는 directed graph형태의 stage</li>
      <li>acceleration structure traversal만 fixed function step이고 나머지는 configurable 하다고 함</li>
    </ul>
  </li>
</ul>

<h4 id="recording">recording</h4>
<p>command buffer에 여러 vkCmd가 recording 되고 (descriptor set binding 등도 포함)</p>
<ul>
  <li>이 command buffer들을 여러개로 한번에 묶어서 submitInfo에 담아 queue에 제출.</li>
  <li>single Time Command 등을 따로 구현해서 하나만 제출하고 바로 그 실행이 끝나기를 wait 하기도 함.</li>
  <li>하나의 command buffer에 여러 bind, draw, 등의 command를 호출해서 한번에 제출하는 형태의 구현을 써왔음</li>
  <li>여러개의 command buffer를 한번에 제출도 가능한데 그걸 batch라는 개념으로 쓰는 것 같음.</li>
  <li>영상에서는 recording 된 cmd들 사이의 순서를 강제하기 위한 신호등의 개념으로 synch를 설명한다.</li>
</ul>

<p>synchromization primitives의 간단한 설명들.</p>

<p>pipeline barrier</p>
<ul>
  <li>command buffer와 같이 recording 된다. <code class="language-plaintext highlighter-rouge">vkCmdPipelineBarrier()</code></li>
  <li>command 들의 내부 순서 뿐 아니라, 같은 queue에 이전에 제출된 command와  이후에 제출된 command 사이의 순서에도 사용된다. 그래서 command buffer의 경계가 pipeline barrier 입장에서는 중요치 않다.</li>
  <li>제출 순서 submission order가 중요한 개념이고, 반대로 semaphore 나 fence 에서는 이 command buffer boundary가 중요하다.</li>
</ul>

<p>fence와 semaphore</p>
<ul>
  <li>signaled state가 될때까지 wait하는 목적으로 사용됨</li>
  <li>semaphore는 device(GPU)에서 wait과정이 일어나지만</li>
  <li>fence의 wait는 host(CPU)에서 일어남</li>
</ul>

<h3 id="wait-idle-operation">wait idle operation</h3>
<p>queue나 device의 작업이 끝나서 idle 상태가 될때까지 기다리는 연산.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">vkQueueWaitIdle</code></li>
  <li><code class="language-plaintext highlighter-rouge">vkDeviceWaitIdle</code></li>
</ul>

<p>host side에서 device의 작업이 끝나고 idle 되기를 기다림.</p>

<h3 id="fences">fences</h3>
<p>먼저 sychronization scope 개념이 필요하다. 아직 이 문서를 세세히 읽어보지 않았는데, 가장 정확하게 개념을 이해할 수 있는 방식인 것 같다. 추후 필요한 내용을 추가해서 정리해야겠다.<br />
<a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-dependencies-scopes</a></p>

<p><code class="language-plaintext highlighter-rouge">synchronization scopes</code> 개념.</p>
<ul>
  <li>동기화 명령이 실행 의존을 만들수 있는 다른 명령들의 범위</li>
  <li>first scope와 second scope가 있다.</li>
  <li>실행 의존. execution dependency는 두 set of operations *(first, second scope)에서 first scope must happen-before the second scope의 실행 순서를 강제하는 개념.</li>
</ul>

<p><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-fences-signaling">https://registry.khronos.org/vulkan/specs/1.3-extensions/html/vkspec.html#synchronization-fences-signaling</a></p>

<p>fence 에서의 first, second scope.</p>
<ul>
  <li>fence에서는 first scope에 해당하는 명령들이, 같이 제출한 batch에 포함된 명령들과 그 이전에 제출된 모든 명령을 포함하고, second scope에는 fence signal operation만 포함한다.</li>
  <li>fence와 함께 제출된 command 들의 실행이 완료되면 fence가 signaled 된다고 이해하면 된다.</li>
</ul>

<h3 id="semaphores">semaphores</h3>
<p>queue 간의 synch를 맞추기 위한 것이라 보면 됨.</p>
<ul>
  <li>binary semaphore
    <ul>
      <li>원래 이 타입 밖에 없었어서, 이것만 지원하는 연산들이 있다고 함.</li>
      <li>device-device 간의 signal만 가능</li>
      <li>swap cahin 다룰때 쓰이는 예시가 대표적
        <ul>
          <li>presentation queue - graphics - queue</li>
        </ul>
      </li>
      <li>swapchain 예시에서 presentation engine은 abstraction을 통해 어떤 device (gpu1 or gpu2)가 실제도 acquire image와 present에서 사용되는지 구분하지 않는다고 함.</li>
      <li><a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_synchronization2.html">synchronization2</a> 의 기능들을 쓰면 더 효율적이라고 함.</li>
    </ul>
  </li>
  <li>timeline semaphore
    <ul>
      <li>상대적으로 새로 추가된 기능</li>
      <li>integer payload가 있어서, 증가시키는 형태로 사용됨. (이 값이 1일 필요는 없어서, actual milliseconds past등의 의미있는 값을 쓸 수 있다고 함.)</li>
      <li>host-device간의 소통이 가능해진게 특징.</li>
      <li>compute 관련 예씨
        <ul>
          <li>physics queue와 graphics queue간의 synch 문제</li>
          <li>physics에서 dispatch command로 physics simulation 계산을 한다고 하자.</li>
          <li>physic frame과 graphics frame 수가 같으면 문제가 없다.</li>
          <li>근데 physics frame은 60hz고, graphics는 가능한 많이 같이 다른 경우라고 가정해보자.</li>
          <li>draw call이 더 적은 경우, draw call이 더 많은 경우를 나눠서 발생가능한 문제들을 설명해줌(영상 참고)</li>
          <li>이런 상황에 timeline semaphore로 편하게 원하는 기능을 구현할 수 있다고 함.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="pipeline-barriers">pipeline barriers</h3>
<p>within a queue에관한 synchronization<br />
queue에 제출한 command 들이 시작하는 순서는 지켜지지만, 끝나는 순서는 out of order이므로 이 순서를 control 하기 위한 기능이다.</p>
<ul>
  <li>execution
    <ul>
      <li>각 command가 pipeline stage를 거쳐서 실행되는데, execution barrier를 지정해주면 더 효율적인 최적화가 가능하다. stage를 지정해주지 않으면 all commands에 대해서 동작한다.</li>
      <li>first synch scope에 해당하는 것은 submission order가 이른 commands중 src stage mask에 의해 지정된 pipeline stage에서의 연산들이다.</li>
      <li>second synch scope에 해당하는 것은 submission order가 늦은 commands 중 dst stage mask에 의해 지정된 pipeline stage에서의 연산들이다.</li>
      <li>영상에서 예시 상황을 묘사해줌</li>
    </ul>
  </li>
  <li>memory
    <ul>
      <li>한 자원에 write해놓고, 이후에 read하고 싶은 상황에서 실행 의존만으로 충분하지 않다. 메모리 구조 (캐시)와 관련된 내용인데, 이를 컨트롤 하기 위한 memory dependency 개념이 필요함</li>
      <li>access scope 개념이 추가된다.</li>
      <li>자원을 read할때 process 시작전에 cache에 들어있는지 확인을 하고, 비슷하게 written back to the resource도 다른 연산 시작전에 확인한다.</li>
    </ul>
  </li>
</ul>

<h3 id="memory-availability-and-visibility">memory availability and visibility</h3>
<p>이 부분은 specification 문서와 함께, 다음 글이 도움이 됐다.
<a href="https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/">https://themaister.net/blog/2019/08/14/yet-another-blog-explaining-vulkan-synchronization/</a></p>

<p>write operation의 state라고 볼 수 있다.</p>

<ul>
  <li>available
    <ul>
      <li>gpu의 L2 cache로 load된 상태</li>
    </ul>
  </li>
  <li>visible
    <ul>
      <li>L1 cache 로 load된 상태</li>
      <li>availablility에 pipeline stage와 access mask가 합쳐진 개념이라고 함.</li>
    </ul>
  </li>
  <li>한 shader stage에서 메모리에 write를 하고 나면, L2 cache는 더이상 up-to-date 하지 않게 되므로, available하지 않은 상태가된다.</li>
  <li>그래서 write 이후에는, 그 데이터가 미래에 visible 해지기 위해 먼저 available 해져야 한다.</li>
  <li>making memory available : about flushing caches</li>
  <li>making memory visible : invalidating caches</li>
</ul>

<p>메모리 의존을 availability operation과 visibility operation을 포함한 실행 의존으로 볼 수도 있는데, 다음과 같다.</p>
<ul>
  <li>1번 연산 set이 availability operation 이전에 일어난다.</li>
  <li>availability operation이 visibility opertion 이전에 일어난다.</li>
  <li>visibility operation이 2번 연산 set 이전에 일어난다.</li>
</ul>

<p>pipeline barrier에서 일어나는 4가지 순서를 좀 더 설명하면</p>
<ul>
  <li>src stage mask가 끝나기를 기다린다</li>
  <li>src stage mask와 src access mask조합 에서 일어난 writes 들을 available하게 만든다.</li>
  <li>available 해진 memory를 다음 dst stage mask와 dst access masmk 조합에 visible 하도록 만든다.</li>
  <li>dst stage mask의 작업을 unblock 한다.</li>
</ul>

<p>TOP_OF_PIPE / BOTTOM_OF_PIPE</p>
<ul>
  <li>이 가상의 stage를 쓸일들이 있는데, 이는 execution barrier를 위한 것이지 memory barrier와는 무관하다.</li>
  <li>이 단계들은 없는 실제로 없는 단계라 아무런 메모리 접근이 일어나지 않는다. 따라서 access mask는 0으로 지정해줘야한다.</li>
  <li>TOP_OF_PIPE 예시
    <ul>
      <li>이미지를 할당한 직후, layout transition을 하고 싶고, 아무것도 기다릴 게 없을때.</li>
      <li>flush out 될 writes가 없다. vulkan에서 새로 할당된 메모리는 항상 모든 stage와 access type에서 available and visible.</li>
      <li>src stage mask로 쓰였을 때, 아무것도 기다리지 않는다는 뜻이 된다.</li>
    </ul>
  </li>
  <li>BOTTOM_OF_PIPE 예시
    <ul>
      <li>swapchain이미지를 presentation engine에 넘기기 직전.</li>
      <li><code class="language-plaintext highlighter-rouge">VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</code>로 transition이 필요하다. (우리는 render pass 생성할 때 지정해놨다.)</li>
      <li>이 transition 이후에는 메모리를 visible하게 만들 stage가 없다.</li>
      <li>dst stage mask로 쓰였을 때, last stage를 block 시키겠다는 뜻으로, 이 barrier 이후의 기다려줘야 될 작업이 없다는 뜻이 된다.</li>
    </ul>
  </li>
</ul>

<h3 id="renderpass-subpass-dependencies">renderPass subpass dependencies</h3>
<p>image memory barrier와 크게 다를게 없다고 함. 대상이 특정 image memory가 아니고 attachment임.</p>

<p>render pass는 frame buffer의 attachments들이 어떻게 쓰일지를 describe.<br />
그리고 여러 subpass들 사이의 synchronization을 describe.</p>

<p>subpass dependecies는 해당 render pass 내부의 subpass 들 간의 internal과, 전/후 render pass와의 external synchronization이 가능.</p>

<h3 id="events">events</h3>
<ul>
  <li>split barrier</li>
  <li>set event 이전의 commands들이 wait event 이후의 commands들과 synchronized 되는 것.</li>
  <li>그 사이의 commands 들은 영향을 받지 않는다고 함.</li>
  <li>host communition이 가능하다는 특징</li>
  <li>아직 사용할 일이 없어서 자세히 보지 않았음.</li>
</ul>

<hr />
<h2 id="fix">fix</h2>
<p>기존 LVE 코드 구조와 vulkan-tutorial.com 에서의 코드 구조 차이가 있는 부분들이 있어서 여기서 수정하고 넘어갔다. 아마 기본 구조는 같은데, vulkan-tutorial.com의 repo history를 보니, 여러 PR들이 합쳐지면서 수정된 내용이 LVE 코드에 대응되는 비슷한 부분과 차이가 벌어졌던 것으로 보인다.</p>

<h3 id="frames-in-flight">frames in flight</h3>
<p>double-buffering 등의 개념은 LVE에서도 swapchain등을 다룰때 presentation mode등을 다루면서 한번 다뤘다.
기본적인 원리는, 다음의 세 단계에서 사용하는 자원들을 duplicate해서 동시에 실행하려는 목적이다.</p>
<ul>
  <li>command buffer recording and data upload</li>
  <li>GPU 실행</li>
  <li>presentation to monitor</li>
</ul>

<p>그래서 command buffer등을 2개로 나누면, 하나는 CPU에서 recording에 사용하고, 다른 하나는 GPU에서 실행하려는 개념인데, CPU에서 동시에 작업을 할 필요가 없는 자원은 이렇게 in-fight 수 만큼 나눌 필요가 없다.</p>

<h3 id="single-depth-buffer">single depth buffer</h3>

<p><a href="https://stackoverflow.com/questions/62371266/why-is-a-single-depth-buffer-sufficient-for-this-vulkan-swapchain-render-loop">https://stackoverflow.com/questions/62371266/why-is-a-single-depth-buffer-sufficient-for-this-vulkan-swapchain-render-loop</a></p>

<p>tutorial에 따른 depth buffer도 공통의 자원이므로 하나만 사용을 하는데, 이 stackoverflow 글에 의하면 하나의 depth buffer를 사용하면 첫 frame에서의 depth buffer가 fragment shader stage에서 사용되는 중에 그 다음 frame의 fragment shader stage에서도 동시에 사용을 하는 문제가 있어 추가적인 barrier가 필요하다고 한다. (swapchain image가 하나라면 발생하지 않을 문제)</p>

<p>그래서 코드 구현에서는 depth buffer도 frames-in-flight 수만큼 따로 생성해서 사용하는 구조로 유지하기로 결정했다.</p>

<h3 id="frame-buffer-and-swapchain-image">frame buffer and swapchain image</h3>

<p><a href="https://www.reddit.com/r/vulkan/comments/jtuhmu/synchronizing_frames_in_flight/">https://www.reddit.com/r/vulkan/comments/jtuhmu/synchronizing_frames_in_flight/</a></p>

<p>먼저 swapchain 이미지에 대해서 정리해보면, vulkan에서 window와 화면에 대한 것을 직접 다룰수 없어서 추상화된 개념인 surface를 이용하는 것처럼, device가 지원하는 swapchain 이미지 수 등도 surface capability query를 통해 미리 받아온다.</p>

<p><img src="/images/vulkan-tutorial-synch-1.png" alt="image" /></p>

<p>정리하면, swapchain 이미지의 수는 device나 driver의 api 구현에 따라서 suuport 하는 수가 달라 질 수 있고, frames-in-flight 수는 내가 구현할 present 정책에 따라 정할 수 있는 값이다.<br />
위 글에서는 이 두 값이 다를때 발생할 수 있는 문제 시나리오 상황에 대한 묘사가 나와있다. 그리고 이 문제는 tutorial code의 command recording 방식과 관련있었는데, 다음 부분에서 정리하겠다.</p>

<p><img src="/images/vulkan-tutorial-synch-2.png" alt="image" /></p>

<p>swapchain image index와 frame index를 출력해봤는데, 꼭 swapchain image index가 위처럼 순차적으로 얻어진다는 보장은 할 수 없다고 이해했다.</p>
<h3 id="additional-fence">additional fence</h3>

<p><a href="https://github.com/Overv/VulkanTutorial/issues/226">https://github.com/Overv/VulkanTutorial/issues/226</a><br />
여기 제시된 문제점이 위 글과 같은 내용으로 이해했는데, 결국 imagesInFlight라는 fence를 추가적으로 사용했던 코드가 여러 문제의 원인이 된다.<br />
이 fence를 사용한 이유는 tutorial code의 과거 구현 구조가, command buffer를 매 frame 마다 새로 recording 하는 것이 아니라 처음에 한번 recording 한 후 재사용하는 구조여서 그렇다.<br />
문제 상황은 frames-in-flight 수가 swapchain image 수보다 많거나, 혹은 swapchain image를 acquire 했을때 out of order로 나오는 상황 등으로 인해 index가 꼬이면서 생기는 경우이다.<br />
이런 문제를 막기 위해서 image index 각각을 frame index로 다시 mapping해서 (recently used) 그 mapped 된 frame의 fence를 additional fence로 추가해주는 구조로 이해했다. 결국 이런 fence의 사용이 비효율을 발생시키는 문제가 제기됐고, 수정 된 것으로 보인다.</p>

<p><a href="https://github.com/Overv/VulkanTutorial/pull/255">https://github.com/Overv/VulkanTutorial/pull/255</a></p>

<p>수정 된 내용을 보면 buffer와 descriptor, command buffer등이 swapchain image count가아니라, MAX_IMAGES_IN_FLIGHT 수 만큼 duplicate 되도록 수정되었는데, 그러면서 imagesInFlight의 fence가 자연스럽게 필요 없어졌다. LVE의 code에는 이런 변경이 일부만 반영되어 있었다고 보면 될 것 같고, 수정된 내용에 맞게 fence를 제거해주었다.</p>

<hr />
<h1 id="renderpass">RenderPass</h1>

<p>렌더패스에서 위의 framebuffer를 생성하기 전에 frame buffer의 foramt과 구조 사용할 attachment format과 종류등을 미리 지정해주는 청사진 역할을 한다고 보면 된다.</p>
<h2 id="framebuffer">FrameBuffer</h2>
<p>그래픽스 파이프라인의 결과가 저장될 리소스다.<br />
대부분 attachment의 형태로 렌더링 결과가 저장된다.</p>

<p><a href="https://stackoverflow.com/questions/39557141/what-is-the-difference-between-framebuffer-and-image-in-vulkan">https://stackoverflow.com/questions/39557141/what-is-the-difference-between-framebuffer-and-image-in-vulkan</a></p>

<p>Vulkan에서 frame buffer와 swapchain image의 관계에 대한 질문글을 봤다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">VkFramebuffer</code>와 <code class="language-plaintext highlighter-rouge">VkRenderPass</code>가 render target을 정의한다.</li>
  <li>renderPass가 어떤 attachment가 어떻게 사용될지를 정의한다.</li>
  <li><code class="language-plaintext highlighter-rouge">VkFramebuffer</code>의 attachment와 어떤 <code class="language-plaintext highlighter-rouge">VkImageView</code>가 연결될지 정의한다.</li>
  <li><code class="language-plaintext highlighter-rouge">VkImageView</code>는 <code class="language-plaintext highlighter-rouge">VkImage</code>의 어떤 파트를 사용할지를 정의한다.</li>
  <li><code class="language-plaintext highlighter-rouge">VkImage</code>는 어떤 <code class="language-plaintext highlighter-rouge">VkDeviceMemory</code>가 사용되고, 어떤 format을 사용할지 등을 정의한다.</li>
</ul>

<p>정리하면, swapChain image는 그냥 image의 한 종류인데, driver가 그 image를 소유할 뿐이다. 그래서 이걸 할당하거나 파괴할 수거 앖고, acquire를 통해서 presentation 전에 변경을 해놓을 뿐이라고 한다.<br />
swapChain image는 buffering이나 다른 advanced rendering을 통해 여러개가 있을수도 있고, 보통 image 개수마다 분리된 frame buffer를 두는게 일반적인 경우라고 한다.</p>

<h2 id="renderpass-1">RenderPass</h2>
<p>크게 세가지로 구성되는데,</p>
<ul>
  <li>attachments
    <ul>
      <li>렌더링 과정에서 사용할 이미지에 대한 정보이고, shader input이나 render target(color) 등을 명시한다.</li>
    </ul>
  </li>
  <li>subpass
    <ul>
      <li>렌더링 명령들의 step이라고 보면 된다.</li>
      <li>최적화가 중요한 모바일 GPU에서 유용한 개념이라고 한다.</li>
    </ul>
  </li>
  <li>subpass dependency
    <ul>
      <li>1개 이상의 subpass에서 그 subpass 들 간의 memory barrier 역할을 수행한다.</li>
      <li>renderpass 외부와의 dependency도 external을 통해 가능한데, implicit external subpass dependency도 있다. 이는 driver에 의해 기본으로 넣어지는 <code class="language-plaintext highlighter-rouge">vkCmdPipelineBarrier</code>라고 이해하면 된다.</li>
    </ul>
  </li>
</ul>

<hr />
<h1 id="마무리">마무리</h1>

<p>해당 주제들을 공부하면서 찾아본 내용들을 덕지덕지 링크로 걸어놨는데, 아직 다 이해하지 못한 내용들이 많다.<br />
그리고 검색해서 나온 내용들에는 잘못된 내용이나 질문글 같은 경우의 답변에는 신뢰도 문제도 있어서 주먹구구식으로 모를때 하나씩 검색하는 방식의 학습에 한계를 느꼈다.  <br />
Specification 문서를 보는게 정확한 내용을 습득하는 방법이겠지만 읽기 딱딱하기도 하고 효율성의 문제도 있다. 그럴때 잘 정리된 강좌를 순차적으로 보는게 도움이 많이 됐다.</p>

<p>직접 사용해서 만들어보면 전체 구조를 이해하는데 도움이 되기는하는데, 제대로 만든 것인지 검증하기가 애매하다는 문제가 있었다. (debugging tool로 <code class="language-plaintext highlighter-rouge">RenderDoc</code> 이라는 도구를 많이들 쓰는 것 같은데, 이후 검증이 필요할때 한번 사용법을 익히면 좋을 것 같다.)</p>

<p>아래 예시는 검증된 내용의 synchronization example 들이라서 비슷한 내용을 구현할 일이 생기면 참고할 용으로 남겨놨다.</p>

<p><a href="https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#transfer-dependencies">https://github.com/KhronosGroup/Vulkan-Docs/wiki/Synchronization-Examples#transfer-dependencies</a></p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[Vulkan Game Engine 영상에서 tutorial로 중간에 넘어오게 되면서, synchronization과 renderpass에서 가볍게 다루고 넘어간 내용들이 있어 구현에 헷갈리는 부분들이 있었다. 특히 pipeline barrier와 subpass dependency 관련 검색해본 내용들을 위주로 정리하고, 관련 자료들 link를 남겨놓으려 한다. 그리고 코드 구현에서 정확히 파악하고 있지 않은 부분들을 정리한 후, tutorial의 extra-chapter인 compute shader로 넘어가려 한다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vulkan-tutorial-synch-1.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vulkan-tutorial-synch-1.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Vulkan Tutorial - Generating mipmaps &amp;amp; MultiSampling</title><link href="https://keechang-choi.github.io/study/study-Vulkan-mipmap-multisampling/" rel="alternate" type="text/html" title="Vulkan Tutorial - Generating mipmaps &amp;amp; MultiSampling" /><published>2023-05-20T00:00:00+09:00</published><updated>2023-05-20T00:00:00+09:00</updated><id>https://keechang-choi.github.io/study/study-Vulkan-mipmap-multisampling</id><content type="html" xml:base="https://keechang-choi.github.io/study/study-Vulkan-mipmap-multisampling/"><![CDATA[<p>Mipmap과 MultiSampling에 관한 내용도 이전 little vulakn game engine tutorial 에서 한 번 다뤘던 주제들이다. 개념들을 정리하고 넘어가려 한다.</p>

<p>최근에 tutorial을 끝내고 예제들을 구현해보는 단계로 넘어가면서, 내용 정리를 제대로 하지 않았다. 빠르게 넘어가서 새로운 예제들 구현에 속도를 붙이려는 생각이 있었는데, 다시 복습하는 느낌으로 정리하고 확실히 하지 않고 넘어간 부분들은 좀 더 조사해서 정리해놓으려 한다.</p>

<ul>
  <li><a href="#generating-mipmaps">Generating Mipmaps</a>
    <ul>
      <li><a href="#intro">Intro</a></li>
      <li><a href="#image-creation">Image Creation</a></li>
      <li><a href="#generating-mipmaps-1">Generating Mipmaps</a></li>
      <li><a href="#linear-filtering-support">Linear filtering support</a></li>
      <li><a href="#sampler">Sampler</a></li>
      <li><a href="#mipmap-적용-예시">mipmap 적용 예시</a></li>
    </ul>
  </li>
  <li><a href="#multisampling">MultiSampling</a>
    <ul>
      <li><a href="#intro-1">Intro</a></li>
      <li><a href="#available-sample-count">Available sample count</a></li>
      <li><a href="#setting-up-a-render-target">Setting up a render target</a></li>
      <li><a href="#adding-new-attachments">Adding new attachments</a></li>
      <li><a href="#quality-improvements">Quality improvements</a></li>
    </ul>
  </li>
  <li><a href="#마무리">마무리</a></li>
</ul>

<hr />

<h1 id="generating-mipmaps">Generating Mipmaps</h1>
<p><a href="https://vulkan-tutorial.com/Generating_Mipmaps">vulkan-tutorial.com 해당 내용</a></p>

<h2 id="intro">Intro</h2>
<p>mipmap 생성을 추가하는 내용이다. vulkan에서는 우리가 직접 mipmap을 어떻게 생성할 건지에 대한 컨트롤을 전부 제공한다.
mipmap이란, 간단하게는 미리 계산된 축소된 이미지다. (어원은 라틴어로 작은 공간에 더 많다는 뜻이라고 한다) 구체적 단계(LOD: Level of Detail) 개념을 위해서 사용되는데, 각 단계마다 이미지의 크기를 절반으로 줄여놓은 mipmap을 사용해서 카메라 기준 멀리있는 물체의 texture를 sampling할때는 더 작은 sampler mip image를 사용하는 원리이다. 장점으로 렌더링 속도를 높이고, Moire pattern이 생기는 걸 방지할 수 있다.</p>

<p>어차피 멀리 있으면 결국 화면에 보여지는 크기가 작아지고, 물체 안의 픽셀 수도 작아지므로 필요한 resolution도 낮아진다. 자연스럽게 한 screen pixel안에 들어가는 texel의 수도 많아지게 될텐데 큰 크기의 texture를 사용할 필요가 없어진다.</p>

<p>정리하면, 물체와 카메라 사이의 거리가 가변적일때, mipmap을 사용해서 적당한 크기의 texture를 사용하게되면 다음과 같은 장점을 얻을 수 있어 자주 사용되는 기법이다.</p>
<ul>
  <li>멀리 있는 곳에서 발생하는 aliasing 효과 제거 (이 aliasing이 Moire pattern을 발생시킴)
    <ul>
      <li>screen의 해상도가 texture의 detail을 보여주기에 충분히 높지 않은 경우인 undersampling의 상황, 모든 display에는 해상도 한계가 있기때문에 어쩔수 없다.</li>
      <li>더 좋은 모니터를 쓰거나 MSAA 기법을 써도 되는데, 거리가 멀어진 물체를 표현할때만 이런 방식을 적용할 수는 없다. 이때 mipmap을 써서 texture의 해상도를 낮춰버리면 aliasing 현상을 없앨 수 있다.</li>
    </ul>
  </li>
  <li>큰 사이즈 대신 적절한 사이즈의 texture를 사용함으로써 cache effieciency를 높인다.</li>
</ul>

<h2 id="image-creation">Image Creation</h2>
<p>Vulkan에서는 이런 다른 mip level의 mip image들을 하나의 <code class="language-plaintext highlighter-rouge">VkImage</code>에 저장한다. 0 level을 original 이미지로 하고, 그 다음 레벨의 작은 이미지들의 mip chain을 직접 생성해서 저장할 수 있다.</p>

<p><code class="language-plaintext highlighter-rouge">VkImage</code>를 생성할 때 총 mipLevels가 몇개인지 명시해줄 수 있는데, 지금까지 이 argument를 1로 지정해왔다. 이를 적절한 크기로 바꾸고 이와 관련된 다음 부분들을 수정해야 한다.</p>
<ul>
  <li>createImage()</li>
  <li>createImageView()</li>
  <li>transitionImageLayout()</li>
</ul>

<p>https://github.com/keechang-choi/Vulkan-Game-Engine-Tutorial/commit/9443485e77792f6ffe09f10abf191336cbcd9da6</p>

<h2 id="generating-mipmaps-1">Generating Mipmaps</h2>

<p>이제 texture image에 여러 mip levels로 지정하여 생성하는 것은 완료했지만, 그 내용을 채워주지는 않았다. 기존의 staging buffer를 통해 transfer해주는 건 mipLevel 0의 original image에만 적용이 된다.</p>

<p>나머지 level의 이미지는 어떻게 채워줘야할까? <code class="language-plaintext highlighter-rouge">vkCmdBlitImage()</code>라는 command를 통해 채워넣을 수 있다. 이 command는 copy, scaling, filtering등을 지정해서 수행해준다. (blit: block of data를 옮기거나 copy)</p>

<p>이 연산을 각 레벨별로 호출해서 내용을 채우면 되는데, 이때 주의할 점이 몇가지 있다.</p>
<ul>
  <li>이 blit 연산은 <code class="language-plaintext highlighter-rouge">vkCmdCopy</code>와 같이 transfer operation에 해당하므로, 이미지를 생성할때, image usage를 trasfer src와 dst 모두 지정해줘야 한다.</li>
  <li>이미지의 layout도 transfer src optimal과 dst optimal을 지정해줘서, general인 layout보다 성능을 높이자.
    <ul>
      <li>기존에 텍스쳐 이미지 생성시 두었던 transition을 제거하고 mipmap 생성시에서 구현.</li>
    </ul>
  </li>
</ul>

<p>generateMipmaps()의 로직은 다음과 같다</p>
<ul>
  <li>command buffer recording 시작.</li>
  <li>i = 1부터 level iteration을 시작</li>
  <li>pipeline barrier로 i-1 level의 layout을 transfer dst optimal -&gt; src optimal로 지정하고, access mask는 trasfer write -&gt; read로 지정한다. stage mask는 transfer -&gt; transfer(이전 blit 연산과 초기 staging copy가 끝나게 기다린 후 새로운 blit을 준비시키는 역할)</li>
  <li>blit command로 i-1 level -&gt; i level을 채운다. 이때 blit src/dst offset을 mip 크기에 맞게 지정.</li>
  <li>pipeline barrier로 i-1 level의 layout을 transfer src opt -&gt; shader read only opt로 바꿔서 fragshader에서 읽을 준비, access mask는 transfer read -&gt; shader read, stage mask는 transfer -&gt; frag shader로 전환한다.</li>
  <li>mip크기를 절반으로 줄이고 이를 지정한 i=levels-1까지 반복한다. (지정할 레벨은 이미지 크기의 log_2 값으로 미리 지정)</li>
  <li>iteration이 끝나고, 마지막 mipLevels - 1 의 pipeline barrier를 수행한다.</li>
  <li>single Time command로 이를 제출한다.</li>
</ul>

<h2 id="linear-filtering-support">Linear filtering support</h2>

<p>device별로 linear filtering을 blit시에 지원하지 않는 경우도 있다고 한다. device에서 지원하지 않으면, format 변경을 통해 linear blitting을 지원하는 texture image format을 찾거나, 애초에 image loader에서 stb image resize 등으로 mipmap generating을 구현 할 수 있다.<br />
실제로 적용할때 runtime에 mipamp을 생성하는 경우는 거의 없다고 한다. 미리 생성해서 texture file에 저장을 해놓는 것이 일반적이기 때문이며, base level 0에 여러 level의 이미지를 한번에 넣어놓는 경우도 있다고 한다.<br />
3D model format인 glTF 포맷을 찾아보다가 알게된 내용인데, KTX라는 <a href="https://www.khronos.org/ktx/">Khronous Texture</a> format에서는 이 mipmap levels에 맞게 이미지를 저장해놓고 불러올 수 있는 기능이 있는 것 같다. (나는 아직은 이 format을 사용하지 않고 일반 png나 jpg로 텍스쳐를 불러온 다음 위처럼 직접 mipmap generating 하는 로직으로만 glTF format을 사용해본 상태다.)</p>

<h2 id="sampler">Sampler</h2>

<p>mipmap 데이터는 준비가 됐고, sampler에서 이 데이터를 어떻게 읽을지에 대한 지정도 필요하다.<br />
minLod, maxLod, mipLodBias등이 그 값인데, 이것들을 미리 지정해놓으면, sampler가 적절한 lod를 정해서(두 level의 결과를 blend하기도 하고) rendering에 사용한다고 한다. 이때 sampled point의 screen size 등을 고려해서 계산되도록 API 내부적으로 구현이 되어 있다는 것 같다. <br />
sampler에 지정해놨던 magFilter와 minFilter중 어떤것을 사용할지도 이 정해진 LOD값을 참고해서 결정되는데, camera로부터 멀리 있는 물체는 LOD값이 크게 되어 minFilter가 사용되고, 가까이 있는 경우는 LOD값이 작게되며 0인 경우는 magFilter를 사용하게 된다.</p>

<h2 id="mipmap-적용-예시">mipmap 적용 예시</h2>

<p>참고한 tutorial에서 사용된 viking room 모델을 두개를 띄워놓고, 좌측은 mipmap없이, 우측은 mipamp 적용하여 카메라와 거리를 다르게 해봤다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">left without mipmap, right with mipmap</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tutorial-mipmap-1.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tutorial-mipmap-2.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tutorial-mipmap-3.png)</td>
    </tr>
  </tbody>
</table>

<p>멀어질수록 LOD에따른 mipmap의 사용 효과가 나타난다. generate시 linear filtering을 사용했기때문에 우측 물체가 blur 된 것 같은 효과를 보인다.</p>

<h1 id="multisampling">MultiSampling</h1>

<p><a href="https://vulkan-tutorial.com/Multisampling">vulkan-tutorial.com의 해당 내용</a></p>

<h2 id="intro-1">Intro</h2>
<p>이제 LOD for texture가 가능해져서 물체가 카메라에서 멀어짐에따라 더 부드러워진 이미지를 확인 가능했다. 근데 렌더링된 이미지를 확대해보면 지그재그한 edge부분이 나타나는 경우들은 별개의 문제로 남았다.</p>

<p><img src="/images/vulkan-tutorial-msaa-1.png" alt="image" /></p>

<p>이런 효과를 aliasing이라고 지칭했는데, 렌더링에 사용가능한 픽셀의 수 (screen의 해상도)가 한정되어 있기 때문에, 모든 디스플레이에서 확대해보면 나타날 수 밖에 없다.</p>
<ul>
  <li>oversampling이 texture 의 detail이 부족해서 나타나는 현상이라면 undersampling은 screen의 detail이 부족해서 나타나는 현상이라고 정리했다. <br />
이 geometry의 edge에서 발생하는 aliasing은 screen의 pixel 한계 때문에 발생하는 undersampling이라고 볼 수 있다. (물체에 가까이 갔을때 texture 해상도가 낮아서 깨져보이는 oversampling과는 구분된다고 이해함.) screen 해상도가 높았다면 이런 계단 현상을 줄일 수 있었을 것이지만, 우리는 다른 해결법으로 MSAA(Multi Sampling Anti Aliasing)을 여기서 다룬다.</li>
  <li>이 기법을 직관적으로 보여주는 이미지가 tutorial에 제공되어 있다.</li>
  <li>일반적인 렌더링에서 픽셀의 색은 single sample point로부터 결정되는데, 대부분의 경우 그 점은 center of the target pixel on screen이다. 특정 선이 한 픽섹은 통과하면서 그 sample point를 포함하지 않으면 blank로 처리되면서 계단 효과가 발생한다.
<img src="https://vulkan-tutorial.com/images/aliasing.png" alt="image" /> <em><a href="https://vulkan-tutorial.com/images/aliasing.png">https://vulkan-tutorial.com/images/aliasing.png</a></em></li>
  <li>MSAA는 이 sample point를 여러개를 써서 최종색을 결정하는 방식이다. 더 좋은 결과의 이미지를 얻지만 계산상 비용이 더 든다. 그래서 app에 따라서 최대의 sample count를 쓰는게 performance 를 고려했을때 최선의 선택은 아닐 수 있다.
<img src="https://vulkan-tutorial.com/images/antialiasing.png" alt="image" /> <em><a href="https://vulkan-tutorial.com/images/antialiasing.png">https://vulkan-tutorial.com/images/antialiasing.png</a></em></li>
</ul>

<h2 id="available-sample-count">Available sample count</h2>

<p>하드웨어가 얼마나 많은 sample point를 지원하는지 알아보자. 보통 현대 GPU는 최소 8개 이상을 지원한다고 한다. <br />
physicalDeviceProperties에서 볼 수 있는데, depth buffer도 쓰고 있으니, color와 depth sample count를 모두 고려해야 한다.</p>

<p><img src="/images/vulkan-tutorial-msaa-2.png" alt="image" /></p>

<p>https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkSampleCountFlagBits.html</p>

<h2 id="setting-up-a-render-target">Setting up a render target</h2>

<p>MSAA에서 각 픽셀은 먼저 offscreen buffer에서 sampled 된 후, 화면으로 render된다.<br />
이 새로운 buffer는 렌더링 하고 있던 regular images와 약간 다른데, 각 픽셀당 하나 이상의 샘플을 저장해야 하기 때문이다.
multiSampled buffer가 생성되고 나며느 기존 default framebuffer로 resolved 되어야 한다.<br />
이를 위해서 새로운 render target을 생성해야 하는데, depth buffer 처럼 추가해주면 된다.<br />
tutorial에서는 depth buffer 처럼 in-flight frames 별로 하나씩이 아니라 공용으로 하나의 자원만 있으면 된다고 하는데, 이 부분에 확실치 않은 부분이 있어서 나는 각 in-flight frames 별로 하나씩 생성했다.</p>
<blockquote>
  <p>https://stackoverflow.com/questions/62371266/why-is-a-single-depth-buffer-sufficient-for-this-vulkan-swapchain-render-loop<br />
하나의 depth buffer만 사용하는 부분도 정확히 이해가 되지 않아서 좀 더 찾아보고 있는데, 각 frames in flight 별로 만드는게 확실한 방법 같다. 공용 자원으로 쓸 경우, subpass dependency를 추가하면 된다고 하는데 굳이 여기서 그렇게 구현할 필요는 없을 것 같다. resources &amp; synchronization 관련해서 개념이 부족한 것도 있고 tutorial 특성상 자세하게 다루지 않는 부분들도 꽤 있는 것 같아 다음 포스트에서 다른 자료들과 함께 정리하고 넘어가려 한다.</p>
</blockquote>

<p>createResource()에서 기존 1로 되어있던 numSamples를 지정할 수 있도록 추가하자. 그리고 depth image 들도 msaaSamples 수와 같도록 업데이트 해야 한다.</p>

<p>https://github.com/keechang-choi/Vulkan-Game-Engine-Tutorial/commit/2a1ef5b44d495a7192c8028c679bac20445c38e5</p>

<h2 id="adding-new-attachments">Adding new attachments</h2>

<p>렌더패스 생성 부분의 info를 수정한다. 그리고 기존 colorAttachment의 finalLayout을 present가 아니라, color attachment opt로 바꾼다. 이는 multiSampled된 이미지는 직적 present 할 수 없으므로,resolve하는 과정을 추가할 것이기 때문.<br />
그 후 frameBuffer에서도 attachemnt를 업데이트 하고 (index 주의), pipeline 생성에서도 msaaSamples를 가져쓰도록 변경하자. (device로부터)</p>

<p>https://github.com/keechang-choi/Vulkan-Game-Engine-Tutorial/commit/1f83d84cdf569d3f972030b5550f15e901cf6725</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">without MSAA</th>
      <th style="text-align: center">with MSAA</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tutorial-msaa-3.png)</td>
      <td style="text-align: center">![image](/images/vulkan-tutorial-msaa-4.png)</td>
    </tr>
    <tr>
      <td style="text-align: center">![image](/images/vulkan-tutorial-msaa-5.png)</td>
      <td style="text-align: center">![image](/images/vulkan-tutorial-msaa-6.png)</td>
    </tr>
  </tbody>
</table>

<h2 id="quality-improvements">Quality improvements</h2>

<p>shader aliasing에 의한 잠재적 문제를 해결하지 않았다고 한다. -&gt; geometry의 edge만 smoothing 해주고 있고 interior filling에 대한건 안다뤘기 때문.<br />
polygon은 smooth하면서, 내부 texture에 대비되는 색이 클 경우는 문제가 나타날 수 있다고 하고, sample shading을 적용하면 성능 감소는 있을수 있지만 해결된다고 함.</p>

<p>현재 예시에서는 뚜렷한 변화가 안보여서 우선 더 이상 자세히 찾아보지는 않았다.</p>

<hr />

<h1 id="마무리">마무리</h1>

<p>이제 vulkan-tutorial.com의 내용을 전부 다뤘다. extra-chapter인 compute shader가 있긴 한데, 그전에 resource와 synchronization 등을 좀 더 다루고 정리한 다음 compute shader를 다룬 후 이 tutorial 을 끝내려 한다.</p>

<p>이후에는 <a href="https://github.com/SaschaWillems/Vulkan">Sascha Williems의 Vulkan Example</a> 레포의 예제들을 보면서 하나씩 구현해보거나 그 구조를 바탕으로 구현하고 싶은 내용들을 다뤄보려 한다.</p>

<p>compute shader 관련해서는 우선 extra-chapter에서 기본적인 것들을 다룬 후, <a href="https://matthias-research.github.io/pages/index.html">Metthias Mueller의 PBD(Position Based Dynamics)</a>의 자료를 보고 적용해보고자 하는 생각이 있다.</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;links&quot;=&gt;[{&quot;title&quot;=&gt;nil, &quot;url&quot;=&gt;nil, &quot;icon&quot;=&gt;nil}]}</name></author><category term="study" /><category term="graphics" /><summary type="html"><![CDATA[Mipmap과 MultiSampling에 관한 내용도 이전 little vulakn game engine tutorial 에서 한 번 다뤘던 주제들이다. 개념들을 정리하고 넘어가려 한다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://keechang-choi.github.io/images/vulkan-tutorial-mipmap-2.png" /><media:content medium="image" url="https://keechang-choi.github.io/images/vulkan-tutorial-mipmap-2.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>